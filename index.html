Ã®<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Career Chute 3.0</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0e0f11;
  --panel: rgba(21, 23, 26, 0.8);
  --text: #f1f3f4;
  --muted: #9aa3ab;
  --accent: #5ad0ff;
  --ok: #79dd94;
  --warn: #ffbe5a;
  --bad: #ff6b6b;
  --line: rgba(255, 255, 255, 0.05);
  --success-glow: rgba(121, 221, 148, 0.4);
  
  /* Modern Design Tokens */
  --glass-bg: rgba(21, 23, 26, 0.8);
  --glass-border: rgba(255, 255, 255, 0.05);
  --shadow-soft: 0 4px 16px rgba(0, 0, 0, 0.12);
  --shadow-glow: 0 0 20px rgba(90, 208, 255, 0.3);
  --shadow-lift: 0 8px 24px rgba(0, 0, 0, 0.15);
  --gradient-primary: linear-gradient(135deg, #5ad0ff, #79dd94);
  --gradient-accent: linear-gradient(135deg, rgba(90, 208, 255, 0.8), rgba(90, 208, 255, 0.4));
  --backdrop-blur: blur(20px);
  --spring-easing: cubic-bezier(0.34, 1.56, 0.64, 1);
  
  /* Button Gradients - Dark Mode */
  --btn-primary: linear-gradient(135deg, #72cc99, #5fb885);
  --btn-secondary: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
  --btn-success: linear-gradient(135deg, #79dd94, #6bc584);
  --btn-warning: linear-gradient(135deg, #ffbe5a, #ffb84d);
  --btn-danger: linear-gradient(135deg, #ff6b6b, #ff5252);
}

/* Light Mode - Desert Clay Rose Design */
[data-theme="light"] {
  --bg: #faf8f5;
  --panel: rgba(255, 248, 245, 0.9);
  --text: #1a1a1a;
  --muted: #6b6b6b;
  --accent: #d97706;
  --ok: #059669;
  --warn: #d97706;
  --bad: #dc2626;
  --line: rgba(45, 45, 45, 0.08);
  --success-glow: rgba(5, 150, 105, 0.3);
  
  /* Light Mode Design Tokens */
  --glass-bg: rgba(255, 248, 245, 0.9);
  --glass-border: rgba(45, 45, 45, 0.08);
  --shadow-soft: 0 4px 16px rgba(0, 0, 0, 0.08);
  --shadow-glow: 0 0 20px rgba(217, 119, 6, 0.3);
  --shadow-lift: 0 8px 24px rgba(0, 0, 0, 0.12);
  --gradient-primary: linear-gradient(135deg, #2563eb, #1d4ed8);
  --gradient-accent: linear-gradient(135deg, rgba(217, 119, 6, 0.8), rgba(217, 119, 6, 0.4));
  
  /* Button Gradients - Light Mode */
  --btn-primary: linear-gradient(135deg, #72cc99, #5fb885);
  --btn-secondary: linear-gradient(135deg, rgba(45, 45, 45, 0.08), rgba(45, 45, 45, 0.04));
  --btn-success: linear-gradient(135deg, #059669, #047857);
  --btn-warning: linear-gradient(135deg, #f59e0b, #d97706);
  --btn-danger: linear-gradient(135deg, #dc2626, #b91c1c);
}

/* Color Theme A1 - Clean White */
[data-color-theme="A1"] {
  --bg: #ffffff;
  --panel: rgba(255, 255, 255, 0.9);
  --text: #1a1a1a;
  --muted: #6b6b6b;
  --accent: #72cc99;
  --ok: #059669;
  --warn: #d97706;
  --bad: #dc2626;
  --line: rgba(45, 45, 45, 0.08);
  --success-glow: rgba(5, 150, 105, 0.3);
  --glass-bg: rgba(255, 255, 255, 0.9);
  --glass-border: rgba(45, 45, 45, 0.08);
  --shadow-soft: 0 4px 16px rgba(0, 0, 0, 0.08);
  --shadow-glow: 0 0 20px rgba(114, 204, 153, 0.3);
  --shadow-lift: 0 8px 24px rgba(0, 0, 0, 0.12);
  --btn-primary: linear-gradient(135deg, #72cc99, #5fb885);
  --btn-secondary: linear-gradient(135deg, rgba(45, 45, 45, 0.08), rgba(45, 45, 45, 0.04));
}

/* Color Theme C3 - Warm Cream */
[data-color-theme="C3"] {
  --bg: #f6f4ed;
  --panel: rgba(246, 244, 237, 0.9);
  --text: #1a1a1a;
  --muted: #6b6b6b;
  --accent: #fcf9f2;
  --ok: #059669;
  --warn: #d97706;
  --bad: #dc2626;
  --line: rgba(45, 45, 45, 0.08);
  --success-glow: rgba(5, 150, 105, 0.3);
  --glass-bg: rgba(246, 244, 237, 0.9);
  --glass-border: rgba(45, 45, 45, 0.08);
  --shadow-soft: 0 4px 16px rgba(0, 0, 0, 0.08);
  --shadow-glow: 0 0 20px rgba(252, 249, 242, 0.3);
  --shadow-lift: 0 8px 24px rgba(0, 0, 0, 0.12);
  --btn-primary: linear-gradient(135deg, #fcf9f2, #f5f2e8);
  --btn-secondary: linear-gradient(135deg, rgba(45, 45, 45, 0.08), rgba(45, 45, 45, 0.04));
}

/* Color Theme E5 - Soft Gray */
[data-color-theme="E5"] {
  --bg: #fefbf4;
  --panel: rgba(254, 251, 244, 0.9);
  --text: #1a1a1a;
  --muted: #6b6b6b;
  --accent: #fefcf4;
  --ok: #059669;
  --warn: #d97706;
  --bad: #dc2626;
  --line: rgba(45, 45, 45, 0.08);
  --success-glow: rgba(5, 150, 105, 0.3);
  --glass-bg: rgba(254, 251, 244, 0.9);
  --glass-border: rgba(45, 45, 45, 0.08);
  --shadow-soft: 0 4px 16px rgba(0, 0, 0, 0.08);
  --shadow-glow: 0 0 20px rgba(254, 252, 244, 0.3);
  --shadow-lift: 0 8px 24px rgba(0, 0, 0, 0.12);
  --btn-primary: linear-gradient(135deg, #fefcf4, #f5f2e8);
  --btn-secondary: linear-gradient(135deg, rgba(45, 45, 45, 0.08), rgba(45, 45, 45, 0.04));
}

/* Typography */
body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
  font-variant-numeric: tabular-nums;
  letter-spacing: -0.01em;
}

.mono {
  font-family: 'JetBrains Mono', 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
  font-variant-numeric: tabular-nums;
}

/* Button Styles with Gradients */
.modern-button.primary {
  background: var(--btn-primary);
  border: none;
  color: white;
  font-weight: 600;
  letter-spacing: -0.01em;
}

.modern-button.primary:hover {
  background: var(--btn-primary);
  transform: translateY(-1px);
  box-shadow: var(--shadow-lift);
}

.modern-button.secondary {
  background: var(--btn-secondary);
  border: 1px solid var(--glass-border);
  color: var(--text);
  font-weight: 500;
}

.modern-button.secondary:hover {
  background: var(--btn-secondary);
  transform: translateY(-1px);
  box-shadow: var(--shadow-soft);
}

/* Success/Warning/Danger buttons */
.modern-button[style*="background: var(--ok)"] {
  background: var(--btn-success) !important;
  border: none !important;
  color: white !important;
}

.modern-button[style*="background: var(--warn)"] {
  background: var(--btn-warning) !important;
  border: none !important;
  color: white !important;
}

.modern-button[style*="background: var(--bad)"] {
  background: var(--btn-danger) !important;
  border: none !important;
  color: white !important;
}

@keyframes confetti {
  0% { 
    transform: translateY(0) rotate(0deg) scale(1); 
    opacity: 1; 
  }
  50% {
    transform: translateY(50vh) rotate(360deg) scale(1.2);
    opacity: 0.8;
  }
  100% { 
    transform: translateY(100vh) rotate(720deg) scale(0.5); 
    opacity: 0; 
  }
}

@keyframes celebrationPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes sparkle {
  0%, 100% { opacity: 0; transform: scale(0); }
  50% { opacity: 1; transform: scale(1); }
}

@keyframes slideIn {
  from { transform: translateY(20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes breathe {
  0%, 100% { transform: scale(1); opacity: 0.6; }
  50% { transform: scale(1.3); opacity: 1; }
}

@keyframes fadeUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Modern Design System Utility Classes */
.glass {
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  border: 1px solid var(--glass-border);
}

.glow {
  box-shadow: var(--shadow-glow);
}

.lift {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lift);
}

.spring {
  transition: all 400ms var(--spring-easing);
}

.fade-up {
  animation: fadeUp 400ms ease-out;
}

.glass-card {
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  border: 1px solid var(--glass-border);
  box-shadow: var(--shadow-soft);
  border-radius: 12px;
  transition: all 400ms var(--spring-easing);
}

.glass-card:hover {
  transform: translateY(-2px) scale(1.01);
  box-shadow: var(--shadow-lift), var(--shadow-glow);
}

.modern-button {
  height: 56px;
  border-radius: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 400ms var(--spring-easing);
  border: none;
  font-size: 16px;
  min-width: 140px;
}

.modern-button:hover {
  transform: translateY(-2px) scale(1.01);
  box-shadow: var(--shadow-glow);
}

.modern-button:active {
  transform: scale(0.98);
}

.modern-button.primary {
  background: var(--gradient-primary);
  color: white;
}

.modern-button.secondary {
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  border: 1px solid var(--glass-border);
  color: var(--text);
}

.modern-button.ghost {
  background: transparent;
  border: 1px solid var(--glass-border);
  color: var(--muted);
}

.modern-button.ghost:hover {
  background: var(--glass-bg);
  color: var(--text);
}

/* Focus Session Panel Styles */
.focus-block {
  width: 16px;
  height: 16px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.8);
  transition: all 400ms cubic-bezier(0.34, 1.56, 0.64, 1);
  position: relative;
  overflow: hidden;
}

.focus-block.filled {
  background: var(--ok);
  border-color: var(--ok);
  box-shadow: 0 0 8px rgba(121, 221, 148, 0.4);
  transform: scale(1.05);
}

.focus-block.queued {
  background: #ffbe5a;
  border-color: #ffbe5a;
  box-shadow: 0 0 8px rgba(255, 190, 90, 0.4);
}

.focus-block.active {
  background: var(--accent);
  border-color: var(--accent);
  box-shadow: 0 0 12px rgba(90, 208, 255, 0.6);
  animation: pulse 1s infinite;
}

.focus-block.filled::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
  animation: fillSweep 600ms ease-out;
}

@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.8; }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes rainbowCycle {
  0% { background: #ff0000; }
  16% { background: #ff8000; }
  33% { background: #ffff00; }
  50% { background: #00ff00; }
  66% { background: #0080ff; }
  83% { background: #8000ff; }
  100% { background: #ff0000; }
}

@keyframes yellowPulse {
  0%, 100% { background-color: rgba(255, 193, 7, 0.1); }
  50% { background-color: rgba(255, 193, 7, 0.3); }
}

.yellow-pulse {
  animation: yellowPulse 2s ease-in-out infinite;
}

@keyframes greenCycle {
  0% { background: #4ade80; }
  25% { background: #22c55e; }
  50% { background: #16a34a; }
  75% { background: #15803d; }
  100% { background: #4ade80; }
}

.rainbow-alert {
  animation: rainbowCycle 0.5s ease-in-out;
}

.green-alert {
  animation: greenCycle 0.8s ease-in-out;
}

@keyframes fillSweep {
  0% { left: -100%; }
  100% { left: 100%; }
}

.confetti-piece {
  position: fixed;
  width: 10px;
  height: 10px;
  animation: confetti 3s ease-out forwards;
  z-index: 9999;
}

.celebration-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  z-index: 9998;
  display: none;
  align-items: center;
  justify-content: center;
}

.celebration-overlay.active {
  display: flex;
  animation: slideIn 0.3s ease-out;
}

.breathing-circle {
  width: 150px;
  height: 150px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent), var(--ok));
  animation: breathe 19s ease-in-out infinite;
}

.breathing-text {
  position: absolute;
  font-size: 24px;
  font-weight: 600;
  color: var(--text);
  margin-top: 200px;
}

.sync-indicator {
  font-size: 12px;
  color: var(--muted);
  display: flex;
  align-items: center;
  gap: 6px;
}

.sync-indicator.syncing { color: var(--warn); }
.sync-indicator.synced { color: var(--ok); }

/* Theme Toggle Switch */
#themeToggle:checked + span {
  background-color: var(--accent);
}

#themeToggle:checked + span span {
  transform: translateX(26px);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.6;
  overflow-x: hidden;
  font-size: 16px;
}

.task-card {
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  border: 1px solid var(--glass-border);
  border-radius: 12px;
  padding: 24px;
  margin: 16px 0;
  cursor: pointer;
  transition: all 400ms var(--spring-easing);
  width: 100%;
  display: flex;
  align-items: center;
  gap: 20px;
  min-height: 80px;
  box-shadow: var(--shadow-soft);
}

.task-card:hover {
  transform: translateY(-2px) scale(1.01);
  box-shadow: var(--shadow-lift), var(--shadow-glow);
  border-color: var(--accent);
}

.task-card.urgent { border-left: 4px solid var(--bad); }
.task-card.soon { border-left: 4px solid var(--warn); }
.task-card.ok { border-left: 4px solid var(--ok); }

.screen {
  display: none;
  min-height: 100vh;
  padding: 40px;
  max-width: 1200px;
  margin: 0 auto;
}

.screen.active { display: block; }

#focusMode {
  background: var(--bg);
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px 20px;
}

.focus-timer {
  font-size: 72px;
  font-weight: 700;
  color: var(--accent);
  margin: 20px 0;
  font-variant-numeric: tabular-nums;
}

.focus-content {
  max-width: 600px;
  text-align: center;
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  padding: 40px;
  border-radius: 20px;
  border: 1px solid var(--glass-border);
  box-shadow: var(--shadow-lift);
}

.focus-title {
  font-size: 32px;
  font-weight: 700;
  margin-bottom: 20px;
  color: var(--accent);
  letter-spacing: -0.02em;
}

.focus-description {
  font-size: 18px;
  margin-bottom: 30px;
  line-height: 1.6;
}

.completion-criteria {
  background: var(--gradient-accent);
  backdrop-filter: var(--backdrop-blur);
  border: 1px solid var(--accent);
  border-radius: 12px;
  padding: 24px;
  margin: 20px 0;
  text-align: left;
  box-shadow: var(--shadow-soft);
}

.completion-criteria h4 {
  color: var(--accent);
  margin-bottom: 10px;
}

button {
  background: var(--gradient-primary);
  color: white;
  border: none;
  border-radius: 12px;
  padding: 16px 32px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 400ms var(--spring-easing);
  min-width: 140px;
  height: 56px;
}

button:hover {
  transform: translateY(-2px) scale(1.01);
  box-shadow: var(--shadow-glow);
}

button:active {
  transform: scale(0.98);
}

button.secondary {
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  border: 1px solid var(--glass-border);
  color: var(--text);
}

button.ghost {
  background: transparent;
  border: 1px solid var(--glass-border);
  color: var(--muted);
}

button.ghost:hover {
  background: var(--glass-bg);
  color: var(--text);
}

button.danger {
  background: var(--bad);
  color: white;
}

.btn-group {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  justify-content: center;
  margin-top: 24px;
}

.next-task-options {
  display: grid;
  gap: 20px;
  margin-top: 32px;
  max-width: 500px;
}

.next-task-options button {
  width: 100%;
  padding: 20px;
  font-size: 18px;
  text-align: left;
  display: flex;
  align-items: center;
  gap: 12px;
}

.header {
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  border: 1px solid var(--glass-border);
  padding: 24px;
  margin-bottom: 32px;
  border-radius: 12px;
  box-shadow: var(--shadow-soft);
}

.header h1 {
  font-size: 32px;
  font-weight: 700;
  margin-bottom: 8px;
  letter-spacing: -0.02em;
}

.header .subtitle {
  color: var(--muted);
  font-size: 13px;
  font-weight: 500;
  letter-spacing: -0.02em;
}

input, select, textarea {
  width: 100%;
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  border: 1px solid var(--glass-border);
  color: var(--text);
  border-radius: 12px;
  padding: 16px;
  font-size: 16px;
  font-family: inherit;
  height: 56px;
  transition: all 400ms var(--spring-easing);
}

input:focus, select:focus, textarea:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: var(--shadow-glow);
}

label {
  display: block;
  color: var(--muted);
  font-size: 13px;
  margin-bottom: 8px;
  font-weight: 500;
  letter-spacing: -0.02em;
}

.form-group {
  margin-bottom: 24px;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 20px;
  margin: 32px 0;
}

.stat-card {
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  border: 1px solid var(--glass-border);
  border-radius: 12px;
  padding: 24px;
  text-align: center;
  box-shadow: var(--shadow-soft);
  transition: all 400ms var(--spring-easing);
}

.stat-card:hover {
  transform: translateY(-2px) scale(1.01);
  box-shadow: var(--shadow-lift), var(--shadow-glow);
}

.stat-value {
  font-size: 36px;
  font-weight: 700;
  margin: 10px 0;
}

.stat-label {
  color: var(--muted);
  font-size: 14px;
}

progress {
  width: 100%;
  height: 8px;
  border-radius: 4px;
  margin-top: 8px;
}

progress::-webkit-progress-bar {
  background: #2b2f35;
  border-radius: 4px;
}

progress::-webkit-progress-value {
  background: var(--accent);
  border-radius: 4px;
}

.nav-bottom {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  border-top: 1px solid var(--glass-border);
  display: flex;
  justify-content: space-around;
  padding: 12px 0;
  z-index: 100;
  box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.12);
}

.nav-btn {
  background: transparent;
  border: none;
  color: var(--muted);
  font-size: 24px;
  padding: 8px 20px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  min-width: auto;
}

.nav-btn span {
  font-size: 11px;
}

.nav-btn.active {
  color: var(--accent);
}

.modal-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(8px);
  z-index: 2000;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.modal-overlay.active {
  display: flex;
  animation: fadeUp 400ms ease-out;
}

.modal {
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  border-radius: 20px;
  padding: 32px;
  max-width: 500px;
  width: 100%;
  max-height: 90vh;
  overflow-y: auto;
  border: 1px solid var(--glass-border);
  box-shadow: var(--shadow-lift);
}

.modal h2 {
  margin-bottom: 20px;
}

.exit-focus {
  position: fixed;
  top: 20px;
  left: 20px;
  background: transparent;
  border: 1px solid var(--line);
  color: var(--muted);
  font-size: 14px;
  padding: 8px 16px;
  min-width: auto;
  z-index: 1001;
}

.empty-state {
  text-align: center;
  padding: 60px 20px;
  color: var(--muted);
}

.empty-state-emoji {
  font-size: 64px;
  margin-bottom: 20px;
}

.list-item {
  background: var(--glass-bg);
  backdrop-filter: var(--backdrop-blur);
  border: 1px solid var(--glass-border);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: var(--shadow-soft);
  transition: all 400ms var(--spring-easing);
}

.list-item:hover {
  transform: translateY(-2px) scale(1.01);
  box-shadow: var(--shadow-lift), var(--shadow-glow);
}

.list-item-title {
  font-weight: 600;
  margin-bottom: 8px;
}

.list-item-meta {
  font-size: 14px;
  color: var(--muted);
}

.item-actions {
  display: flex;
  gap: 8px;
}

.icon-btn {
  background: transparent;
  border: none;
  color: var(--muted);
  font-size: 18px;
  padding: 4px 8px;
  cursor: pointer;
  min-width: auto;
}

.icon-btn:hover {
  color: var(--accent);
}

.badge {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
  margin-left: 8px;
}

.badge.queued { background: #2b2f35; color: var(--muted); }
.badge.tailoring { background: rgba(255, 190, 90, 0.2); color: var(--warn); }
.badge.ready { background: rgba(121, 221, 148, 0.2); color: var(--ok); }
.badge.sent { background: rgba(90, 208, 255, 0.2); color: var(--accent); }

.icon {
  font-size: 24px;
  flex-shrink: 0;
}

@media (max-width: 768px) {
  .screen {
    padding: 16px;
    padding-bottom: 120px; /* Extra padding to clear bottom nav + floating buttons */
  }
  
  /* Reduce form field heights on mobile */
  input, select, textarea {
    height: 28px;
    padding: 8px 12px;
    font-size: 14px;
  }
  
  textarea {
    height: auto;
    min-height: 60px;
  }
  
  #focusMode {
    padding: 20px 16px;
    justify-content: flex-start;
    padding-top: 60px;
  }
  
  .focus-content {
    max-width: 100%;
    width: 100%;
    padding: 24px 20px;
    margin: 0;
  }
  
  .focus-timer {
    font-size: 48px;
    margin: 16px 0;
  }
  
  .focus-title {
    font-size: 20px;
    margin-bottom: 16px;
  }
  
  .task-card {
    padding: 16px;
  }
  
  /* Focus mode button layout for mobile */
  #focusMode .focus-content > div:first-child {
    flex-direction: row;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 16px;
    justify-content: center;
  }
  
  #focusMode .focus-content > div:first-child button {
    flex: 1;
    min-width: 120px;
    height: 40px;
    font-size: 14px;
    padding: 0 12px;
  }
  
  /* Focus mode form elements */
  #focusMode textarea,
  #focusMode input {
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 12px;
  }
  
  /* Focus mode completion criteria */
  #focusMode .completion-criteria {
    font-size: 14px;
    line-height: 1.4;
    margin-bottom: 16px;
  }
}

/* iPhone 14 Pro Max specific optimizations */
@media (max-width: 430px) {
  #focusMode {
    padding: 16px 12px;
    padding-top: 50px;
  }
  
  .focus-content {
    padding: 20px 16px;
    border-radius: 16px;
  }
  
  .focus-timer {
    font-size: 42px;
    margin: 12px 0;
  }
  
  .focus-title {
    font-size: 18px;
    margin-bottom: 12px;
  }
  
  #focusMode .focus-content > div:first-child button {
    height: 40px;
    font-size: 13px;
    border-radius: 10px;
    padding: 0 10px;
  }
  
  /* General mobile button sizing */
  .modern-button {
    height: 44px;
    font-size: 14px;
    padding: 0 16px;
  }
  
  /* Task action buttons on mobile */
  .item-actions .icon-btn {
    width: 32px;
    height: 32px;
    font-size: 14px;
  }
  
  /* Ensure content fits within safe area */
  #focusMode .focus-content {
    max-height: calc(100vh - 100px);
    overflow-y: auto;
  }
}
</style>
</head>

<body>

<!-- Today Screen -->
<div id="today" class="screen active">
  <div style="position: sticky; top: 0; background: var(--bg); z-index: 10; padding: 16px 20px; border-bottom: 1px solid var(--line); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;">
    <div>
      <h1 style="margin: 0; font-size: 24px;">Today's Queue</h1>
      <div id="todayDate" style="font-size: 12px; color: var(--muted); margin-top: 2px; font-weight: 500;"></div>
    </div>
    <div style="display: flex; gap: 16px; align-items: center;">
      <div class="sync-indicator" id="syncStatus">
        <span>âï¸</span>
        <span id="syncText">Loading...</span>
      </div>
      <div style="text-align: center;">
        <div style="font-size: 11px; color: var(--muted); margin-bottom: 2px;">Apps</div>
        <div style="font-size: 18px; font-weight: 700;">
          <span id="todayAppsComplete" style="color: var(--bad);">0</span><span style="color: var(--text);">/</span><span id="todayAppsTarget">3</span>
        </div>
      </div>
      <div style="text-align: center;">
        <div style="font-size: 11px; color: var(--muted); margin-bottom: 2px;">Network</div>
        <div style="font-size: 18px; font-weight: 700;">
          <span id="todayNetComplete" style="color: var(--bad);">0</span><span style="color: var(--text);">/</span><span id="todayNetTarget">2</span>
        </div>
      </div>
      <div style="text-align: center;">
        <div style="font-size: 11px; color: var(--muted); margin-bottom: 2px;">Time</div>
        <div style="font-size: 18px; font-weight: 700;" id="todayTimeTotal">0m</div>
      </div>
      <div style="text-align: center; padding-left: 8px; border-left: 1px solid var(--line);">
        <div style="font-size: 20px;">ð¥</div>
        <div style="font-size: 14px; font-weight: 700;" id="todayStreak">0</div>
      </div>
    </div>
  </div>
  
  <!-- Redesigned Focus Session Panel -->
  <div id="focusSessionPanel" style="display: none; margin: 20px; padding: 20px; background: var(--glass-bg); backdrop-filter: var(--backdrop-blur); border: 1px solid var(--glass-border); border-radius: 16px; box-shadow: var(--shadow-soft);">
    
    <!-- Start Day Section -->
    <div id="startDaySection">
      <div style="text-align: center; margin-bottom: 20px;">
        <h3 style="color: var(--accent); font-size: 20px; font-weight: 600; margin: 0 0 16px 0;">ð¯ Focus Session</h3>
        <p style="color: var(--muted); font-size: 14px; margin: 0 0 20px 0;">Set your daily focus goal and start tracking your progress</p>
      </div>
      
      <div style="display: flex; flex-direction: column; align-items: center; gap: 16px;">
        <div style="display: flex; align-items: center; gap: 12px;">
          <label style="color: var(--text); font-size: 16px; font-weight: 500;">Daily Goal:</label>
          <select id="dailyGoalSelect" style="height: 40px; font-size: 16px; padding: 0 12px; border-radius: 8px; border: 1px solid var(--line); background: var(--bg); color: var(--text); width: 140px;">
            <option value="1">1 hour (4 blocks)</option>
            <option value="2">2 hours (8 blocks)</option>
            <option value="3">3 hours (12 blocks)</option>
            <option value="4" selected>4 hours (16 blocks)</option>
            <option value="5">5 hours (20 blocks)</option>
            <option value="6">6 hours (24 blocks)</option>
            <option value="7">7 hours (28 blocks)</option>
            <option value="8">8 hours (32 blocks)</option>
          </select>
        </div>
        
        <button onclick="startNewFocusDay()" class="modern-button primary" style="height: 44px; padding: 0 24px; font-size: 16px; font-weight: 600;">Start Focus Day</button>
      </div>
    </div>
    
    <!-- Active Session Section -->
    <div id="activeSessionSection" style="display: none;">
      <!-- Header - Ultra Compact -->
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; flex-wrap: wrap; gap: 8px;">
        <div style="display: flex; align-items: center; gap: 8px;">
          <h3 style="margin: 0; color: var(--accent); font-size: 16px;">ð¯ Focus Session</h3>
          <span id="sessionStartTime" style="color: var(--muted); font-size: 12px;">Started: --:--</span>
          <span onclick="showFocusInstructions()" style="width: 16px; height: 16px; border-radius: 50%; border: 1px solid var(--line); background: var(--bg); color: var(--muted); cursor: pointer; display: inline-block; text-align: center; line-height: 14px; font-size: 9px; font-weight: bold; margin-left: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--accent)'; this.style.color='white';" onmouseout="this.style.background='var(--bg)'; this.style.color='var(--muted)';" title="Focus Session Instructions">â¹</span>
        </div>
        <div style="display: flex; align-items: center; gap: 6px;">
          <label style="color: var(--text); font-size: 12px;">Goal:</label>
          <select id="activeDailyGoalSelect" onchange="updateDailyGoal()" style="height: 26px; font-size: 11px; padding: 0 4px; border-radius: 4px; border: 1px solid var(--line); background: var(--bg); color: var(--text); width: 60px;">
            <option value="1">1h</option>
            <option value="2">2h</option>
            <option value="3">3h</option>
            <option value="4">4h</option>
            <option value="5">5h</option>
            <option value="6">6h</option>
            <option value="7">7h</option>
            <option value="8">8h</option>
          </select>
          <span id="progressText" style="color: var(--muted); font-size: 11px;">0/16</span>
          <span id="totalTimeText" style="color: var(--accent); font-size: 11px; font-weight: 500;">Total: 0m</span>
        </div>
      </div>
      
      
      <!-- Progress Blocks - Compact -->
      <div style="margin-bottom: 8px;">
        <div id="blockGrid" style="display: flex; gap: 2px; flex-wrap: wrap; justify-content: center; padding: 6px; background: rgba(0,0,0,0.1); border-radius: 4px; min-height: 28px;"></div>
      </div>
      
      <!-- Controls - Single Row -->
      <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px; margin-bottom: 8px;">
        <!-- Left: Chunk Controls -->
        <div style="display: flex; align-items: center; gap: 4px;">
          <select id="chunkDuration" style="height: 26px; font-size: 11px; padding: 0 4px; border-radius: 4px; border: 1px solid var(--line); background: var(--bg); color: var(--text); width: 60px;">
            <option value="15">15m</option>
            <option value="30">30m</option>
            <option value="45" selected>45m</option>
            <option value="60">60m</option>
            <option value="90">90m</option>
            <option value="120">120m</option>
          </select>
          <button id="startChunkBtn" onclick="startFocusChunk()" class="modern-button primary" style="height: 26px; padding: 0 8px; font-size: 11px; width: auto; min-width: 0;">Start</button>
        </div>
        
        <!-- Right: Action Buttons -->
        <div style="display: flex; gap: 4px;">
          <button onclick="resetFocusProgress()" class="modern-button secondary" style="height: 26px; padding: 0 8px; font-size: 11px; width: auto; min-width: 0;">Reset</button>
          <button onclick="endFocusDay()" class="modern-button" style="height: 26px; padding: 0 8px; font-size: 11px; background: var(--warn); width: auto; min-width: 0;">End</button>
        </div>
      </div>
      
      <!-- Active Chunk Display -->
      <div id="activeChunkSection" style="display: none; padding: 12px; background: rgba(90, 208, 255, 0.1); border: 1px solid rgba(90, 208, 255, 0.3); border-radius: 6px; margin-bottom: 12px;">
        <div style="text-align: center; margin-bottom: 8px;">
          <span style="color: var(--accent); font-size: 14px; font-weight: 600;">Chunk Active</span>
          <div id="chunkProgress" style="color: var(--muted); font-size: 10px; margin-top: 2px;">0/3 blocks completed</div>
        </div>
        <div id="chunkTimer" class="mono" style="font-size: 20px; font-weight: 600; color: var(--accent); text-align: center; margin-bottom: 8px;">00:00</div>
        <div style="display: flex; gap: 6px; justify-content: center; flex-wrap: wrap;">
          <button id="pauseChunkBtn" onclick="pauseFocusChunk()" class="modern-button secondary" style="height: 28px; padding: 0 8px; font-size: 10px; min-width: 60px;">â¸ï¸ Pause</button>
          <button id="finishChunkBtn" onclick="finishFocusChunk()" class="modern-button" style="height: 28px; padding: 0 8px; font-size: 10px; background: var(--ok); min-width: 60px;">â Finish</button>
        </div>
      </div>
    </div>
  </div>
  
  <div style="padding: 20px;">
    <div id="todayTasks" style="margin-bottom: 120px;"></div>
  </div>
  
  <button onclick="showAddTaskModal()" class="secondary" style="position: fixed; bottom: 100px; left: 20px; right: 20px; max-width: 1160px; margin: 0 auto; z-index: 50; box-shadow: 0 -4px 16px rgba(0,0,0,0.12);">+ Add Task for Today</button>
</div>

<!-- Plan Screen -->
<div id="plan" class="screen">
  <div class="header" style="margin-bottom: 20px;">
    <h1 style="margin-bottom: 4px;">Weekly Plan</h1>
    <div class="subtitle">Manage your pipeline</div>
  </div>
  
  <div style="margin-bottom: 20px;">
    <h3 style="margin-bottom: 8px; font-size: 16px;">This Week's Targets</h3>
    <div class="stats-grid" style="grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
      <div class="stat-card" style="padding: 12px; display: flex; flex-direction: column; gap: 4px;">
        <div class="stat-label" style="font-size: 12px;">Applications</div>
        <div class="stat-value" style="font-size: 20px; margin: 0;"><span id="planAppsProgress">0</span>/<span id="planAppsTarget">15</span></div>
        <progress id="planAppsBar" value="0" max="15" style="width: 100%; height: 4px;"></progress>
      </div>
      <div class="stat-card" style="padding: 12px; display: flex; flex-direction: column; gap: 4px;">
        <div class="stat-label" style="font-size: 12px;">Networking</div>
        <div class="stat-value" style="font-size: 20px; margin: 0;"><span id="planNetProgress">0</span>/<span id="planNetTarget">10</span></div>
        <progress id="planNetBar" value="0" max="10" style="width: 100%; height: 4px;"></progress>
      </div>
      <div class="stat-card" style="padding: 12px; display: flex; flex-direction: column; gap: 4px;">
        <div class="stat-label" style="font-size: 12px;">Events</div>
        <div class="stat-value" style="font-size: 20px; margin: 0;"><span id="planEventsProgress">0</span>/<span id="planEventsTarget">1</span></div>
        <progress id="planEventsBar" value="0" max="1" style="width: 100%; height: 4px;"></progress>
      </div>
    </div>
  </div>
  
  <div style="margin-bottom: 30px;">
    <h3 style="margin-bottom: 16px;">Applications Pipeline</h3>
    <button onclick="showAddAppModal()" class="secondary" style="width: 100%; margin-bottom: 16px;">+ Add New Application</button>
    <div id="appsList"></div>
  </div>
  
  <div style="margin-bottom: 30px;">
    <h3 style="margin-bottom: 16px;">Networking Queue</h3>
    <button onclick="showAddContactModal()" class="secondary" style="width: 100%; margin-bottom: 16px;">+ Add Contact</button>
    <div id="contactsList"></div>
  </div>
  
  <div style="margin-bottom: 100px;">
    <h3 style="margin-bottom: 16px;">Upcoming Events</h3>
    <button onclick="showAddEventModal()" class="secondary" style="width: 100%; margin-bottom: 16px;">+ Add Event</button>
    <div id="eventsList"></div>
  </div>
</div>

<!-- Progress Screen -->
<div id="progress" class="screen">
  <div class="header">
    <h1>Progress</h1>
    <div class="subtitle">Track your job search journey</div>
  </div>
  
  <!-- New condensed dashboard -->
  <div id="progressDashboard"></div>
  
  <!-- Analytics Section -->
  <div id="analyticsSection" style="margin: 20px; padding: 24px; background: var(--glass-bg); backdrop-filter: var(--backdrop-blur); border: 1px solid var(--glass-border); border-radius: 16px; box-shadow: var(--shadow-soft);">
    <h2 style="margin: 0 0 20px 0; color: var(--accent); font-size: 24px; display: flex; align-items: center; gap: 8px;">
      ð Analytics
    </h2>
    
    <!-- Daily Focus Summary -->
    <div id="dailyFocusSummary" style="margin-bottom: 24px;">
      <h3 style="margin: 0 0 16px 0; color: var(--text); font-size: 18px;">Today's Focus</h3>
      <div id="dailyFocusCard" style="padding: 20px; background: rgba(0,0,0,0.1); border-radius: 12px; text-align: center;">
        <div style="color: var(--muted); font-size: 14px; margin-bottom: 8px;">No focus session today</div>
        <div style="font-size: 12px; color: var(--muted);">Start a focus session to see your analytics</div>
      </div>
    </div>
    
    <!-- Weekly Overview -->
    <div id="weeklyOverview" style="margin-bottom: 24px;">
      <h3 style="margin: 0 0 16px 0; color: var(--text); font-size: 18px;">This Week</h3>
      <div id="weeklyFocusGrid" style="display: grid; grid-template-columns: repeat(7, minmax(0, 1fr)); gap: 4px; margin-bottom: 16px; overflow-x: auto; padding: 4px;">
        <!-- 7 days will be populated here -->
      </div>
      <div id="weeklyStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px;">
        <div style="text-align: center; padding: 12px; background: rgba(0,0,0,0.1); border-radius: 8px;">
          <div class="mono" style="font-size: 20px; font-weight: 600; color: var(--accent);" id="weeklyTotalBlocks">0</div>
          <div style="font-size: 12px; color: var(--muted);">Blocks</div>
        </div>
        <div style="text-align: center; padding: 12px; background: rgba(0,0,0,0.1); border-radius: 8px;">
          <div class="mono" style="font-size: 20px; font-weight: 600; color: var(--ok);" id="weeklyOnTaskPct">0%</div>
          <div style="font-size: 12px; color: var(--muted);">On-task</div>
        </div>
        <div style="text-align: center; padding: 12px; background: rgba(0,0,0,0.1); border-radius: 8px;">
          <div class="mono" style="font-size: 20px; font-weight: 600; color: var(--warn);" id="weeklyStreak">0</div>
          <div style="font-size: 12px; color: var(--muted);">Day Streak</div>
        </div>
      </div>
    </div>
    
    <!-- Badges & Achievements -->
    <div id="badgesSection" style="margin-bottom: 24px;">
      <h3 style="margin: 0 0 16px 0; color: var(--text); font-size: 18px;">ð Achievements</h3>
      <div id="badgesGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px; margin-bottom: 16px;">
        <!-- Badges will be populated here -->
      </div>
      <div id="streakStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 12px;">
        <div style="text-align: center; padding: 12px; background: rgba(0,0,0,0.1); border-radius: 8px;">
          <div class="mono" style="font-size: 18px; font-weight: 600; color: var(--warn);" id="currentStreak">0</div>
          <div style="font-size: 11px; color: var(--muted);">Current Streak</div>
        </div>
        <div style="text-align: center; padding: 12px; background: rgba(0,0,0,0.1); border-radius: 8px;">
          <div class="mono" style="font-size: 18px; font-weight: 600; color: var(--accent);" id="longestStreak">0</div>
          <div style="font-size: 11px; color: var(--muted);">Best Streak</div>
        </div>
        <div style="text-align: center; padding: 12px; background: rgba(0,0,0,0.1); border-radius: 8px;">
          <div class="mono" style="font-size: 18px; font-weight: 600; color: var(--ok);" id="totalBadges">0</div>
          <div style="font-size: 11px; color: var(--muted);">Badges Earned</div>
        </div>
      </div>
    </div>
    
    <!-- Insights & Achievements -->
    <div id="insightsSection">
      <h3 style="margin: 0 0 16px 0; color: var(--text); font-size: 18px;">Insights</h3>
      <div id="insightsCard" style="padding: 20px; background: linear-gradient(135deg, rgba(90, 208, 255, 0.1), rgba(121, 221, 148, 0.1)); border-radius: 12px; border: 1px solid rgba(90, 208, 255, 0.2);">
        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
          <div style="font-size: 24px;">ð¯</div>
          <div>
            <div style="font-weight: 600; color: var(--text); font-size: 16px;" id="insightTitle">Ready to Focus</div>
            <div style="color: var(--muted); font-size: 14px;" id="insightSubtitle">Start your first focus session to unlock insights</div>
          </div>
        </div>
        <div style="font-size: 14px; color: var(--text);" id="insightText">
          Your focus analytics will appear here once you start tracking your work sessions.
        </div>
      </div>
    </div>
  </div>
  
  <!-- Application History -->
  <div id="applicationHistorySection" style="margin: 20px; padding: 24px; background: var(--glass-bg); backdrop-filter: var(--backdrop-blur); border: 1px solid var(--glass-border); border-radius: 16px; box-shadow: var(--shadow-soft);">
    <h2 style="margin: 0 0 20px 0; color: var(--accent); font-size: 24px; display: flex; align-items: center; gap: 8px;">
      ð Application History
    </h2>
    <div id="applicationHistory"></div>
  </div>

  <!-- Legacy layout (hidden) -->
  <div id="progressLegacy" style="display:none; background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 20px; margin: 0 0 20px;">
    <h3 style="margin-bottom: 16px;">This Week</h3>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
      <span style="color: var(--muted);">Week Progress</span>
      <span style="font-weight: 600;" id="progressWeekDay">Day 1 of 7</span>
    </div>
    <div style="display: flex; gap: 8px; margin-bottom: 20px;">
      <div id="progressWeekDots"></div>
    </div>
    
    <div style="text-align: center; padding: 20px; background: linear-gradient(135deg, rgba(255, 190, 90, 0.2), rgba(255, 107, 107, 0.2)); border-radius: 12px; margin-bottom: 20px;">
      <div style="font-size: 48px; margin-bottom: 8px;">ð¥</div>
      <div style="font-size: 36px; font-weight: 700; margin-bottom: 4px;" id="progressStreakCount">0</div>
      <div style="font-size: 14px; color: var(--muted);">day streak</div>
      <div style="font-size: 12px; color: var(--muted); margin-top: 8px;">Best: <span id="progressStreakBest">0</span> days</div>
    </div>
    
    <div style="display: grid; gap: 12px;">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span>Applications</span>
        <span id="progressAppsStatus">0/15</span>
      </div>
      <progress id="progressAppsBar" value="0" max="15"></progress>
      
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span>Networking</span>
        <span id="progressNetStatus">0/10</span>
      </div>
      <progress id="progressNetBar" value="0" max="10"></progress>
      
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span>Events</span>
        <span id="progressEventsStatus">0/1</span>
      </div>
      <progress id="progressEventsBar" value="0" max="1"></progress>
    </div>
    
    <div id="progressOnTrack" style="margin-top: 20px; padding: 16px; border-radius: 12px; text-align: center; font-weight: 600;"></div>
  </div>
  
  <div style="display:none; background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 20px; margin: 0 0 20px;">
    <h3 style="margin-bottom: 16px;">Time This Week</h3>
    <div style="display: grid; gap: 12px;">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span>Optimization Work</span>
        <span id="progressWeekOptTime">0 min</span>
      </div>
      <div style="font-size: 12px; color: var(--muted);">Resume tweaking, strategy</div>
      
      <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 12px;">
        <span>Execution Work</span>
        <span id="progressWeekExecTime">0 min</span>
      </div>
      <div style="font-size: 12px; color: var(--muted);">Applications, networking, events</div>
    </div>
  </div>
  
  <div style="display:none; background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 20px; margin: 0 0 100px;">
    <h3 style="margin-bottom: 16px;">Application History</h3>
    <div id="applicationHistory"></div>
  </div>
</div>

<!-- Job Queue Screen -->
<div id="jobs" class="screen">
  <div class="header">
    <h1>Job Queue</h1>
    <div class="subtitle">Manage and prioritize your job applications</div>
  </div>
  
  <!-- Job Prioritization Rules Section -->
  <div style="background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 20px; margin-bottom: 24px;">
    <h3 style="margin: 0 0 16px 0; font-size: 16px;">Job Prioritization Rules</h3>
    <div id="prioritizationSettings">
      <!-- Settings will be populated by JavaScript -->
    </div>
  </div>
  
  <!-- City Grading Section -->
  <div style="background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 20px; margin-bottom: 24px;">
    <h3 style="margin: 0 0 16px 0; font-size: 16px;">City Grading Rules</h3>
    <div id="cityGradingSettings">
      <!-- Settings will be populated by JavaScript -->
    </div>
  </div>
  
  <!-- ARCHIVED: Email scanning removed - manual entry only -->
  <!-- Job Queue Controls -->
  <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; align-items: center;">
    <button class="modern-button secondary" onclick="addJobManually()" title="Manually add a job to the queue">
      â Add Job Manually
    </button>
    <div style="border-left: 1px solid var(--line); height: 32px; margin: 0 4px;"></div>
    <span style="font-size: 13px; color: var(--muted);" id="selectedCount">0 selected</span>
    <button class="modern-button secondary" onclick="addSelectedToPipeline()" title="Add selected jobs to your Applications Pipeline">
      ð Add to Pipeline
    </button>
    <button class="modern-button secondary" onclick="bulkDeleteJobs()" title="Delete selected jobs">
      ðï¸ Delete Selected
    </button>
  </div>
  
  <!-- Bulk Selection Dropdown -->
  <div style="margin: 12px 0; display: flex; align-items: center; gap: 8px;">
    <select id="bulkSelectDropdown" onchange="handleBulkSelection(this.value)" style="
      background: var(--panel); 
      border: 1px solid var(--line); 
      border-radius: 6px; 
      padding: 6px 12px; 
      color: var(--text); 
      font-size: 13px;
      cursor: pointer;
    ">
      <option value="">Select by grade...</option>
      <option value="all">â All Jobs</option>
      <option value="A">ð¢ Grade A (Green)</option>
      <option value="B">ð  Grade B (Orange)</option>
      <option value="C">ð´ Grade C (Red)</option>
      <option value="ungraded">âª Ungraded (Gray)</option>
    </select>
    <button onclick="clearAllSelections()" style="
      background: var(--panel); 
      border: 1px solid var(--line); 
      border-radius: 6px; 
      padding: 6px 12px; 
      color: var(--text); 
      font-size: 13px;
      cursor: pointer;
    ">Clear All</button>
  </div>
  
  <!-- Job Queue Table -->
  <div style="background: var(--panel); border: 1px solid var(--line); border-radius: 12px; overflow: hidden; margin-bottom: 120px;">
    <div id="jobQueueTable">
      <!-- Table will be populated by JavaScript -->
    </div>
  </div>
  
  <!-- Job Prioritization Settings Modal -->
  <div id="jobPrioritizationModal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 800px;">
      <div class="modal-header">
        <h3>Job Prioritization Rules</h3>
        <button class="modal-close" onclick="closeJobPrioritizationSettings()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="prioritizationSettings">
          <!-- Settings will be populated by JavaScript -->
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Field Mapping Training Screen -->
<div id="mapping" class="screen">
  <div class="header">
    <h1>Email Parser Management</h1>
    <p style="color: var(--muted); margin-top: 8px;">Monitor and improve email parsing accuracy across all job sources</p>
  </div>
  
  <!-- Parser Statistics Dashboard -->
  <div style="background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 20px; margin-bottom: 24px;">
    <h3 style="margin: 0 0 16px 0;">ð Parsing Statistics</h3>
    <div id="parserStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 16px;">
      <div style="background: var(--bg); padding: 12px; border-radius: 8px; text-align: center;">
        <div style="font-size: 24px; font-weight: 700; color: var(--accent);" id="totalEmailsProcessed">0</div>
        <div style="font-size: 12px; color: var(--muted);">Emails Processed</div>
      </div>
      <div style="background: var(--bg); padding: 12px; border-radius: 8px; text-align: center;">
        <div style="font-size: 24px; font-weight: 700; color: var(--ok);" id="parsingAccuracy">0%</div>
        <div style="font-size: 12px; color: var(--muted);">Accuracy Rate</div>
      </div>
      <div style="background: var(--bg); padding: 12px; border-radius: 8px; text-align: center;">
        <div style="font-size: 24px; font-weight: 700; color: var(--warn);" id="correctionsMade">0</div>
        <div style="font-size: 12px; color: var(--muted);">Corrections Made</div>
      </div>
      <div style="background: var(--bg); padding: 12px; border-radius: 8px; text-align: center;">
        <div style="font-size: 24px; font-weight: 700; color: var(--accent);" id="lastScanTime">Never</div>
        <div style="font-size: 12px; color: var(--muted);">Last Scan</div>
      </div>
    </div>
    <button onclick="loadMappingTrainingData()" class="modern-button primary" style="height: 36px; padding: 0 16px;">
      ð§ Load Recent Emails for Training
    </button>
  </div>
  
  <!-- Parser Rules Explanation -->
  <div style="background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 20px; margin-bottom: 24px;">
    <h3 style="margin: 0 0 16px 0;">ð§ Parser Rules & Logic</h3>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
      <!-- Subject Line Patterns -->
      <div>
        <h4 style="margin: 0 0 12px 0; color: var(--accent);">ð Subject Line Patterns</h4>
        <div style="background: var(--bg); padding: 12px; border-radius: 8px; font-size: 13px;">
          <div style="margin-bottom: 8px;"><strong>LinkedIn:</strong> "Role at Company in Location"</div>
          <div style="margin-bottom: 8px;"><strong>Indeed:</strong> "Company for Role" or "Role @ Company"</div>
          <div style="margin-bottom: 8px;"><strong>Glassdoor:</strong> "Company1, Company2 in Location"</div>
          <div style="margin-bottom: 8px;"><strong>Generic:</strong> "Company is hiring" or "Various Roles"</div>
        </div>
      </div>
      
      <!-- Body Extraction -->
      <div>
        <h4 style="margin: 0 0 12px 0; color: var(--accent);">ð Body Extraction</h4>
        <div style="background: var(--bg); padding: 12px; border-radius: 8px; font-size: 13px;">
          <div style="margin-bottom: 8px;"><strong>Company:</strong> "at Company" or "@ Company" patterns</div>
          <div style="margin-bottom: 8px;"><strong>Role:</strong> Job title keywords (Manager, Engineer, etc.)</div>
          <div style="margin-bottom: 8px;"><strong>Location:</strong> "City, State" format detection</div>
          <div style="margin-bottom: 8px;"><strong>Salary:</strong> "$X-Y" or "$X to $Y" patterns</div>
        </div>
      </div>
    </div>
    
    <!-- Advanced Features -->
    <div>
      <h4 style="margin: 0 0 12px 0; color: var(--accent);">â¡ Advanced Features</h4>
      <div style="background: var(--bg); padding: 12px; border-radius: 8px; font-size: 13px;">
        <div style="margin-bottom: 8px;"><strong>City Resolution:</strong> "Angeles" â "Los Angeles" (partial city name expansion)</div>
        <div style="margin-bottom: 8px;"><strong>Role Validation:</strong> Filters out non-job words like "Apply Now", "Click Here"</div>
        <div style="margin-bottom: 8px;"><strong>Fallback Extraction:</strong> Extracts roles from body when subject parsing fails</div>
        <div style="margin-bottom: 8px;"><strong>Source Detection:</strong> Identifies job board from email domain</div>
      </div>
    </div>
  </div>
  
  <!-- Source-Specific Rules -->
  <div style="background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 20px; margin-bottom: 24px;">
    <h3 style="margin: 0 0 16px 0;">ð¯ Source-Specific Rules</h3>
    <div id="sourceRules" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px;">
      <!-- Rules will be populated by JavaScript -->
    </div>
  </div>
  
  <!-- Training Interface -->
  <div id="mappingTrainingContainer">
    <!-- Training data will be populated here -->
  </div>
</div>

<!-- Settings Screen -->
<div id="settings" class="screen">
  <div class="header">
    <h1>Settings</h1>
    <div class="subtitle">Customize your goals and preferences</div>
  </div>
  
  <!-- Version Info -->
  <div style="background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 8px; padding: 12px 16px; margin-bottom: 24px; display: flex; align-items: center; justify-content: space-between;">
    <div style="display: flex; align-items: center; gap: 12px;">
      <span style="font-family: 'JetBrains Mono', monospace; font-size: 13px; color: var(--accent); font-weight: 600;">v<span id="app-version"></span></span>
      <span style="font-size: 12px; color: var(--muted);">â¢</span>
      <span style="font-size: 12px; color: var(--muted);">Build: <span id="app-build-date"></span></span>
      <span style="font-size: 12px; color: var(--muted);">â¢</span>
      <span style="font-size: 12px; color: var(--muted);">Deploy: <span id="app-deploy-time"></span></span>
    </div>
    <div style="font-size: 11px; color: var(--muted);">
      <span id="version-status">Loading...</span>
    </div>
  </div>
  
  <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 24px; margin-bottom: 32px;">
    <div class="glass-card" style="padding: 24px;">
      <h3 style="margin-bottom: 16px; color: var(--accent);">Weekly Targets</h3>
      <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 16px;">
        <div class="form-group" style="margin-bottom: 0;">
          <label style="font-size: 12px; margin-bottom: 4px;">Applications</label>
          <input type="number" id="targetApps" min="1" value="15" style="height: 40px; font-size: 14px;">
        </div>
        <div class="form-group" style="margin-bottom: 0;">
          <label style="font-size: 12px; margin-bottom: 4px;">Networking</label>
          <input type="number" id="targetNet" min="1" value="10" style="height: 40px; font-size: 14px;">
        </div>
        <div class="form-group" style="margin-bottom: 0;">
          <label style="font-size: 12px; margin-bottom: 4px;">Events</label>
          <input type="number" id="targetEvents" min="1" value="1" style="height: 40px; font-size: 14px;">
        </div>
      </div>
      <button onclick="saveSettings()" style="width: 100%;">Save Targets</button>
    </div>
    
    <div class="glass-card" style="padding: 24px;">
      <h3 style="margin-bottom: 20px; color: var(--accent);">Appearance</h3>
      <div class="form-group">
        <label>Color Theme</label>
        <select id="colorThemeSelect" onchange="changeColorTheme()" style="height: 40px; font-size: 14px;">
          <option value="A1">A1 - Clean White</option>
          <option value="C3">C3 - Warm Cream</option>
          <option value="E5">E5 - Soft Gray</option>
        </select>
      </div>
    <div style="background: var(--glass-bg); backdrop-filter: var(--backdrop-blur); border: 1px solid var(--glass-border); border-radius: 12px; padding: 16px; margin-bottom: 16px;">
      <label style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; margin: 0;">
        <span style="font-size: 16px; color: var(--text);">Dark Mode</span>
        <div style="position: relative; display: inline-block; width: 50px; height: 24px;">
          <input type="checkbox" id="themeToggle" onchange="toggleTheme()" style="opacity: 0; width: 0; height: 0;">
          <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--muted); transition: .4s; border-radius: 24px;">
            <span style="position: absolute; content: ''; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%;"></span>
          </span>
        </div>
      </label>
    </div>
      <p style="color: var(--muted); font-size: 14px; margin: 0;">Choose your color theme and toggle dark/light mode</p>
    </div>
  </div>
  
  <div class="glass-card" style="padding: 24px; margin-top: 20px;">
    <h3 style="margin-bottom: 20px; color: var(--accent);">Styling Center</h3>
    <div id="stylingRows">
      <!-- Dynamic styling rows will be added here -->
    </div>
    <div style="display: flex; gap: 12px; margin-top: 16px;">
      <button onclick="addStylingRow()" class="modern-button secondary" style="flex: 1;">+ Add Color Customization</button>
      <button onclick="saveAsTheme()" class="modern-button primary" style="flex: 1;">Save as Theme</button>
    </div>
  </div>
  
  <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--line);">
    <div style="background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 12px; margin-bottom: 12px;">
      <label style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; margin: 0;">
        <div>
          <span style="font-size: 14px; color: var(--text); font-weight: 600;">Enable Guardrails</span>
          <span style="font-size: 11px; color: var(--muted); display: block; margin-top: 2px;">Prevent optimization paralysis</span>
        </div>
        <input type="checkbox" id="guardrailsEnabled" onchange="toggleGuardrails()" style="width: auto; height: 24px; cursor: pointer;">
      </label>
    </div>
    
    <div id="guardrailsSettings" style="display: none;">
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
        <div class="form-group" style="margin-bottom: 0;">
          <label style="font-size: 11px; margin-bottom: 4px;">Max tailoring time (min)</label>
          <input type="number" id="maxTailorTime" min="15" max="120" value="40" style="height: 32px;">
        </div>
        
        <div class="form-group" style="margin-bottom: 0;">
          <label style="font-size: 11px; margin-bottom: 4px;">Max daily optimization (min)</label>
          <input type="number" id="maxOptimizationTime" min="30" max="180" value="60" style="height: 32px;">
        </div>
        
        <div class="form-group" style="margin-bottom: 0;">
          <label style="font-size: 11px; margin-bottom: 4px;">Warning threshold (min)</label>
          <input type="number" id="warningThreshold" min="10" max="60" value="30" style="height: 32px;">
        </div>
      </div>
    </div>
  </div>
  
  <div style="margin-top: 40px; padding-top: 40px; border-top: 1px solid var(--line);">
    <h3 style="margin-bottom: 16px;">Account</h3>
    <div style="background: var(--panel); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
      <div style="font-size: 12px; color: var(--muted); margin-bottom: 4px;">User ID</div>
      <div style="font-size: 14px; font-family: monospace; color: var(--text);" id="userId">Loading...</div>
    </div>
    <p style="font-size: 14px; color: var(--muted); margin-bottom: 16px;">
      Your data syncs automatically across all devices using this ID.
    </p>
    <div style="background: var(--panel); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
      <div style="font-size: 12px; color: var(--muted); margin-bottom: 4px;">Sync Status:</div>
      <div id="debugSyncStatus" style="font-size: 14px; font-family: monospace;">Loading...</div>
    </div>
    
    <div style="background: var(--panel); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
      <div style="font-size: 12px; color: var(--muted); margin-bottom: 8px;">Sync Devices:</div>
      <div style="display: flex; gap: 8px; flex-wrap: wrap;">
        <input type="text" id="syncUserIdInput" placeholder="Enter User ID from other device" style="flex: 1; min-width: 200px; height: 36px; padding: 0 8px; border: 1px solid var(--line); border-radius: 6px; background: var(--bg); color: var(--text);">
        <button onclick="syncToUserId()" class="modern-button secondary" style="height: 36px; padding: 0 12px; font-size: 13px;">Sync</button>
      </div>
      <div style="font-size: 11px; color: var(--muted); margin-top: 6px;">
        Copy User ID from other device and paste above to sync data
      </div>
      <button onclick="listAllUsers()" class="modern-button ghost" style="height: 32px; padding: 0 8px; font-size: 12px; margin-top: 8px;">Show All User IDs</button>
      <button onclick="cleanupAndMigrateUsers()" class="modern-button primary" style="height: 32px; padding: 0 8px; font-size: 12px; margin-top: 8px;">Clean Up & Merge Users</button>
    </div>
    
    <div style="background: var(--panel); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
      <div style="font-size: 12px; color: var(--muted); margin-bottom: 8px;">Emergency Access:</div>
      <button onclick="forceOfflineMode()" class="modern-button secondary" style="height: 36px; padding: 0 12px; font-size: 13px;">Force Offline Mode</button>
      <div style="font-size: 11px; color: var(--muted); margin-top: 6px;">
        Use if app is stuck loading - will load from local storage
      </div>
    </div>
  </div>
  
  <div style="margin-top: 40px; padding-top: 40px; border-top: 1px solid var(--line);">
    <h3 style="margin-bottom: 16px;">ð Google Sheets Integration</h3>
    <p style="font-size: 14px; color: var(--muted); margin-bottom: 16px;">
      Automatically sync your job queue to a Google Sheet for easy tracking<br>
      <small style="color: var(--warn);">â ï¸ Requires Google Authentication below</small>
    </p>
    
    <div style="background: var(--panel); padding: 16px; border-radius: 12px; margin-bottom: 16px;">
      <div id="sheetsStatus" style="margin-bottom: 12px;">
        <div style="font-size: 12px; color: var(--muted); margin-bottom: 4px;">Status:</div>
        <div id="sheetsStatusText" style="font-size: 14px; color: var(--muted);">Not configured</div>
      </div>
      
      <div style="display: flex; gap: 8px; flex-wrap: wrap;">
        <button onclick="initializeSpreadsheet()" class="modern-button primary" title="Create a new Google Sheet for your job applications" style="height: 36px; padding: 0 16px; font-size: 13px;">Create Spreadsheet</button>
        <button onclick="syncToGoogleSheets()" class="modern-button secondary" title="Sync all jobs and contacts to your Google Sheet" style="height: 36px; padding: 0 16px; font-size: 13px;">Sync All</button>
        <button onclick="syncContactsToGoogleSheets()" class="modern-button secondary" title="Sync only contacts to Google Sheets" style="height: 36px; padding: 0 16px; font-size: 13px;">Sync Contacts</button>
        <button onclick="openSpreadsheet()" id="openSheetBtn" class="modern-button secondary" title="Open your spreadsheet in a new tab" style="height: 36px; padding: 0 16px; font-size: 13px; display: none;">Open Sheet</button>
        <button onclick="resetSpreadsheet()" class="modern-button secondary" title="Reset and create a new sheet" style="height: 32px; padding: 0 12px; font-size: 12px; color: var(--warn);">Reset Sheet Connection</button>
      </div>
      
      <div id="sheetsLastSync" style="margin-top: 12px; font-size: 12px; color: var(--muted);"></div>
    </div>
  </div>
  
  <!-- Google OAuth Configuration (for Sheets only) -->
  <div style="margin-top: 40px; padding-top: 40px; border-top: 1px solid var(--line);">
    <h3 style="margin-bottom: 16px;">ð Google Authentication</h3>
    <p style="font-size: 14px; color: var(--muted); margin-bottom: 16px;">
      Required for Google Sheets sync functionality. Connect once to enable all Google features.
    </p>
    
    <div style="background: var(--panel); padding: 16px; border-radius: 12px; margin-bottom: 16px;">
      <div style="margin-bottom: 12px;">
        <label for="google-client-id" style="display: block; font-size: 12px; color: var(--muted); margin-bottom: 4px;">Google Client ID:</label>
        <input type="text" id="google-client-id" placeholder="Enter your Google Client ID" style="width: 100%; padding: 8px; border: 1px solid var(--line); border-radius: 6px; background: var(--bg); color: var(--text);">
      </div>
      
      <div style="display: flex; gap: 8px; flex-wrap: wrap;">
        <button onclick="configureGoogleAuth()" class="modern-button primary" style="height: 36px; padding: 0 16px; font-size: 13px;">Connect Google</button>
        <button onclick="disconnectGoogle()" class="modern-button secondary" style="height: 36px; padding: 0 16px; font-size: 13px; color: var(--warn);">Disconnect</button>
      </div>
      
      <div id="google-auth-status" style="margin-top: 12px; font-size: 12px; color: var(--muted);"></div>
    </div>
  </div>
  
  <!-- CSV Import Modal -->
  <div id="csvImportModal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 800px;">
      <div class="modal-header">
        <h3>ð Import Jobs from CSV</h3>
        <button onclick="closeCSVImport()" class="close-btn">&times;</button>
      </div>
      
      <div class="modal-body">
        <div style="margin-bottom: 20px;">
          <h4>How to use:</h4>
          <ol style="margin: 10px 0; padding-left: 20px; color: var(--muted);">
            <li>Copy job listings from emails, job boards, etc.</li>
            <li>Paste into your Claude chat with the prompt below</li>
            <li>Copy the CSV output from Claude</li>
            <li>Paste it here and click "Import Jobs"</li>
          </ol>
        </div>
        
        <div style="background: var(--panel); padding: 16px; border-radius: 8px; margin-bottom: 20px;">
          <h4>Claude Prompt:</h4>
          <textarea id="claudePrompt" readonly style="width: 100%; height: 120px; padding: 12px; border: 1px solid var(--line); border-radius: 6px; background: var(--bg); color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 12px; resize: vertical;">Extract job data from the following text and output as CSV with these exact columns:
company,role,location,salary,url,benefits,source,notes

Rules:
- company: Company name only (no "at" or extra text)
- role: Job title/position
- location: City, State format (or "Remote" if remote)
- salary: Salary range if mentioned (e.g., "$80k-120k" or "Not specified")
- url: Job posting URL if available (or "Not provided")
- benefits: Key benefits/compensation details (e.g., "PTO, 401k, stock options")
- source: Where you found it (e.g., "LinkedIn", "Indeed", "Email")
- notes: Any additional relevant info

Output only the CSV data, no explanations. Include header row.

Text to parse:</textarea>
          <button onclick="copyPrompt()" class="modern-button secondary" style="margin-top: 8px;">Copy Prompt</button>
        </div>
        
        <div>
          <label for="csvData" style="display: block; margin-bottom: 8px; font-weight: 500;">Paste CSV data from Claude:</label>
          <textarea id="csvData" placeholder="Paste the CSV output from Claude here..." style="width: 100%; height: 200px; padding: 12px; border: 1px solid var(--line); border-radius: 6px; background: var(--bg); color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 12px; resize: vertical;"></textarea>
        </div>
      </div>
      
      <div class="modal-footer">
        <button onclick="closeCSVImport()" class="modern-button secondary">Cancel</button>
        <button onclick="importCSVData()" class="modern-button primary">Import Jobs</button>
      </div>
    </div>
  </div>

  <!-- ARCHIVED: Gmail Integration - Removed due to unreliable parsing -->
  <!-- See archived/EMAIL_PARSING_CODE_ARCHIVE.md for details -->
  <!-- Future: Consider Safari extension for direct DOM access -->
  
  <div style="margin-top: 40px; padding-top: 40px; border-top: 1px solid var(--line); margin-bottom: 100px;">
    <h3 style="margin-bottom: 16px;">Data Management</h3>
    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
      <button onclick="exportData()" class="secondary">Export Data</button>
      <button onclick="importData()" class="secondary">Import Data</button>
      <button onclick="confirmReset()" class="modern-button secondary" style="height: 32px; padding: 0 12px; font-size: 12px; color: var(--bad);">Reset All Data</button>
    </div>
  </div>
</div>

<!-- Focus Mode -->
<div id="focusMode" style="display: none;">
  <button class="exit-focus" onclick="exitFocus()">â Back to Queue</button>
  
  <div class="focus-content">
    <div style="display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 20px;">
      <div class="focus-timer" id="focusTimer">00:00</div>
      <button onclick="pauseTask()" class="secondary" style="height: 48px; padding: 0 20px;">â¸ï¸ Pause</button>
      <button id="focusSwitchPairBtn" onclick="switchFocusPair()" class="ghost" style="display:none; height: 48px; padding: 0 20px;">âï¸ Switch</button>
    </div>
    
    <div id="optimizationProgress" style="display: none; margin-bottom: 20px;">
      <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px;">
        <span>Today's optimization time</span>
        <span id="optProgressText">0/60 min</span>
      </div>
      <progress id="optProgressBar" value="0" max="60" style="width: 100%;"></progress>
    </div>
    
    <div class="focus-title" id="focusTitle"></div>
    <div class="focus-description" id="focusDescription"></div>
    
    <div id="focusMeta" style="margin: 20px 0; display: grid; gap: 16px; text-align: left;">
      <div id="focusUrlRow" style="display:none;">
        <div style="display:flex; gap:8px; align-items:center;">
          <input type="url" id="focusAppUrl" placeholder="https://..." style="flex:1;">
          <button class="secondary" onclick="openFocusUrl()" style="min-width:60px;">Open</button>
          <button class="secondary" onclick="saveFocusUrl()" style="min-width:60px;">Save</button>
        </div>
      </div>
      <div>
        <textarea id="focusNotes" rows="4" placeholder="Notes for this task..." oninput="debouncedSaveFocusNotes()" style="width: 100%; resize: vertical; min-height: 80px;"></textarea>
      </div>
    </div>
  
    <div class="completion-criteria" style="padding: 16px; margin: 16px 0;">
      <h4 style="margin-bottom: 8px;">Completion Criteria:</h4>
      <p id="focusCriteria" style="margin: 0;"></p>
    </div>
    
    <div class="btn-group">
      <button onclick="switchTask()" class="secondary">ð Switch Task</button>
      <button onclick="completeTask()">â Done</button>
    </div>
  </div>
</div>

<!-- Next Task Modal -->
<div id="nextTaskModal" class="modal-overlay">
  <div class="modal">
    <h2>Nice work! What's next?</h2>
    <div class="next-task-options">
      <button onclick="nextTaskRecommended()">
        <span>â­</span>
        <span id="recommendedTaskText">Recommended task</span>
      </button>
      <button onclick="nextTaskRandom()" class="secondary">
        <span>ð²</span>
        <span>Choose for me</span>
      </button>
      <button onclick="nextTaskManual()" class="ghost">
        <span>ð</span>
        <span>Let me pick</span>
      </button>
    </div>
  </div>
</div>

<!-- Breathing Break -->
<div id="breathingBreak" class="celebration-overlay">
  <div style="text-align: center;">
    <div class="breathing-circle"></div>
    <div class="breathing-text" id="breathingText">Breathe in...</div>
    <button onclick="skipBreathing()" class="ghost" style="margin-top: 60px;">Skip â</button>
  </div>
</div>

<!-- Celebration -->
<div id="celebrationOverlay" class="celebration-overlay">
  <div style="text-align: center; max-width: 400px;">
    <div style="font-size: 80px; margin-bottom: 20px;" id="celebrationEmoji">ð</div>
    <h2 style="margin-bottom: 12px;" id="celebrationTitle">Great work!</h2>
    <p style="color: var(--muted); margin-bottom: 30px;" id="celebrationMessage"></p>
    <button onclick="closeCelebration()">Continue â</button>
  </div>
</div>

<!-- Add Task Modal -->
<div id="addTaskModal" class="modal-overlay">
  <div class="modal">
    <h2>Add Task for Today</h2>
    <div class="form-group">
      <label>Task Type</label>
      <select id="newTaskType" onchange="updateTaskModalForType()">
        <option value="application">Job Application</option>
        <option value="networking">Networking Outreach</option>
        <option value="event">Event/Activity</option>
      </select>
    </div>
    
    <div id="taskSelectSection">
      <div class="form-group">
        <label>Select existing item</label>
        <select id="newTaskRef">
          <option value="">-- Select --</option>
        </select>
      </div>
      <div style="text-align: center; color: var(--muted); margin: 12px 0;">or</div>
    </div>
    
    <div id="quickAddSection" style="display: none;"></div>
    
    <button onclick="toggleQuickAdd()" class="secondary" style="width: 100%; margin-bottom: 12px;" id="quickAddToggle">+ Quick Add New</button>
    
    <div class="btn-group">
      <button onclick="addTaskToToday()">Add to Today</button>
      <button onclick="closeModal('addTaskModal')" class="ghost">Cancel</button>
    </div>
  </div>
</div>

<!-- Add Application Modal -->
<div id="addAppModal" class="modal-overlay">
  <div class="modal" style="max-width: 600px;">
    <h2>Add New Application</h2>
    
    <!-- CSV Import Section -->
    <div style="background: var(--panel); padding: 16px; border-radius: 8px; margin-bottom: 20px; border: 1px solid var(--line);">
      <h3 style="margin: 0 0 12px 0; font-size: 16px; color: var(--text);">ð Import from CSV (Claude Chat)</h3>
      <p style="margin: 0 0 12px 0; font-size: 12px; color: var(--muted);">Paste CSV data from your Claude chat to import multiple jobs at once</p>
      <textarea id="csvImportText" placeholder="Paste CSV data here (company,role,location,salary,url,benefits,source,notes)..." style="width: 100%; height: 80px; padding: 8px; border: 1px solid var(--line); border-radius: 4px; background: var(--bg); color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 11px; resize: vertical;"></textarea>
      <div style="display: flex; gap: 8px; margin-top: 8px;">
        <button onclick="importFromCSVText()" class="modern-button primary" style="height: 32px; padding: 0 12px; font-size: 12px;">Import CSV</button>
        <button onclick="clearCSVText()" class="modern-button secondary" style="height: 32px; padding: 0 12px; font-size: 12px;">Clear</button>
      </div>
    </div>
    
    <div style="text-align: center; margin: 16px 0; color: var(--muted); font-size: 12px;">OR</div>
    
    <!-- Manual Entry Section -->
    <div class="form-group">
      <label>Company Name</label>
      <input type="text" id="newAppCompany" placeholder="Acme Corp">
    </div>
    <div class="form-group">
      <label>Job Title</label>
      <input type="text" id="newAppRole" placeholder="Product Manager">
    </div>
    <div class="form-group">
      <label>Job URL</label>
      <input type="url" id="newAppUrl" placeholder="https://...">
    </div>
    <div class="form-group">
      <label>Deadline (optional)</label>
      <input type="date" id="newAppDeadline">
    </div>
    <div class="form-group">
      <label>Notes</label>
      <textarea id="newAppNotes" rows="3"></textarea>
    </div>
    <div class="btn-group">
      <button onclick="addApplication()">Add Application</button>
      <button onclick="closeModal('addAppModal')" class="ghost">Cancel</button>
    </div>
  </div>
</div>

<!-- Add Contact Modal -->
<div id="addContactModal" class="modal-overlay">
  <div class="modal">
    <h2>Add Networking Contact</h2>
    <div class="form-group">
      <label>Name</label>
      <input type="text" id="newContactName" placeholder="Walter Smith">
    </div>
    <div class="form-group">
      <label>Relationship</label>
      <select id="newContactRel">
        <option value="Friend/Ally">Friend/Ally</option>
        <option value="Professional Contact">Professional Contact</option>
        <option value="Recruiter">Recruiter</option>
        <option value="Mentor">Mentor</option>
        <option value="Cold Contact">Cold Contact</option>
      </select>
    </div>
    <div class="form-group">
      <label>Company (optional)</label>
      <input type="text" id="newContactCompany">
    </div>
    <div class="form-group">
      <label>LinkedIn Profile (optional)</label>
      <input type="url" id="newContactLinkedIn" placeholder="https://linkedin.com/in/username">
    </div>
    <div class="form-group">
      <label>Notes</label>
      <textarea id="newContactNotes" rows="3" placeholder="What to discuss, how they can help..."></textarea>
    </div>
    <div class="btn-group">
      <button onclick="addContact()">Add Contact</button>
      <button onclick="closeModal('addContactModal')" class="ghost">Cancel</button>
    </div>
  </div>
</div>

<!-- Add Event Modal -->
<div id="addEventModal" class="modal-overlay">
  <div class="modal">
    <h2>Add Event</h2>
    <div class="form-group">
      <label>Event Name</label>
      <input type="text" id="newEventName" placeholder="Career Fair">
    </div>
    <div class="form-group">
      <label>Date</label>
      <input type="date" id="newEventDate">
    </div>
    <div class="form-group">
      <label>Start Time</label>
      <input type="time" id="newEventStartTime">
    </div>
    <div class="form-group">
      <label>End Time</label>
      <input type="time" id="newEventEndTime">
    </div>
    <div class="form-group">
      <label>Type</label>
      <select id="newEventType" onchange="handleEventTypeChange()">
        <option value="fair">Career Fair</option>
        <option value="workshop">Workshop</option>
        <option value="info_session">Info Session</option>
        <option value="networking">Networking Event</option>
        <option value="interview">Interview</option>
        <option value="volunteer">Volunteer Shift</option>
        <option value="mindfulness">Mindfulness Event</option>
        <option value="balloon_gig">Balloon Gig</option>
        <option value="dog_gig">Dog Gig</option>
      </select>
    </div>
    <div id="favoritesGroup" class="form-group" style="display: none;">
      <label>Favorites</label>
      <select id="newEventFavorites" onchange="handleFavoritesChange()">
        <option value="">Select a favorite location</option>
        <option value="project_angel_food">Project Angel Food</option>
        <option value="compost_la">Compost LA</option>
      </select>
    </div>
    <div class="form-group">
      <label>Link</label>
      <input type="url" id="newEventLink" placeholder="https://example.com">
    </div>
    <div class="form-group">
      <label>Address</label>
      <input type="text" id="newEventAddress" placeholder="123 Main St, City, State">
    </div>
    <div class="form-group">
      <label>Notes</label>
      <textarea id="newEventNotes" rows="3"></textarea>
    </div>
    <div class="btn-group">
      <button onclick="addEvent()">Add Event</button>
      <button onclick="closeModal('addEventModal')" class="ghost">Cancel</button>
    </div>
  </div>
</div>

<!-- Guardrail Warning Modal -->
<div id="guardrailWarning" class="modal-overlay">
  <div class="modal" style="text-align: center;">
    <div style="font-size: 48px; margin-bottom: 16px;">â ï¸</div>
    <h2 id="guardrailTitle" style="margin-bottom: 16px;"></h2>
    <p id="guardrailMessage" style="color: var(--muted); margin-bottom: 24px;"></p>
    <div class="btn-group">
      <button onclick="closeModal('guardrailWarning')">Got it, moving on</button>
      <button onclick="continueAnyway()" class="ghost">Continue anyway</button>
    </div>
  </div>
</div>

<!-- Bottom Navigation -->
<div class="nav-bottom">
  <button class="nav-btn active" onclick="showScreen('today')">
    ð¯
    <span>Today</span>
  </button>
  <button class="nav-btn" onclick="showScreen('plan')">
    ð
    <span>Plan</span>
  </button>
  <button class="nav-btn" onclick="showScreen('progress')">
    ð
    <span>Progress</span>
  </button>
  <button class="nav-btn" onclick="showScreen('settings')">
    âï¸
    <span>Settings</span>
  </button>
</div>

<input type="file" id="importFileInput" accept=".json" style="display: none;">

<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

<script>
// Emergency functions available immediately - GLOBAL SCOPE
window.emergencyOffline = function() {
  console.log('Emergency offline mode triggered');
  // Force update sync status
  const syncText = document.getElementById('syncText');
  if (syncText) syncText.textContent = 'Offline';
  
  // Load from localStorage
  try {
    const saved = localStorage.getItem('career_chute_backup');
    if (saved) {
      window.state = JSON.parse(saved);
      if (window.renderTodayTasks) window.renderTodayTasks();
      if (window.renderSettings) window.renderSettings();
      alert('Emergency offline mode activated!');
    } else {
      alert('No local data found. Starting fresh.');
    }
  } catch (error) {
    console.error('Emergency load error:', error);
    alert('Emergency mode failed. Please refresh the page.');
  }
};

// Auto-trigger emergency mode after 3 seconds
setTimeout(() => {
  const syncText = document.getElementById('syncText');
  if (syncText && syncText.textContent === 'Loading...') {
    console.warn('Auto-emergency mode triggered');
    window.emergencyOffline();
  }
}, 3000);

// Simple manual override - just change the text
window.forceOffline = function() {
  const syncText = document.getElementById('syncText');
  if (syncText) {
    syncText.textContent = 'Offline';
    console.log('Forced offline mode - sync text updated');
  }
};

// Firebase initialization
const firebaseConfig = {
  apiKey: "AIzaSyBRIlCVLNKtTqazJJeueLhYMZlBGlqISik",
  authDomain: "career-chute-b0be0.firebaseapp.com",
  projectId: "career-chute-b0be0",
  storageBucket: "career-chute-b0be0.firebasestorage.app",
  messagingSenderId: "42803696035",
  appId: "1:42803696035:web:da8b7d61c227fdc44c0a16"
};

// Debug Firebase configuration
console.log('Firebase Config:', firebaseConfig);
console.log('Current URL:', window.location.href);
console.log('Is HTTPS:', window.location.protocol === 'https:');

let db = null;
let firebaseAvailable = false;

// Initialize Firebase with timeout
function initializeFirebase() {
  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      console.warn('Firebase initialization timeout - falling back to offline mode');
      firebaseAvailable = false;
      resolve(false);
    }, 5000); // 5 second timeout

    try {
      if (typeof firebase === 'undefined') {
        console.warn('Firebase SDK not loaded - falling back to offline mode');
        clearTimeout(timeout);
        firebaseAvailable = false;
        resolve(false);
        return;
      }

      firebase.initializeApp(firebaseConfig);
      db = firebase.firestore();
      
      // Test connection
      db.enableNetwork().then(() => {
        clearTimeout(timeout);
        firebaseAvailable = true;
        console.log('Firebase initialized and connected successfully');
        console.log('Firebase URL:', db.app.options.databaseURL);
        resolve(true);
      }).catch(error => {
        console.warn('Firebase connection failed:', error);
        console.warn('Error details:', error.message, error.code);
        clearTimeout(timeout);
        firebaseAvailable = false;
        resolve(false);
      });
    } catch (error) {
      console.warn('Firebase initialization failed:', error);
      clearTimeout(timeout);
      firebaseAvailable = false;
      resolve(false);
    }
  });
}

// Single shared User ID for all devices
const SHARED_USER_ID = 'career-chute-shared-user';
let userId = SHARED_USER_ID;

// Always use the shared User ID
localStorage.setItem('career_chute_user_id', userId);

// App Version
const APP_VERSION = '3.5.8'; // Visual color palette and bug fixes
const APP_BUILD_DATE = '2025-01-08';
const APP_DEPLOY_TIME = '2025-01-08 22:00:00';

// State
let state = {
  version: APP_VERSION,
  weekStart: null,
  targets: { apps: 15, networking: 10, events: 1 },
  applications: [],
  contacts: [],
  events: [],
  dailyTasks: {},
  completedThisWeek: { apps: 0, networking: 0, events: 0 },
  currentTask: null,
  focusStartTime: null,
  guardrails: {
    enabled: true,
    maxTailorTime: 40,
    maxOptimizationTime: 60,
    warningThreshold: 30
  },
  dailyTimeTracking: {},
  guardrailOverride: false,
  taskProgress: {},
  streaks: { current: 0, longest: 0, lastActiveDate: null },
  milestones: [],
  timeBlocking: null,
  theme: 'dark',
  gmail: {
    enabled: false,
    connected: false,
    userEmail: null,
    clientId: '',
    accessToken: null,
    tokenExpiry: null,
  },
  google: {
    connected: false,
    clientId: '906932405437-9r5i8d63ssle5sqas1fob1k7u4k57bfq.apps.googleusercontent.com',
    accessToken: null,
    lastConnected: null,
  },
  sheets: {
    enabled: false,
    spreadsheetId: null,
    spreadsheetUrl: null,
    lastSync: null,
    autoSync: true,
    lastScanTime: null,
    lastScanResults: { added: 0, duplicates: 0, emailsProcessed: 0 }
  },
  roleGrades: {
    // Role titles mapped to grades: 'A', 'B', 'C', or 'ungraded' (gray)
    // Example: 'Solutions Engineer': 'A', 'Account Executive': 'B'
  },
  blockedEmployers: {
    // List of company names that should be blocked from future imports
    // Example: 'Spam Company': true, 'Bad Employer': true
    // This persists even when applications are cleared
  },
  cityGrades: {
    // Cities mapped to grades: 'A', 'B', 'C', or 'ungraded' (gray)
    // Example: 'Los Angeles': 'A', 'Santa Monica': 'A', 'Beverly Hills': 'B'
  },
  blockedCities: {
    // Cities that should be completely blocked from future imports
    // Example: 'New York': true, 'Chicago': true
  },
  emailParsers: {
    // Configurable field mapping rules for different email sources
    // Similar to Zapier/Make.com field mapping
    linkedin: {
      patterns: {
        subject: [
          /(.+?)\s+at\s+(.+?)\s+in\s+(.+?)(?:\s+and\s+\d+\s+more|$)/i,
          /(.+?)\s+@\s+(.+)/i
        ],
        body: {
          company: [/company[:\s]+([^<\n]+)/i, /at\s+([^<\n]+)/i],
          location: [/location[:\s]+([^<\n]+)/i, /([A-Z][a-z]+,\s*[A-Z]{2})/],
          salary: [/\$[\d,]+\s*-\s*\$[\d,]+/],
          url: [/https:\/\/www\.linkedin\.com[^\s"<]+/]
        }
      }
    },
    indeed: {
      patterns: {
        subject: [
          /(.+?)\s+at\s+(.+?)\s+in\s+(.+?)(?:\s+and\s+\d+\s+more|$)/i,
          /(.+?)\s+@\s+(.+)/i
        ],
        body: {
          company: [/company[:\s]+([^<\n]+)/i],
          location: [/location[:\s]+([^<\n]+)/i, /([A-Z][a-z]+,\s*[A-Z]{2})/],
          salary: [/\$[\d,]+\s*-\s*\$[\d,]+/],
          url: [/https:\/\/[^\s"<]+/]
        }
      }
    },
    glassdoor: {
      patterns: {
        subject: [
          // Pattern 1: "Company1, Company2 in Location. Apply Now."
          /(.+?)\s+in\s+(.+?)\.\s*Apply\s+Now/i,
          // Pattern 2: "Company for Role. Apply Now."
          /(.+?)\s+for\s+(.+?)\.\s*Apply\s+Now/i,
          // Pattern 3: "Company is hiring"
          /(.+?)\s+is\s+hiring/i
        ],
        body: {
          company: [/company[:\s]+([^<\n]+)/i],
          location: [/location[:\s]+([^<\n]+)/i, /([A-Z][a-z]+,\s*[A-Z]{2})/],
          salary: [/\$[\d,]+\s*-\s*\$[\d,]+/],
          url: [/https:\/\/www\.glassdoor\.com[^\s"<]+/]
        }
      }
    },
    ziprecruiter: {
      patterns: {
        subject: [
          // Pattern 1: "Jared, I think this job might be right for you!"
          /Jared,\s+I\s+think\s+this\s+job\s+might\s+be\s+right\s+for\s+you!/i,
          // Pattern 2: "ð¼ Jared, Company. has an open position"
          /ð¼\s+Jared,\s+(.+?)\.\s+has\s+an\s+open\s+position/i,
          // Pattern 3: "Did you see this job?"
          /Did\s+you\s+see\s+this\s+job\?/i
        ],
        body: {
          company: [/company[:\s]+([^<\n]+)/i, /at\s+([^<\n]+)/i],
          location: [/location[:\s]+([^<\n]+)/i, /([A-Z][a-z]+,\s*[A-Z]{2})/],
          salary: [/\$[\d,]+\s*-\s*\$[\d,]+/],
          url: [/https:\/\/[^\s"<]+/]
        }
      }
    }
  }
};

let isSyncing = false;
let unsubscribe = null;

// Timer state
let chunkTimerInterval = null;
let chunkStartTime = null;
let chunkPausedTime = 0;

// Date utilities
function getTodayISO() {
  // Use Los Angeles timezone to match the display
  const now = new Date();
  const laTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
  return laTime.toISOString().split('T')[0];
}

function getMonday() {
  const now = new Date();
  const day = now.getDay();
  const diff = (day === 0 ? -6 : 1 - day);
  const monday = new Date(now);
  monday.setDate(now.getDate() + diff);
  return monday.toISOString().split('T')[0];
}

function addDays(dateStr, days) {
  const date = new Date(dateStr + 'T00:00:00');
  date.setDate(date.getDate() + days);
  return date.toISOString().split('T')[0];
}

function isCurrentWeek(weekStart) {
  return weekStart === getMonday();
}

function getDaysDifference(date1, date2) {
  const d1 = new Date(date1);
  const d2 = new Date(date2);
  return Math.floor((d1 - d2) / (1000 * 60 * 60 * 24));
}

function formatDate(dateStr) {
  const date = new Date(dateStr + 'T00:00:00');
  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
}

function formatDateTime(isoString, forSpreadsheet = false) {
  if (!isoString) return '';
  const date = new Date(isoString);
  
  // For spreadsheets, always use absolute date/time
  if (forSpreadsheet) {
    return date.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: 'numeric'
    }) + ' ' + date.toLocaleTimeString('en-US', { 
      hour: 'numeric', 
      minute: '2-digit',
      hour12: true 
    });
  }
  
  // For UI, use relative time for recent dates
  const now = new Date();
  const diffMs = now - date;
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);
  
  if (diffMins < 1) return 'just now';
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  if (diffDays < 7) return `${diffDays}d ago`;
  
  // Absolute date for older dates
  return date.toLocaleDateString('en-US', { 
    month: 'short', 
    day: 'numeric',
    year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
  }) + ' ' + date.toLocaleTimeString('en-US', { 
    hour: 'numeric', 
    minute: '2-digit',
    hour12: true 
  });
}

function isValidUrl(url) {
  if (!url || url.trim() === '') return { isValid: true, message: '' };
  
  try {
    // Basic URL validation
    const urlObj = new URL(url);
    
    // Check for valid protocols
    if (!['http:', 'https:'].includes(urlObj.protocol)) {
      return { isValid: false, message: 'URL must start with http:// or https://' };
    }
    
    // Check for obviously invalid URLs (like the cchute.netlify.app issue)
    if (urlObj.hostname.includes('cchute.netlify.app') || 
        urlObj.hostname.includes('career-chute') ||
        urlObj.pathname.startsWith('/$')) {
      return { isValid: false, message: 'This appears to be an invalid placeholder URL. Please enter the actual job posting URL.' };
    }
    
    // Check for common job board domains
    const validJobDomains = [
      'linkedin.com', 'indeed.com', 'glassdoor.com', 'ziprecruiter.com',
      'monster.com', 'careerbuilder.com', 'dice.com', 'angel.co',
      'greenhouse.io', 'lever.co', 'workday.com', 'bamboohr.com',
      'smartrecruiters.com', 'jobvite.com', 'icims.com', 'jobs.com',
      'remote.co', 'weworkremotely.com', 'flexjobs.com', 'upwork.com',
      'github.com', 'stackoverflow.com', 'angel.co', 'crunchbase.com'
    ];
    
    const hostname = urlObj.hostname.toLowerCase();
    const hasValidDomain = validJobDomains.some(domain => 
      hostname === domain || hostname.endsWith('.' + domain)
    );
    
    if (!hasValidDomain) {
      // Allow company websites (not subdomains of known job boards)
      const isCompanySite = !validJobDomains.some(domain => hostname.includes(domain));
      if (isCompanySite) {
        return { isValid: true, message: 'Company website detected' };
      }
    }
    
    return { isValid: true, message: 'Valid job posting URL' };
    
  } catch (error) {
    return { isValid: false, message: 'Invalid URL format' };
  }
}

function promptForValidUrl(currentUrl = '', company = '', role = '') {
  const prompt = `Please enter a valid job posting URL for ${company} - ${role}:\n\nCurrent URL: ${currentUrl || 'None'}\n\nThis should be the direct link to the job posting, not a placeholder or redirect URL.`;
  
  let newUrl = prompt(prompt);
  if (newUrl === null) return null; // User cancelled
  
  newUrl = newUrl.trim();
  if (newUrl === '') return ''; // User cleared the URL
  
  const validation = isValidUrl(newUrl);
  if (!validation.isValid) {
    alert(`Invalid URL: ${validation.message}\n\nPlease try again with a proper job posting URL.`);
    return promptForValidUrl(newUrl, company, role); // Recursive retry
  }
  
  return newUrl;
}

function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

// Firebase sync
function updateSyncStatus(status, text) {
  const indicator = document.getElementById('syncStatus');
  const textEl = document.getElementById('syncText');
  const debugEl = document.getElementById('debugSyncStatus');
  
  if (!indicator || !textEl) return;
  
  indicator.className = 'sync-indicator';
  if (status === 'syncing') indicator.classList.add('syncing');
  if (status === 'synced') indicator.classList.add('synced');
  
  textEl.textContent = text;
  
  // Update debug status
  if (debugEl) {
    debugEl.textContent = `${status || 'idle'}: ${text} | Firebase: ${firebaseAvailable ? 'connected' : 'offline'}`;
  }
}

function saveToFirebase() {
  if (!firebaseAvailable || !db) {
    localStorage.setItem('career_chute_backup', JSON.stringify(state));
    return;
  }
  
  if (isSyncing) return;
  
  try {
    updateSyncStatus('syncing', 'Saving...');
    
    // Filter out emailParsers (contains RegExp objects that can't be serialized)
    const { emailParsers, ...saveableState } = state;
    
    db.collection('users').doc(userId).set({
      ...saveableState,
      lastUpdated: new Date().toISOString()
    }).then(() => {
      updateSyncStatus('synced', 'Synced');
      setTimeout(() => updateSyncStatus('', 'Cloud'), 2000);
    }).catch(error => {
      console.error('Save error:', error);
      updateSyncStatus('error', 'Error');
      localStorage.setItem('career_chute_backup', JSON.stringify(saveableState));
    });
  } catch (error) {
    console.error('Save error:', error);
    updateSyncStatus('error', 'Error');
    // Save saveable state to localStorage (without RegExp objects)
    const { emailParsers, ...saveableState } = state;
    localStorage.setItem('career_chute_backup', JSON.stringify(saveableState));
  }
}

function loadFromFirebase() {
  if (!firebaseAvailable || !db) {
    console.log('Firebase not available, loading from localStorage');
    updateSyncStatus('error', 'Offline');
    loadFromLocalStorage();
    return;
  }
  
  try {
    updateSyncStatus('syncing', 'Loading...');
    
    // Add timeout for Firebase operations
    const loadTimeout = setTimeout(() => {
      console.warn('Firebase load timeout - falling back to localStorage');
      updateSyncStatus('error', 'Offline');
      loadFromLocalStorage();
    }, 10000); // 10 second timeout
    
    db.collection('users').doc(userId).get().then(doc => {
      clearTimeout(loadTimeout);
      
      if (doc.exists) {
        const data = doc.data();
        state = { ...state, ...data };
        delete state.lastUpdated;
      } else {
        loadFromLocalStorage();
      }
      
      initializeWeekAndDay();
      
      updateSyncStatus('synced', 'Synced');
      setTimeout(() => updateSyncStatus('', 'Cloud'), 2000);
      
      renderTodayTasks();
      renderSettings();
      setupRealtimeSync();
    }).catch(error => {
      clearTimeout(loadTimeout);
      console.error('Load error:', error);
      updateSyncStatus('error', 'Offline');
      loadFromLocalStorage();
    });
  } catch (error) {
    console.error('Load error:', error);
    updateSyncStatus('error', 'Offline');
    loadFromLocalStorage();
  }
}

function loadFromLocalStorage() {
  try {
    const backup = localStorage.getItem('career_chute_backup');
    if (backup) {
      state = { ...state, ...JSON.parse(backup) };
    }
  } catch (e) {
    console.error('LocalStorage load error:', e);
  }
  
  initializeWeekAndDay();
  applyTheme();
  renderTodayTasks();
  renderSettings();
}

function applyTheme() {
  document.documentElement.setAttribute('data-theme', state.theme);
}

function toggleTheme() {
  state.theme = state.theme === 'dark' ? 'light' : 'dark';
  applyTheme();
  saveToFirebase();
  renderSettings();
}

function changeColorTheme() {
  const themeSelect = document.getElementById('colorThemeSelect');
  const selectedTheme = themeSelect.value;
  
  // Remove existing color theme
  document.documentElement.removeAttribute('data-color-theme');
  
  // Clear ALL custom colors (including inline styles)
  if (state.customColors) {
    Object.keys(state.customColors).forEach(element => {
      document.documentElement.style.removeProperty(element);
    });
  }
  
  // Apply theme
  if (selectedTheme && selectedTheme !== 'default') {
    if (state.customThemes && state.customThemes[selectedTheme]) {
      // Apply custom theme
      Object.entries(state.customThemes[selectedTheme]).forEach(([element, color]) => {
        document.documentElement.style.setProperty(element, color);
      });
    } else {
      // Apply preset theme
      document.documentElement.setAttribute('data-color-theme', selectedTheme);
    }
  }
  
  // Save to state
  state.colorTheme = selectedTheme;
  saveToFirebase();
}

// Styling Center Functions
const availableColors = [
  '#ffffff', '#72cc99', '#f6f4ed', '#e7f1fd', '#fefefe', '#fcf9f2', '#fdfdfd',
  '#fefbf4', '#fefcf4', '#fcfcfc', '#fbfbfb', '#fafafa'
];

const colorElements = [
  { value: '--bg', label: 'Background' },
  { value: '--text', label: 'Text' },
  { value: '--muted', label: 'Subtitle/Muted Text' },
  { value: '--accent', label: 'Primary Button/Accent' },
  { value: '--ok', label: 'Success/OK' },
  { value: '--warn', label: 'Warning' },
  { value: '--bad', label: 'Error/Bad' },
  { value: '--line', label: 'Borders/Lines' },
  { value: '--panel', label: 'Panel Background' },
  { value: '--glass-bg', label: 'Glass Background' },
  { value: '--glass-border', label: 'Glass Border' }
];

function addStylingRow() {
  const container = document.getElementById('stylingRows');
  const rowId = 'styling-row-' + Date.now();
  
  const row = document.createElement('div');
  row.id = rowId;
  row.style.cssText = 'display: flex; gap: 8px; margin-bottom: 12px; align-items: center;';
  
  row.innerHTML = `
    <select onchange="updateStylingRow('${rowId}')" style="flex: 1; height: 32px; font-size: 12px;">
      <option value="">Select Element</option>
      ${colorElements.map(el => `<option value="${el.value}">${el.label}</option>`).join('')}
    </select>
    <div class="color-palette" style="flex: 1; display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px;">
      ${availableColors.map(color => `
        <div onclick="selectColor('${rowId}', '${color}')" 
             style="width: 24px; height: 24px; background-color: ${color}; border: 2px solid transparent; border-radius: 4px; cursor: pointer; transition: all 0.2s ease;"
             onmouseover="this.style.borderColor='var(--accent)'; this.style.transform='scale(1.1)'"
             onmouseout="this.style.borderColor='transparent'; this.style.transform='scale(1)'"
             title="${color}"></div>
      `).join('')}
    </div>
    <button onclick="removeStylingRow('${rowId}')" class="modern-button secondary" style="height: 32px; padding: 0 8px; font-size: 12px;">Ã</button>
  `;
  
  container.appendChild(row);
}

function selectColor(rowId, color) {
  const row = document.getElementById(rowId);
  const elementSelect = row.querySelector('select');
  const element = elementSelect.value;
  
  if (!element) {
    alert('Please select an element first');
    return;
  }
  
  // Apply color immediately
  document.documentElement.style.setProperty(element, color);
  
  // Update visual feedback
  const colorSwatches = row.querySelectorAll('.color-palette > div');
  colorSwatches.forEach(swatch => {
    swatch.style.borderColor = 'transparent';
    swatch.style.transform = 'scale(1)';
  });
  
  // Highlight selected color
  const selectedSwatch = row.querySelector(`div[onclick*="${color}"]`);
  if (selectedSwatch) {
    selectedSwatch.style.borderColor = 'var(--accent)';
    selectedSwatch.style.transform = 'scale(1.1)';
  }
  
  // Store the selection for theme saving
  if (!state.customColors) state.customColors = {};
  state.customColors[element] = color;
}

function saveAsTheme() {
  if (!state.customColors || Object.keys(state.customColors).length === 0) {
    alert('Please customize some colors first before saving as theme');
    return;
  }
  
  // Generate next theme name (A1, C3, E5, A2, C4, E6, etc.)
  const existingThemes = ['A1', 'C3', 'E5'];
  let nextTheme = 'A2';
  let counter = 2;
  
  while (existingThemes.includes(nextTheme)) {
    const letters = ['A', 'B', 'C', 'D', 'E'];
    const letter = letters[counter % 5];
    const number = Math.floor(counter / 5) + 1;
    nextTheme = letter + number;
    counter++;
  }
  
  // Save the theme
  if (!state.customThemes) state.customThemes = {};
  state.customThemes[nextTheme] = { ...state.customColors };
  saveToFirebase();
  
  // Add to dropdown
  const themeSelect = document.getElementById('colorThemeSelect');
  const newOption = document.createElement('option');
  newOption.value = nextTheme;
  newOption.textContent = `${nextTheme} - Custom Theme`;
  themeSelect.appendChild(newOption);
  
  alert(`Theme saved as ${nextTheme}! You can now select it from the Color Theme dropdown.`);
}

function removeStylingRow(rowId) {
  document.getElementById(rowId).remove();
}

function loadCustomColors() {
  // Clear any existing custom colors first
  if (state.customColors) {
    Object.keys(state.customColors).forEach(element => {
      document.documentElement.style.removeProperty(element);
    });
  }
  
  // Then apply saved custom colors
  if (state.customColors) {
    Object.entries(state.customColors).forEach(([element, color]) => {
      document.documentElement.style.setProperty(element, color);
    });
  }
}

function initializeStylingCenter() {
  const container = document.getElementById('stylingRows');
  if (!container) return;
  
  // Clear existing rows
  container.innerHTML = '';
  
  // Add one initial row
  addStylingRow();
}

function initializeWeekAndDay() {
  if (!state.weekStart || !isCurrentWeek(state.weekStart)) {
    state.weekStart = getMonday();
    state.completedThisWeek = { apps: 0, networking: 0, events: 0 };
  }
  
  if (!state.tasks) state.tasks = {};
  if (!state.dailyTasks) state.dailyTasks = {};
  
  const today = getTodayISO();
  if (!state.dailyTasks[today]) {
    state.dailyTasks[today] = [];
  }
  
  if (!state.taskProgress) state.taskProgress = {};
  if (!state.streaks) state.streaks = { current: 0, longest: 0, lastActiveDate: null };
  if (!state.milestones) state.milestones = [];
  if (!state.dailyTimeTracking) state.dailyTimeTracking = {};
  
  // Handle carryover of unfinished tasks from previous days
  handleTaskCarryover();
}

function handleTaskCarryover() {
  const today = getTodayISO();
  const yesterday = addDays(today, -1);
  
  // Check if yesterday had unfinished tasks
  if (state.dailyTasks[yesterday]) {
    const unfinishedTasks = state.dailyTasks[yesterday].filter(t => !t.completed);
    
    if (unfinishedTasks.length > 0) {
      // Mark applications as in-progress in pipeline
      unfinishedTasks.forEach(task => {
        if (task.type === 'application' && task.refId) {
          const app = state.applications.find(a => a.id === task.refId);
          if (app && app.status === 'queued') {
            app.status = 'in_progress';
          }
        }
      });
      
      // Move unfinished tasks to today (optional - you might want to ask user first)
      // For now, we'll just mark them as in-progress in the pipeline
      console.log(`Found ${unfinishedTasks.length} unfinished tasks from yesterday`);
    }
  }
}

function setupRealtimeSync() {
  if (!firebaseAvailable || !db) return;
  if (unsubscribe) unsubscribe();
  
  try {
    console.log('Setting up realtime sync for user:', userId);
    unsubscribe = db.collection('users').doc(userId).onSnapshot({
      includeMetadataChanges: false
    }, doc => {
      console.log('Realtime update received:', doc.exists);
      if (doc.exists && !isSyncing) {
        const data = doc.data();
        if (data.lastUpdated) {
          isSyncing = true;
          state = { ...state, ...data };
          delete state.lastUpdated;
          
          initializeWeekAndDay();
          
          renderTodayTasks();
          renderProgress();
          renderPlanScreen();
          renderSettings();
          
          setTimeout(() => { isSyncing = false; }, 100);
        }
      }
    }, error => {
      console.error('Realtime sync error:', error);
      updateSyncStatus('error', 'Sync Error');
    });
  } catch (error) {
    console.error('Realtime sync setup error:', error);
    updateSyncStatus('error', 'Sync Setup Error');
  }
  
  // Set up periodic Gmail token expiry check and UI update
  if (state.gmail && state.gmail.connected) {
    setInterval(() => {
      checkTokenExpiry();
      updateGmailUI(); // Update UI to show current token time remaining
    }, 60000); // Check every minute
    
    console.log('Gmail token monitoring started - will check every minute');
  }
}

// Navigation
function showScreen(screenId) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(screenId).classList.add('active');
  
  document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
  if (event && event.target) {
    event.target.closest('.nav-btn').classList.add('active');
  }
  
  if (screenId === 'today') {
    window.scrollTo(0, 0);
    renderTodayTasks();
  }
  if (screenId === 'plan') renderPlanScreen();
  if (screenId === 'progress') renderProgress();
  if (screenId === 'jobs') {
    renderPrioritizationSettings();
    renderCityGradingSettings();
    renderJobQueue();
  }
  if (screenId === 'mapping') {
    // Initialize parser statistics and rules
    initParserStats();
  }
  if (screenId === 'settings') renderSettings();
}

// Today's tasks rendering
function renderTodayTasks() {
  const today = getTodayISO();
  const todayTasks = state.dailyTasks[today] || [];
  const container = document.getElementById('todayTasks');
  
  if (todayTasks.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-emoji">ð­</div>
        <p>No tasks queued for today</p>
        <p style="font-size: 14px;">Add tasks to get started</p>
      </div>
    `;
    updateTodayStats();
    return;
  }
  
  const activeTasks = todayTasks.filter(t => !t.completed);
  const completedTasks = todayTasks.filter(t => t.completed);
  
  const sortedActive = [...activeTasks].sort((a, b) => {
    const urgencyA = getTaskUrgency(a);
    const urgencyB = getTaskUrgency(b);
    const urgencyOrder = { urgent: 0, soon: 1, ok: 2 };
    return urgencyOrder[urgencyA] - urgencyOrder[urgencyB];
  });
  
  const mergedCompleted = mergeCompletedApplications(completedTasks);
  
  let html = '';
  
  if (sortedActive.length > 0) {
    html += sortedActive.map(task => renderTaskCard(task, false)).join('');
  }
  
  if (mergedCompleted.length > 0) {
    html += '<div style="margin-top: 32px; padding-top: 24px; border-top: 2px dashed var(--line);"></div>';
    html += mergedCompleted.map(item => {
      if (item.merged) {
        return renderMergedApplicationCard(item);
      } else {
        return renderTaskCard(item, true);
      }
    }).join('');
  }
  
  container.innerHTML = html;
  updateTodayStats();
  
  // Auto-queue today's events if not already present
  const todayISO = getTodayISO();
  const todaysEvents = state.events.filter(e => e.date === todayISO);
  todaysEvents.forEach(evt => {
    const exists = (state.dailyTasks[todayISO] || []).some(t => t.type === 'event' && t.refId === evt.id);
    if (!exists) {
      const eventTask = { id: generateId(), type: 'event', refId: evt.id, completed: !!evt.attended, estimatedTime: evt.duration || 60, notes: '' };
      state.dailyTasks[todayISO].push(eventTask);
    }
  });
  
  // Render focus panel
  renderFocusPanel();
  
  // Update today's date
  updateTodayDate();
}

function updateTodayDate() {
  const todayDateEl = document.getElementById('todayDate');
  if (todayDateEl) {
    const today = new Date();
    const options = { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric',
      timeZone: 'America/Los_Angeles'
    };
    todayDateEl.textContent = today.toLocaleDateString('en-US', options);
  }
}

// Focus Session Panel Functions
function renderFocusPanel() {
  const panel = document.getElementById('focusSessionPanel');
  if (!panel) return;
  
  if (!state.timeBlocking || !state.timeBlocking.currentDay) {
    // Show start day section
    panel.style.display = 'block';
    document.getElementById('startDaySection').style.display = 'block';
    document.getElementById('activeSessionSection').style.display = 'none';
  } else {
    // Show active session
    panel.style.display = 'block';
    document.getElementById('startDaySection').style.display = 'none';
    document.getElementById('activeSessionSection').style.display = 'block';
    
    // Update session info
    const currentDay = state.timeBlocking.currentDay;
    const today = getTodayISO();
    
    // Update start time if it's a new day
    if (currentDay.date !== today) {
      const now = new Date();
      currentDay.startTime = now.toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true,
        timeZone: 'America/Los_Angeles'
      });
      currentDay.date = today;
      saveToFirebase();
    }
    
    document.getElementById('sessionStartTime').textContent = currentDay.startTime;
    
    // Update daily goal selector
    const goalSelect = document.getElementById('activeDailyGoalSelect');
    if (goalSelect) {
      const goalHours = Math.floor(currentDay.goalBlocks / 4);
      goalSelect.value = goalHours;
    }
    
    // Render block grid
    renderNewBlockGrid();
    
    // Update total accumulated time
    updateTotalTimeDisplay();
    
    // Handle active chunk timer
    if (currentDay.activeChunk && currentDay.activeChunk.status === 'active') {
      // Restore timer state from saved data
      const chunk = currentDay.activeChunk;
      const now = Date.now();
      
      // Calculate elapsed time since chunk started
      const chunkStart = new Date(chunk.startTime).getTime();
      const elapsed = Math.floor((now - chunkStart) / 1000);
      const remaining = Math.max(0, chunk.remainingTime - elapsed);
      
      if (remaining > 0) {
        // Restore timer variables
        chunkStartTime = chunkStart;
        chunkPausedTime = chunk.pausedTime || 0;
        
        // Update remaining time
        chunk.remainingTime = remaining;
        
        // Show active chunk UI
        document.getElementById('activeChunkSection').style.display = 'block';
        document.getElementById('startChunkBtn').style.display = 'none';
        
        // Start timer
        startFocusChunkTimer();
        
        // Save updated state
        saveToFirebase();
      } else {
        // Chunk should have finished
        finishFocusChunk();
      }
    }
  }
}

function startDay() {
  // Check if we need to save previous day first
  const today = getTodayISO();
  if (state.timeBlocking?.currentDay && state.timeBlocking.currentDay.date !== today) {
    saveDailyDataToHistory();
  }
  
  // Initialize time blocking if it doesn't exist
  if (!state.timeBlocking) {
    state.timeBlocking = {
      history: {},
      achievements: {
        badges: [],
        streaks: {
          workStreak: 0,
          goalStreak: 0,
          longestWork: 0,
          longestGoal: 0,
          currentWorkStreak: 0,
          currentGoalStreak: 0
        },
        stats: {
          totalBlocks: 0,
          totalOnTaskTime: 0,
          totalSessions: 0,
          bestDay: 0,
          perfectDays: 0
        }
      }
    };
  }
  
  // Start new day
  startNewDay();
}

// New Focus Session Functions
function startNewFocusDay() {
  const today = getTodayISO();
  const goalHours = parseInt(document.getElementById('dailyGoalSelect').value);
  const goalBlocks = goalHours * 4; // 4 blocks per hour (15 min each)
  
  // Initialize time blocking if it doesn't exist
  if (!state.timeBlocking) {
    state.timeBlocking = {
      history: {},
      achievements: {
        badges: [],
        streaks: {
          workStreak: 0,
          goalStreak: 0,
          longestWork: 0,
          longestGoal: 0,
          currentWorkStreak: 0,
          currentGoalStreak: 0
        }
      }
    };
  }
  
  // Create new day
  state.timeBlocking.currentDay = {
    date: today,
    startTime: new Date().toLocaleTimeString('en-US', { 
      hour: 'numeric', 
      minute: '2-digit',
      hour12: true 
    }),
    goalBlocks: goalBlocks,
    completedBlocks: 0,
    queuedBlocks: 0,
    activeChunk: null,
    chunks: []
  };
  
  saveToFirebase();
  renderFocusPanel();
}

function renderNewBlockGrid() {
  const grid = document.getElementById('blockGrid');
  const progressText = document.getElementById('progressText');
  if (!grid || !state.timeBlocking?.currentDay) return;
  
  const { goalBlocks, completedBlocks, queuedBlocks } = state.timeBlocking.currentDay;
  
  // Update progress text
  if (progressText) {
    progressText.textContent = `${completedBlocks}/${goalBlocks} blocks completed`;
  }
  
  grid.innerHTML = '';
  
  for (let i = 0; i < goalBlocks; i++) {
    const block = document.createElement('div');
    block.className = 'focus-block';
    block.dataset.index = i;
    
    if (i < completedBlocks) {
      block.classList.add('filled');
    } else if (i < completedBlocks + queuedBlocks) {
      block.classList.add('queued');
    }
    
    grid.appendChild(block);
  }
}

function startFocusChunk() {
  if (!state.timeBlocking?.currentDay) return;
  
  const duration = parseInt(document.getElementById('chunkDuration').value);
  const blocks = Math.floor(duration / 15); // 15 minutes per block
  const now = new Date();
  
  // Mark blocks as queued
  state.timeBlocking.currentDay.queuedBlocks = blocks;
  
  // Create active chunk
  state.timeBlocking.currentDay.activeChunk = {
    id: 'chunk_' + Date.now(),
    plannedDuration: duration,
    blocks: blocks,
    completedBlocks: 0,
    startTime: now.toLocaleTimeString('en-US', { 
      hour: 'numeric', 
      minute: '2-digit',
      hour12: true 
    }),
    status: 'active',
    remainingTime: duration * 60 // seconds
  };
  
  // Start timer
  chunkStartTime = now;
  chunkPausedTime = 0;
  
  // Save start time to chunk for persistence
  activeChunk.startTime = new Date(now).toISOString();
  
  // Show active chunk section
  document.getElementById('activeChunkSection').style.display = 'block';
  document.getElementById('startChunkBtn').style.display = 'none';
  
  // Start rainbow alert for chunk start
  triggerGreenAlert();
  
  // Start timer
  startFocusChunkTimer();
  
  // Update UI
  renderNewBlockGrid();
  saveToFirebase();
}

function startFocusChunkTimer() {
  if (chunkTimerInterval) {
    clearInterval(chunkTimerInterval);
  }
  
  chunkTimerInterval = setInterval(updateFocusChunkTimer, 1000);
}

function updateFocusChunkTimer() {
  if (!state.timeBlocking?.currentDay?.activeChunk) {
    stopFocusChunkTimer();
    return;
  }
  
  const activeChunk = state.timeBlocking.currentDay.activeChunk;
  
  if (activeChunk.status !== 'active') {
    return;
  }
  
  // Calculate remaining time
  const now = Date.now();
  const elapsed = Math.floor((now - chunkStartTime - chunkPausedTime) / 1000);
  const remaining = Math.max(0, activeChunk.remainingTime - elapsed);
  
  // Update timer display
  const minutes = Math.floor(remaining / 60);
  const seconds = remaining % 60;
  const timerDisplay = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  document.getElementById('chunkTimer').textContent = timerDisplay;
  
  // Update progress
  const totalElapsed = Math.floor((now - chunkStartTime - chunkPausedTime) / 60); // minutes
  const blocksCompleted = Math.floor(totalElapsed / 15);
  const currentBlockProgress = (totalElapsed % 15) / 15;
  
  // Update chunk progress
  document.getElementById('chunkProgress').textContent = `${blocksCompleted}/${activeChunk.blocks} blocks completed`;
  
  // Update block grid
  updateBlockProgress(blocksCompleted, currentBlockProgress);
  
  // Check if chunk is complete
  if (remaining <= 0) {
    finishFocusChunk();
  }
}

function updateBlockProgress(completedBlocks, currentBlockProgress) {
  const grid = document.getElementById('blockGrid');
  if (!grid) return;
  
  const blocks = grid.querySelectorAll('.focus-block');
  const { goalBlocks, completedBlocks: totalCompleted } = state.timeBlocking.currentDay;
  
  blocks.forEach((block, index) => {
    const blockIndex = parseInt(block.dataset.index);
    
    // Remove all classes
    block.classList.remove('filled', 'queued', 'active');
    
    if (blockIndex < totalCompleted) {
      block.classList.add('filled');
    } else if (blockIndex === totalCompleted && currentBlockProgress > 0) {
      block.classList.add('active');
    } else if (blockIndex < totalCompleted + state.timeBlocking.currentDay.queuedBlocks) {
      block.classList.add('queued');
    }
  });
}

function pauseFocusChunk() {
  if (!state.timeBlocking?.currentDay?.activeChunk) return;
  
  const activeChunk = state.timeBlocking.currentDay.activeChunk;
  
  if (activeChunk.status === 'active') {
    activeChunk.status = 'paused';
    chunkPausedTime = Date.now();
    activeChunk.pausedTime = chunkPausedTime;
    stopFocusChunkTimer();
    
    // Add yellow pulse background effect
    document.body.classList.add('yellow-pulse');
    
    document.getElementById('pauseChunkBtn').textContent = 'â¶ï¸ Resume';
    document.getElementById('pauseChunkBtn').onclick = resumeFocusChunk;
  }
  
  saveToFirebase();
}

function resumeFocusChunk() {
  if (!state.timeBlocking?.currentDay?.activeChunk) return;
  
  const activeChunk = state.timeBlocking.currentDay.activeChunk;
  
  if (activeChunk.status === 'paused') {
    activeChunk.status = 'active';
    chunkPausedTime = 0;
    activeChunk.pausedTime = 0;
    
    // Remove yellow pulse background effect
    document.body.classList.remove('yellow-pulse');
    
    startFocusChunkTimer();
    
    document.getElementById('pauseChunkBtn').textContent = 'â¸ï¸ Pause';
    document.getElementById('pauseChunkBtn').onclick = pauseFocusChunk;
  }
  
  saveToFirebase();
}

function finishFocusChunk() {
  if (!state.timeBlocking?.currentDay?.activeChunk) return;
  
  const activeChunk = state.timeBlocking.currentDay.activeChunk;
  const now = new Date();
  
  // Calculate final elapsed time
  const totalElapsed = Math.floor((now - chunkStartTime - chunkPausedTime) / 60); // minutes
  const blocksCompleted = Math.floor(totalElapsed / 15);
  
  // Update completed blocks
  state.timeBlocking.currentDay.completedBlocks += blocksCompleted;
  state.timeBlocking.currentDay.queuedBlocks = 0;
  
  // Add to chunks history
  state.timeBlocking.currentDay.chunks.push({
    ...activeChunk,
    completedAt: now.toISOString(),
    actualDuration: totalElapsed
  });
  
  // Clear active chunk
  state.timeBlocking.currentDay.activeChunk = null;
  
  // Hide active chunk section
  document.getElementById('activeChunkSection').style.display = 'none';
  document.getElementById('startChunkBtn').style.display = 'inline-block';
  
  // Stop timer
  stopFocusChunkTimer();
  
  // Trigger rainbow alert for completion
  triggerRainbowAlert();
  
  // Update UI
  renderNewBlockGrid();
  updateTotalTimeDisplay();
  saveToFirebase();
  
  // Check if daily goal is achieved
  if (state.timeBlocking.currentDay.completedBlocks >= state.timeBlocking.currentDay.goalBlocks) {
    setTimeout(() => {
      alert('ð Daily focus goal achieved! Great work!');
    }, 1000);
  }
}

function stopFocusChunkTimer() {
  if (chunkTimerInterval) {
    clearInterval(chunkTimerInterval);
    chunkTimerInterval = null;
  }
}

function resetFocusProgress() {
  if (!confirm('Are you sure you want to reset your progress for today?')) return;
  
  if (state.timeBlocking?.currentDay) {
    state.timeBlocking.currentDay.completedBlocks = 0;
    state.timeBlocking.currentDay.queuedBlocks = 0;
    state.timeBlocking.currentDay.activeChunk = null;
    
    // Stop any active timer
    stopFocusChunkTimer();
    
    // Update UI
    renderNewBlockGrid();
    document.getElementById('activeChunkSection').style.display = 'none';
    document.getElementById('startChunkBtn').style.display = 'inline-block';
    
    saveToFirebase();
  }
}

function endFocusDay() {
  if (!confirm('Are you sure you want to end your focus day?')) return;
  
  // Save current day to history
  if (state.timeBlocking?.currentDay) {
    const today = getTodayISO();
    state.timeBlocking.history[today] = { ...state.timeBlocking.currentDay };
    state.timeBlocking.currentDay = null;
    
    // Stop any active timer
    stopFocusChunkTimer();
    
    saveToFirebase();
    renderFocusPanel();
  }
}

function triggerRainbowAlert() {
  document.body.classList.add('rainbow-alert');
  setTimeout(() => {
    document.body.classList.remove('rainbow-alert');
  }, 500);
}

function triggerGreenAlert() {
  document.body.classList.add('green-alert');
  setTimeout(() => {
    document.body.classList.remove('green-alert');
  }, 800);
}

function updateDailyGoal() {
  if (!state.timeBlocking?.currentDay) return;
  
  const goalHours = parseInt(document.getElementById('activeDailyGoalSelect').value);
  const goalBlocks = goalHours * 4;
  
  state.timeBlocking.currentDay.goalBlocks = goalBlocks;
  saveToFirebase();
  renderNewBlockGrid();
  updateTotalTimeDisplay();
}

function pauseFocusSessionForTask() {
  // Pause focus session timer when entering task focus mode
  if (state.timeBlocking?.currentDay?.activeChunk?.status === 'active') {
    const activeChunk = state.timeBlocking.currentDay.activeChunk;
    activeChunk.status = 'paused-for-task';
    activeChunk.pausedForTaskTime = Date.now();
    stopFocusChunkTimer();
    
    // Update UI to show paused state
    document.getElementById('pauseChunkBtn').textContent = 'â¶ï¸ Resume';
    document.getElementById('pauseChunkBtn').onclick = resumeFocusSessionFromTask;
    
    saveToFirebase();
  }
}

function resumeFocusSessionFromTask() {
  // Resume focus session timer when exiting task focus mode
  if (state.timeBlocking?.currentDay?.activeChunk?.status === 'paused-for-task') {
    const activeChunk = state.timeBlocking.currentDay.activeChunk;
    activeChunk.status = 'active';
    
    // Adjust start time to account for task focus time
    if (activeChunk.pausedForTaskTime) {
      const taskFocusDuration = Date.now() - activeChunk.pausedForTaskTime;
      activeChunk.startTime += taskFocusDuration;
      delete activeChunk.pausedForTaskTime;
    }
    
    // Update UI to show active state
    document.getElementById('pauseChunkBtn').textContent = 'â¸ï¸ Pause';
    document.getElementById('pauseChunkBtn').onclick = pauseFocusChunk;
    
    startFocusChunkTimer();
    saveToFirebase();
  }
}

function checkTimerConflicts() {
  // Check for conflicts between focus session and task timers
  const hasActiveFocusSession = state.timeBlocking?.currentDay?.activeChunk?.status === 'active';
  const hasActiveTask = state.currentTask && state.focusStartTime;
  
  if (hasActiveFocusSession && hasActiveTask) {
    console.warn('â ï¸ Timer conflict detected: Both focus session and task timer are active');
    
    // Resolve conflict by pausing focus session (task takes priority)
    if (state.timeBlocking.currentDay.activeChunk) {
      state.timeBlocking.currentDay.activeChunk.status = 'paused-for-task';
      state.timeBlocking.currentDay.activeChunk.pausedForTaskTime = Date.now();
      
      // Update UI
      const pauseBtn = document.getElementById('pauseChunkBtn');
      if (pauseBtn) {
        pauseBtn.textContent = 'â¶ï¸ Resume';
        pauseBtn.onclick = resumeFocusSessionFromTask;
      }
      
      console.log('â Resolved conflict: Focus session paused for active task');
      saveToFirebase();
    }
  }
  
  // Check for stale timers (older than 24 hours)
  const now = Date.now();
  const oneDayAgo = now - (24 * 60 * 60 * 1000);
  
  if (state.focusStartTime && state.focusStartTime < oneDayAgo) {
    console.warn('â ï¸ Stale task timer detected, clearing...');
    state.currentTask = null;
    state.focusStartTime = null;
    saveToFirebase();
  }
  
  if (state.timeBlocking?.currentDay?.activeChunk?.startTime) {
    const chunkStartTime = new Date(state.timeBlocking.currentDay.activeChunk.startTime).getTime();
    if (chunkStartTime < oneDayAgo) {
      console.warn('â ï¸ Stale focus session timer detected, clearing...');
      state.timeBlocking.currentDay.activeChunk = null;
      saveToFirebase();
    }
  }
}

function handleEventTypeChange() {
  const eventType = document.getElementById('newEventType').value;
  const favoritesGroup = document.getElementById('favoritesGroup');
  
  if (eventType === 'volunteer') {
    favoritesGroup.style.display = 'block';
  } else {
    favoritesGroup.style.display = 'none';
    // Clear favorites selection if not volunteer
    document.getElementById('newEventFavorites').value = '';
  }
}

function handleFavoritesChange() {
  const favorite = document.getElementById('newEventFavorites').value;
  const nameField = document.getElementById('newEventName');
  const addressField = document.getElementById('newEventAddress');
  
  if (favorite === 'project_angel_food') {
    nameField.value = 'Project Angel Food';
    addressField.value = '230 W. Ave 26, Los Angeles, CA 90031';
  } else if (favorite === 'compost_la') {
    nameField.value = 'Compost LA';
    addressField.value = ''; // You can add Compost LA address here if needed
  } else {
    // Clear fields if no favorite selected
    if (nameField.value === 'Project Angel Food' || nameField.value === 'Compost LA') {
      nameField.value = '';
    }
    if (addressField.value === '230 W. Ave 26, Los Angeles, CA 90031') {
      addressField.value = '';
    }
  }
}

function showFocusInstructions() {
  document.getElementById('focusInstructionsModal').style.display = 'flex';
}

function closeFocusInstructions() {
  document.getElementById('focusInstructionsModal').style.display = 'none';
}

function updateTotalTimeDisplay() {
  const totalTimeElement = document.getElementById('totalTimeText');
  if (!totalTimeElement || !state.timeBlocking?.currentDay) return;
  
  const currentDay = state.timeBlocking.currentDay;
  const completedBlocks = currentDay.completedBlocks || 0;
  const totalMinutes = completedBlocks * 15; // Each block is 15 minutes
  
  let timeText;
  if (totalMinutes < 60) {
    timeText = `${totalMinutes}m`;
  } else {
    const hours = Math.floor(totalMinutes / 60);
    const minutes = totalMinutes % 60;
    timeText = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
  }
  
  totalTimeElement.textContent = `Total: ${timeText}`;
}

function renderBlockGrid() {
  const grid = document.getElementById('blockGrid');
  if (!grid || !state.timeBlocking?.currentDay) return;
  
  const { goalBlocks, completedBlocks } = state.timeBlocking.currentDay;
  const totalBlocks = Math.max(goalBlocks, 24); // Show at least 24 blocks
  
  grid.innerHTML = '';
  
  for (let i = 0; i < totalBlocks; i++) {
    const block = document.createElement('div');
    block.className = 'focus-block';
    block.dataset.index = i;
    
    if (i < completedBlocks) {
      block.classList.add('filled');
    }
    
    grid.appendChild(block);
  }
}

function updateBlockGrid() {
  const grid = document.getElementById('blockGrid');
  if (!grid || !state.timeBlocking?.currentDay) return;
  
  const { goalBlocks, completedBlocks } = state.timeBlocking.currentDay;
  const totalBlocks = Math.max(goalBlocks, 24);
  
  // Update existing blocks
  const existingBlocks = grid.querySelectorAll('.focus-block');
  
  existingBlocks.forEach((block, index) => {
    const blockIndex = parseInt(block.dataset.index);
    
    if (blockIndex < completedBlocks) {
      if (!block.classList.contains('filled')) {
        block.classList.add('filled');
      }
    } else {
      block.classList.remove('filled');
    }
  });
  
  // Add new blocks if needed
  const currentBlockCount = existingBlocks.length;
  if (currentBlockCount < totalBlocks) {
    for (let i = currentBlockCount; i < totalBlocks; i++) {
      const block = document.createElement('div');
      block.className = 'focus-block';
      block.dataset.index = i;
      
      if (i < completedBlocks) {
        block.classList.add('filled');
      }
      
      grid.appendChild(block);
    }
  }
  
  // Remove excess blocks if goal decreased
  if (currentBlockCount > totalBlocks) {
    for (let i = totalBlocks; i < currentBlockCount; i++) {
      const blockToRemove = grid.querySelector(`[data-index="${i}"]`);
      if (blockToRemove) {
        blockToRemove.remove();
      }
    }
  }
}

function formatMinutes(minutes) {
  if (minutes < 60) {
    return `${minutes}m`;
  }
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;
  return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
}

function startChunk() {
  if (!state.timeBlocking?.currentDay) return;
  
  const duration = parseInt(document.getElementById('chunkDuration').value) || 90;
  const now = new Date();
  
  state.timeBlocking.currentDay.activeChunk = {
    id: 'chunk_' + Date.now(),
    plannedDuration: duration,
    startTime: now.toLocaleTimeString('en-US', { 
      hour: 'numeric', 
      minute: '2-digit',
      hour12: true 
    }),
    elapsedTime: 0,
    status: 'active',
    onTaskTime: 0,
    offTaskTime: 0,
    remainingTime: duration * 60 // seconds
  };
  
  state.timeBlocking.currentDay.currentMode = 'on-task';
  state.timeBlocking.currentDay.modeStartTime = now.toISOString();
  
  // Start the countdown timer
  chunkStartTime = now;
  chunkPausedTime = 0;
  startChunkTimer();
  
  // Show timer and toggle sections
  document.getElementById('timerSection').style.display = 'block';
  document.getElementById('taskToggleSection').style.display = 'block';
  document.getElementById('chunkControlBtn').textContent = 'Chunk Active';
  document.getElementById('chunkControlBtn').disabled = true;
  
  // Update button states
  updateTimerButtons('active');
  updateTaskModeButtons(); // Set ON TASK as default active
  
  saveToFirebase();
  renderFocusPanel();
}

function pauseChunk() {
  if (!state.timeBlocking?.currentDay?.activeChunk) return;
  
  const activeChunk = state.timeBlocking.currentDay.activeChunk;
  
  if (activeChunk.status === 'active') {
    // Pause the timer
    activeChunk.status = 'paused';
    chunkPausedTime = Date.now();
    stopChunkTimer();
    
    // Update UI
    updateTimerButtons('paused');
    document.getElementById('pauseBtn').textContent = 'â¶ï¸ Resume';
    
  } else if (activeChunk.status === 'paused') {
    // Resume the timer
    activeChunk.status = 'active';
    if (chunkPausedTime) {
      chunkPausedTime = Date.now() - chunkPausedTime;
    }
    startChunkTimer();
    
    // Update UI
    updateTimerButtons('active');
    document.getElementById('pauseBtn').textContent = 'â¸ï¸ Pause';
  }
  
  saveToFirebase();
}

function finishChunk() {
  if (!state.timeBlocking?.currentDay?.activeChunk) return;
  
  const activeChunk = state.timeBlocking.currentDay.activeChunk;
  
  // Stop the timer
  stopChunkTimer();
  
  // Log the final session before finishing
  const now = new Date();
  const currentMode = state.timeBlocking.currentDay.currentMode;
  const modeStartTime = new Date(state.timeBlocking.currentDay.modeStartTime);
  const finalSessionTime = Math.floor((now - modeStartTime) / 1000 / 60); // minutes
  
  if (finalSessionTime > 0) {
    const session = {
      mode: currentMode,
      duration: finalSessionTime,
      startTime: state.timeBlocking.currentDay.modeStartTime,
      endTime: now.toISOString()
    };
    
    if (!activeChunk.sessions) {
      activeChunk.sessions = [];
    }
    activeChunk.sessions.push(session);
    
    // Add final session time to counters
    if (currentMode === 'on-task') {
      activeChunk.onTaskTime += finalSessionTime;
      
      // Check for final block fills
      const totalOnTaskTime = activeChunk.onTaskTime;
      const blocksToFill = Math.floor(totalOnTaskTime / 30);
      const currentCompletedBlocks = state.timeBlocking.currentDay.completedBlocks;
      
      if (blocksToFill > currentCompletedBlocks) {
        state.timeBlocking.currentDay.completedBlocks = blocksToFill;
        updateBlockGrid();
      }
    } else {
      activeChunk.offTaskTime += finalSessionTime;
    }
  }
  
  // Calculate final elapsed time
  const totalElapsed = Math.floor((now - chunkStartTime - chunkPausedTime) / 1000);
  activeChunk.elapsedTime = totalElapsed;
  activeChunk.status = 'complete';
  
  // Add to chunks history
  state.timeBlocking.currentDay.chunks.push({
    ...activeChunk,
    completedAt: now.toISOString()
  });
  
  // Clear active chunk
  state.timeBlocking.currentDay.activeChunk = null;
  
  // Hide timer sections
  document.getElementById('timerSection').style.display = 'none';
  document.getElementById('taskToggleSection').style.display = 'none';
  document.getElementById('chunkControlBtn').textContent = 'Start Chunk';
  document.getElementById('chunkControlBtn').disabled = false;
  
  // Show completion message
  showChunkCompletion(totalElapsed);
  
  saveToFirebase();
  renderFocusPanel();
  
  // Check if we should save today's data to history
  saveDailyDataToHistory();
  
  // Check for achievements
  checkAchievements();
}

function startChunkTimer() {
  if (chunkTimerInterval) {
    clearInterval(chunkTimerInterval);
  }
  
  chunkTimerInterval = setInterval(updateChunkTimer, 1000);
}

function stopChunkTimer() {
  if (chunkTimerInterval) {
    clearInterval(chunkTimerInterval);
    chunkTimerInterval = null;
  }
}

function updateChunkTimer() {
  if (!state.timeBlocking?.currentDay?.activeChunk) {
    stopChunkTimer();
    return;
  }
  
  const activeChunk = state.timeBlocking.currentDay.activeChunk;
  
  if (activeChunk.status !== 'active') {
    return;
  }
  
  // Calculate remaining time
  const now = Date.now();
  const elapsed = Math.floor((now - chunkStartTime - chunkPausedTime) / 1000);
  const remaining = Math.max(0, activeChunk.remainingTime - elapsed);
  
  // Update display
  const minutes = Math.floor(remaining / 60);
  const seconds = remaining % 60;
  const timerDisplay = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  
  const timerElement = document.getElementById('chunkTimer');
  if (timerElement) {
    timerElement.textContent = timerDisplay;
    
    // Change color when time is running low
    if (remaining <= 300) { // 5 minutes
      timerElement.style.color = 'var(--warn)';
    } else if (remaining <= 60) { // 1 minute
      timerElement.style.color = 'var(--bad)';
    } else {
      timerElement.style.color = 'var(--accent)';
    }
  }
  
  // Auto-finish when timer reaches zero
  if (remaining === 0) {
    finishChunk();
  }
  
  // Update state
  activeChunk.elapsedTime = elapsed;
}

function updateTimerButtons(status) {
  const pauseBtn = document.getElementById('pauseBtn');
  const finishBtn = document.getElementById('finishBtn');
  
  if (status === 'active') {
    pauseBtn.textContent = 'â¸ï¸ Pause';
    pauseBtn.disabled = false;
    finishBtn.disabled = false;
  } else if (status === 'paused') {
    pauseBtn.textContent = 'â¶ï¸ Resume';
    pauseBtn.disabled = false;
    finishBtn.disabled = false;
  }
}

function showChunkCompletion(elapsedSeconds) {
  const minutes = Math.floor(elapsedSeconds / 60);
  const seconds = elapsedSeconds % 60;
  const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
  
  // Show completion message
  alert(`ð Chunk completed in ${timeStr}!`);
}

function setTaskMode(mode) {
  if (!state.timeBlocking?.currentDay?.activeChunk) return;
  
  const now = new Date();
  const currentMode = state.timeBlocking.currentDay.currentMode;
  const modeStartTime = new Date(state.timeBlocking.currentDay.modeStartTime);
  const timeSpent = Math.floor((now - modeStartTime) / 1000 / 60); // minutes
  
  // Don't switch if already in the same mode
  if (currentMode === mode) return;
  
  // Log the previous session
  if (timeSpent > 0) {
    const session = {
      mode: currentMode,
      duration: timeSpent,
      startTime: state.timeBlocking.currentDay.modeStartTime,
      endTime: now.toISOString()
    };
    
    // Add to sessions array
    if (!state.timeBlocking.currentDay.activeChunk.sessions) {
      state.timeBlocking.currentDay.activeChunk.sessions = [];
    }
    state.timeBlocking.currentDay.activeChunk.sessions.push(session);
    
    // Add time to appropriate counter
    if (currentMode === 'on-task') {
      state.timeBlocking.currentDay.activeChunk.onTaskTime += timeSpent;
      
      // Check if we should fill a block (every 30 minutes of on-task time)
      const totalOnTaskTime = state.timeBlocking.currentDay.activeChunk.onTaskTime;
      const blocksToFill = Math.floor(totalOnTaskTime / 30);
      const currentCompletedBlocks = state.timeBlocking.currentDay.completedBlocks;
      
      if (blocksToFill > currentCompletedBlocks) {
        state.timeBlocking.currentDay.completedBlocks = blocksToFill;
        updateBlockGrid();
      }
    } else {
      state.timeBlocking.currentDay.activeChunk.offTaskTime += timeSpent;
    }
  }
  
  // Update mode
  state.timeBlocking.currentDay.currentMode = mode;
  state.timeBlocking.currentDay.modeStartTime = now.toISOString();
  
  // Update UI
  updateTaskModeButtons();
  document.getElementById('offTaskTime').textContent = formatMinutes(state.timeBlocking.currentDay.activeChunk.offTaskTime);
  
  saveToFirebase();
}

function updateTaskModeButtons() {
  const currentMode = state.timeBlocking?.currentDay?.currentMode;
  const onTaskBtn = document.getElementById('onTaskBtn');
  const offTaskBtn = document.getElementById('offTaskBtn');
  
  if (currentMode === 'on-task') {
    // ON TASK is active
    onTaskBtn.style.background = 'var(--ok)';
    onTaskBtn.style.color = 'white';
    onTaskBtn.style.transform = 'scale(1.05)';
    onTaskBtn.style.boxShadow = '0 0 20px rgba(121, 221, 148, 0.4)';
    
    offTaskBtn.style.background = 'var(--muted)';
    offTaskBtn.style.color = 'white';
    offTaskBtn.style.transform = 'scale(1)';
    offTaskBtn.style.boxShadow = 'none';
  } else {
    // OFF TASK is active
    offTaskBtn.style.background = 'var(--warn)';
    offTaskBtn.style.color = 'white';
    offTaskBtn.style.transform = 'scale(1.05)';
    offTaskBtn.style.boxShadow = '0 0 20px rgba(255, 190, 90, 0.4)';
    
    onTaskBtn.style.background = 'var(--muted)';
    onTaskBtn.style.color = 'white';
    onTaskBtn.style.transform = 'scale(1)';
    onTaskBtn.style.boxShadow = 'none';
  }
}

function incrementCompletedBlocks() {
  if (!state.timeBlocking?.currentDay) return;
  
  const currentDay = state.timeBlocking.currentDay;
  const { goalBlocks, completedBlocks } = currentDay;
  
  if (completedBlocks < goalBlocks) {
    currentDay.completedBlocks += 1;
    saveToFirebase();
    updateBlockGrid();
    
    // Check if goal is reached
    if (currentDay.completedBlocks >= goalBlocks) {
      showGoalAchieved();
    }
    
    // Check for achievements
    checkAchievements();
  }
}

function showGoalAchieved() {
  // Create celebration effect
  const grid = document.getElementById('blockGrid');
  if (grid) {
    grid.style.animation = 'pulse 1s ease-in-out';
  }
  
  // Show achievement message (could be enhanced with confetti, etc.)
  setTimeout(() => {
    alert('ð Daily focus goal achieved! Great work!');
  }, 500);
}

// Add pulse animation for goal achievement
const pulseKeyframes = `
@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.02); }
  100% { transform: scale(1); }
}`;

// Add the keyframes to the document
const style = document.createElement('style');
style.textContent = pulseKeyframes;
document.head.appendChild(style);

function mergeCompletedApplications(completedTasks) {
  const appGroups = {};
  const otherTasks = [];
  
  completedTasks.forEach(task => {
    if ((task.type === 'application' || task.type === 'tailoring') && task.refId) {
      if (!appGroups[task.refId]) {
        appGroups[task.refId] = { tailoring: null, application: null };
      }
      if (task.type === 'tailoring') {
        appGroups[task.refId].tailoring = task;
      } else {
        appGroups[task.refId].application = task;
      }
    } else {
      otherTasks.push(task);
    }
  });
  
  const merged = [];
  
  Object.keys(appGroups).forEach(refId => {
    const group = appGroups[refId];
    if (group.tailoring && group.application) {
      const app = state.applications.find(a => a.id === refId);
      const celebrationEmojis = ['ð', 'ð', 'ðª', 'â­', 'ð', 'â¨', 'ð¥', 'ð¼'];
      const emoji = celebrationEmojis[Math.floor(Math.random() * celebrationEmojis.length)];
      
      merged.push({
        merged: true,
        refId,
        app,
        tailoringTask: group.tailoring,
        applicationTask: group.application,
        emoji,
        totalTime: (group.tailoring.actualTime || 0) + (group.application.actualTime || 0)
      });
    } else {
      if (group.tailoring) otherTasks.push(group.tailoring);
      if (group.application) otherTasks.push(group.application);
    }
  });
  
  return [...merged, ...otherTasks];
}

function renderMergedApplicationCard(item) {
  return `
    <div class="task-card ok" style="opacity: 0.8; min-height: 60px; background: linear-gradient(135deg, rgba(121, 221, 148, 0.1), rgba(90, 208, 255, 0.1));">
      <div class="icon">${item.emoji}</div>
      <div style="flex: 1;">
        <div style="font-weight: 600; margin-bottom: 4px;">
          ${item.app.company} - Application Complete!
        </div>
        <div style="font-size: 14px; color: var(--muted);">
          ${item.app.role} â¢ ${item.totalTime} min total
        </div>
        <div style="font-size: 12px; color: var(--ok); margin-top: 4px;">
          â Tailored (${item.tailoringTask.actualTime}m) â¢ â Submitted (${item.applicationTask.actualTime}m)
        </div>
      </div>
      <div style="font-size: 28px; color: var(--ok);">â</div>
    </div>
  `;
}

function renderTaskCard(task, isCompleted) {
  const urgency = getTaskUrgency(task);
  const icon = getTaskIcon(task.type);
  const detail = getTaskDetail(task);
  const accumulatedTime = state.taskProgress[task.id] || 0;
  
  if (isCompleted) {
    const celebrationEmojis = {
      application: ['ð', 'ð', 'ðª', 'â­'],
      networking: ['ð¤', 'ð', 'ð«', 'ð'],
      tailoring: ['âï¸', 'ð', 'â¨'],
      event: ['ð', 'ð¯', 'â­']
    };
    const emojis = celebrationEmojis[task.type] || ['â'];
    const emoji = emojis[Math.floor(Math.random() * emojis.length)];
    
    return `
      <div class="task-card ok" style="opacity: 0.7; min-height: 60px;">
        <div class="icon">${emoji}</div>
        <div style="flex: 1;">
          <div style="font-weight: 600; margin-bottom: 4px;">${detail.title}</div>
          <div style="font-size: 14px; color: var(--muted);">${detail.subtitle} â¢ ${task.actualTime || 0}m</div>
        </div>
        <div style="font-size: 24px; color: var(--ok);">â</div>
        <div class="item-actions" style="margin-left:8px;">
          <button class="icon-btn" onclick="event.stopPropagation(); editQueueItem('${task.id}')" title="Edit">âï¸</button>
          <button class="icon-btn" onclick="event.stopPropagation(); deleteQueueItem('${task.id}')" title="Delete">ðï¸</button>
        </div>
      </div>
    `;
  }
  
  return `
    <div class="task-card ${urgency}" onclick='enterFocus("${task.id}")'>
      <div class="icon">${icon}</div>
      <div style="flex: 1; min-width: 0;">
        <div style="font-weight: 600; margin-bottom: 4px;">${detail.title}</div>
        <div style="font-size: 14px; color: var(--muted);">${detail.subtitle}</div>
        ${task.deadline ? `<div style="font-size: 12px; color: var(--warn); margin-top: 4px;">â° ${formatDate(task.deadline)}</div>` : ''}
        ${accumulatedTime > 0 ? `<div style="font-size: 12px; color: var(--accent); margin-top: 4px;">â±ï¸ ${accumulatedTime} min in progress</div>` : ''}
      </div>
      <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px; margin-left: 8px;">
        <div style="font-size: 12px; color: var(--muted);">${task.estimatedTime}m</div>
        <div class="item-actions" style="display: flex; gap: 4px;">
          ${task.type === 'event' ? `<button class="icon-btn" onclick="event.stopPropagation(); downloadEventICal('${task.refId}')" title="Download iCal">ð</button>` : ''}
          <button class="icon-btn" onclick="event.stopPropagation(); editQueueItem('${task.id}')" title="Edit">âï¸</button>
          <button class="icon-btn" onclick="event.stopPropagation(); deleteQueueItem('${task.id}')" title="Delete">ðï¸</button>
        </div>
      </div>
    </div>
  `;
}

function updateTodayStats() {
  const today = getTodayISO();
  const todayTasks = state.dailyTasks[today] || [];
  
  const completedApps = todayTasks.filter(t => t.completed && t.type === 'application').length;
  const completedNet = todayTasks.filter(t => t.completed && t.type === 'networking').length;
  const addedApps = todayTasks.filter(t => t.type === 'application').length;
  const addedNet = todayTasks.filter(t => t.type === 'networking').length;
  
  const daysLeft = 7 - getDaysDifference(today, state.weekStart);
  const appsLeft = Math.max(0, state.targets.apps - state.completedThisWeek.apps);
  const netLeft = Math.max(0, state.targets.networking - state.completedThisWeek.networking);
  const dailyAppsQuota = Math.ceil(appsLeft / Math.max(1, daysLeft));
  const dailyNetQuota = Math.ceil(netLeft / Math.max(1, daysLeft));
  
  const appsCompleteEl = document.getElementById('todayAppsComplete');
  const appsTargetEl = document.getElementById('todayAppsTarget');
  if (appsCompleteEl && appsTargetEl) {
    appsCompleteEl.textContent = completedApps;
    appsTargetEl.textContent = dailyAppsQuota;
    
    // Color numerator based on completion
    if (completedApps === 0) {
      appsCompleteEl.style.color = 'var(--bad)';
    } else if (completedApps >= dailyAppsQuota) {
      appsCompleteEl.style.color = 'var(--ok)';
    } else {
      appsCompleteEl.style.color = 'var(--warn)';
    }
    
    // Color denominator based on tasks added to queue
    if (addedApps === 0) {
      appsTargetEl.style.color = 'var(--bad)';
    } else if (addedApps === 1) {
      appsTargetEl.style.color = '#ff8c42'; // Dark orange
    } else if (addedApps === 2) {
      appsTargetEl.style.color = 'var(--warn)'; // Orange
    } else if (addedApps === 3) {
      appsTargetEl.style.color = '#ffd700'; // Yellow
    } else if (addedApps >= dailyAppsQuota) {
      appsTargetEl.style.color = 'var(--ok)'; // Green
    } else {
      appsTargetEl.style.color = 'var(--muted)';
    }
  }
  
  const netCompleteEl = document.getElementById('todayNetComplete');
  const netTargetEl = document.getElementById('todayNetTarget');
  if (netCompleteEl && netTargetEl) {
    netCompleteEl.textContent = completedNet;
    netTargetEl.textContent = dailyNetQuota;
    
    // Color numerator based on completion
    if (completedNet === 0) {
      netCompleteEl.style.color = 'var(--bad)';
    } else if (completedNet >= dailyNetQuota) {
      netCompleteEl.style.color = 'var(--ok)';
    } else {
      netCompleteEl.style.color = 'var(--warn)';
    }
    
    // Color denominator based on tasks added to queue
    if (addedNet === 0) {
      netTargetEl.style.color = 'var(--bad)';
    } else if (addedNet === 1) {
      netTargetEl.style.color = '#ff8c42'; // Dark orange
    } else if (addedNet === 2) {
      netTargetEl.style.color = 'var(--warn)'; // Orange
    } else if (addedNet === 3) {
      netTargetEl.style.color = '#ffd700'; // Yellow
    } else if (addedNet >= dailyNetQuota) {
      netTargetEl.style.color = 'var(--ok)'; // Green
    } else {
      netTargetEl.style.color = 'var(--muted)';
    }
  }
  
  const todayTracking = state.dailyTimeTracking[today] || { optimization: 0, execution: 0 };
  const totalTime = todayTracking.optimization + todayTracking.execution;
  const timeEl = document.getElementById('todayTimeTotal');
  if (timeEl) {
    timeEl.textContent = totalTime > 0 ? `${totalTime}m` : '0m';
  }
  
  const streakEl = document.getElementById('todayStreak');
  if (streakEl) {
    streakEl.textContent = state.streaks.current || 0;
  }
}

function getTaskUrgency(task) {
  if (!task.deadline) return 'ok';
  const days = getDaysDifference(task.deadline, getTodayISO());
  if (days < 0) return 'urgent';
  if (days <= 2) return 'urgent';
  if (days <= 5) return 'soon';
  return 'ok';
}

function getTaskIcon(type) {
  const icons = {
    application: 'ð',
    networking: 'ð¤',
    tailoring: 'ð',
    event: 'ð'
  };
  return icons[type] || 'ð';
}

function getTaskDetail(task) {
  if (task.type === 'application') {
    const app = state.applications.find(a => a.id === task.refId);
    if (app) {
      let action = 'Apply to';
      if (app.status === 'tailoring') action = 'Tailor resume & cover letter for';
      if (app.status === 'ready') action = 'Submit application to';
      return { title: `${action} ${app.company}`, subtitle: app.role };
    }
  }
  
  if (task.type === 'networking') {
    const contact = state.contacts.find(c => c.id === task.refId);
    if (contact) {
      return { title: `Reach out to ${contact.name}`, subtitle: contact.relationship };
    }
  }
  
  if (task.type === 'tailoring') {
    const app = state.applications.find(a => a.id === task.refId);
    if (app) {
      return { title: `Tailor resume & cover letter for ${app.company}`, subtitle: app.role };
    }
    return { title: 'Tailor resume & cover letter', subtitle: 'General tailoring session' };
  }
  
  if (task.type === 'event') {
    const event = state.events.find(e => e.id === task.refId);
    if (event) {
      return { title: event.name, subtitle: event.type };
    }
  }
  
  return { title: 'Task', subtitle: '' };
}

// Focus mode
function enterFocus(taskId) {
  const today = getTodayISO();
  const task = state.dailyTasks[today].find(t => t.id === taskId);
  if (!task || task.completed) return;
  
  // Pause focus session timer if active
  pauseFocusSessionForTask();
  
  state.currentTask = task;
  
  if (!state.taskProgress[taskId]) {
    state.taskProgress[taskId] = 0;
  }
  
  state.focusStartTime = Date.now();
  saveToFirebase();
  
  const detail = getTaskDetail(task);
  const criteria = getCompletionCriteria(task);
  
  document.getElementById('focusTitle').textContent = detail.title;
  document.getElementById('focusDescription').textContent = detail.subtitle;
  document.getElementById('focusCriteria').textContent = criteria;
  document.getElementById('focusNotes').value = task.notes || '';
  
  // URL row for applications/tailoring
  const app = (task.type === 'application' || task.type === 'tailoring') && task.refId ? state.applications.find(a => a.id === task.refId) : null;
  const focusUrlRow = document.getElementById('focusUrlRow');
  const focusAppUrl = document.getElementById('focusAppUrl');
  if (app) {
    focusUrlRow.style.display = 'block';
    focusAppUrl.value = app.url || '';
  } else {
    focusUrlRow.style.display = 'none';
  }
  
  // Paired switch button visibility
  const pairBtn = document.getElementById('focusSwitchPairBtn');
  if ((task.type === 'application' || task.type === 'tailoring') && task.refId) {
    pairBtn.style.display = 'inline-block';
  } else {
    pairBtn.style.display = 'none';
  }
  
  if (isOptimizationTask(task)) {
    const today = getTodayISO();
    const todayTracking = state.dailyTimeTracking[today] || { optimization: 0, execution: 0 };
    const currentTaskTime = state.taskProgress[taskId] || 0;
    const totalOptTime = todayTracking.optimization + currentTaskTime;
    
    document.getElementById('optimizationProgress').style.display = 'block';
    document.getElementById('optProgressText').textContent = 
      `${totalOptTime}/${state.guardrails.maxOptimizationTime} min`;
    document.getElementById('optProgressBar').value = totalOptTime;
    document.getElementById('optProgressBar').max = state.guardrails.maxOptimizationTime;
  } else {
    document.getElementById('optimizationProgress').style.display = 'none';
  }
  
  document.getElementById('focusMode').style.display = 'flex';
  
  startFocusTimer();
}

function startFocusTimer() {
  updateTimer();
  state.focusInterval = setInterval(updateTimer, 1000);
  
  if (state.guardrails.enabled && !state.guardrailOverride) {
    checkGuardrailsInterval();
  }
}

function checkGuardrailsInterval() {
  state.guardrailCheckInterval = setInterval(() => {
    if (!state.currentTask || !state.focusStartTime) {
      clearInterval(state.guardrailCheckInterval);
      return;
    }
    
    const elapsed = Math.floor((Date.now() - state.focusStartTime) / 1000 / 60);
    const task = state.currentTask;
    
    if (elapsed === state.guardrails.warningThreshold) {
      showGuardrailWarning(
        'Time Check',
        `You've been working on this task for ${elapsed} minutes. Consider wrapping up soon to keep momentum.`
      );
    }
    
    if (task.type === 'tailoring' && elapsed >= state.guardrails.maxTailorTime) {
      showGuardrailWarning(
        'Time to Move On',
        `You've hit your ${state.guardrails.maxTailorTime}-minute limit for resume tailoring. Time to take action instead of optimizing!`
      );
      state.guardrailOverride = false;
    }
    
    const today = getTodayISO();
    const todayTracking = state.dailyTimeTracking[today] || { optimization: 0, execution: 0 };
    
    if (isOptimizationTask(task) && todayTracking.optimization >= state.guardrails.maxOptimizationTime) {
      showGuardrailWarning(
        'Daily Optimization Limit Reached',
        `You've spent ${state.guardrails.maxOptimizationTime} minutes on optimization today. Switch to execution mode (applications, networking).`
      );
      state.guardrailOverride = false;
    }
  }, 60000);
}

function isOptimizationTask(task) {
  return task.type === 'tailoring';
}

function showGuardrailWarning(title, message) {
  if (state.guardrailOverride) return;
  
  document.getElementById('guardrailTitle').textContent = title;
  document.getElementById('guardrailMessage').textContent = message;
  document.getElementById('guardrailWarning').classList.add('active');
  
  if (state.focusInterval) {
    clearInterval(state.focusInterval);
  }
}

function continueAnyway() {
  state.guardrailOverride = true;
  closeModal('guardrailWarning');
  
  if (state.focusStartTime) {
    startFocusTimer();
  }
}

function updateTimer() {
  if (!state.focusStartTime) return;
  
  const elapsed = Math.floor((Date.now() - state.focusStartTime) / 1000);
  const taskId = state.currentTask?.id;
  const previousTime = taskId ? (state.taskProgress[taskId] || 0) : 0;
  const totalSeconds = previousTime * 60 + elapsed;
  
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  
  document.getElementById('focusTimer').textContent = 
    `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
  
  if (state.currentTask && isOptimizationTask(state.currentTask)) {
    const today = getTodayISO();
    const todayTracking = state.dailyTimeTracking[today] || { optimization: 0, execution: 0 };
    const currentMinutes = Math.floor(elapsed / 60);
    const totalOptTime = todayTracking.optimization + previousTime + currentMinutes;
    
    document.getElementById('optProgressText').textContent = 
      `${totalOptTime}/${state.guardrails.maxOptimizationTime} min`;
    document.getElementById('optProgressBar').value = totalOptTime;
  }
}

function exitFocus() {
  saveTaskProgress();
  
  if (state.focusInterval) {
    clearInterval(state.focusInterval);
    state.focusInterval = null;
  }
  
  if (state.guardrailCheckInterval) {
    clearInterval(state.guardrailCheckInterval);
    state.guardrailCheckInterval = null;
  }
  
  state.currentTask = null;
  state.focusStartTime = null;
  state.guardrailOverride = false;
  saveToFirebase();
  
  // Resume focus session timer if it was paused
  resumeFocusSessionFromTask();
  
  document.getElementById('focusMode').style.display = 'none';
  renderTodayTasks();
}

function pauseTask() {
  saveTaskProgress();
  exitFocus();
}

function switchTask() {
  saveTaskProgress();
  exitFocus();
}

function saveTaskProgress() {
  if (!state.currentTask || !state.focusStartTime) return;
  
  const elapsed = Math.floor((Date.now() - state.focusStartTime) / 1000 / 60);
  const taskId = state.currentTask.id;
  
  if (!state.taskProgress[taskId]) {
    state.taskProgress[taskId] = 0;
  }
  
  state.taskProgress[taskId] += elapsed;
  saveToFirebase();
}

// Focus notes/url handlers
let focusNotesSaveTimer = null;
function debouncedSaveFocusNotes() {
  if (!state.currentTask) return;
  const taskId = state.currentTask.id;
  const today = getTodayISO();
  const task = state.dailyTasks[today].find(t => t.id === taskId);
  if (!task) return;
  task.notes = document.getElementById('focusNotes').value;
  if (focusNotesSaveTimer) clearTimeout(focusNotesSaveTimer);
  focusNotesSaveTimer = setTimeout(() => {
    saveToFirebase();
  }, 500);
}

function saveFocusUrl() {
  if (!state.currentTask) return;
  const task = state.currentTask;
  if (!(task.type === 'application' || task.type === 'tailoring') || !task.refId) return;
  const app = state.applications.find(a => a.id === task.refId);
  if (!app) return;
  let url = document.getElementById('focusAppUrl').value.trim();
  
  // Validate URL if provided
  if (url) {
    const validation = isValidUrl(url);
    if (!validation.isValid) {
      const newUrl = promptForValidUrl(url, app.company, app.role);
      if (newUrl === null) return; // User cancelled
      url = newUrl;
      // Update the input field with the corrected URL
      document.getElementById('focusAppUrl').value = url;
    }
  }
  
  app.url = url;
  saveToFirebase();
}

function openFocusUrl() {
  const url = document.getElementById('focusAppUrl').value.trim();
  if (url && isValidUrl(url).isValid) {
    window.open(url, '_blank');
  } else {
    alert('Please enter a valid URL first');
  }
}

function updateFocusSessionUI() {
  // Only update if currently in a focus session
  if (!state.currentTask || !state.focusStartTime) return;
  
  const detail = getTaskDetail(state.currentTask);
  const criteria = getCompletionCriteria(state.currentTask);
  
  // Update the focus session UI elements
  const focusTitle = document.getElementById('focusTitle');
  const focusDescription = document.getElementById('focusDescription');
  const focusCriteria = document.getElementById('focusCriteria');
  
  if (focusTitle) focusTitle.textContent = detail.title;
  if (focusDescription) focusDescription.textContent = detail.subtitle;
  if (focusCriteria) focusCriteria.textContent = criteria;
  
  // Update URL field if it's an application/tailoring task
  const app = (state.currentTask.type === 'application' || state.currentTask.type === 'tailoring') && state.currentTask.refId ? 
              state.applications.find(a => a.id === state.currentTask.refId) : null;
  const focusAppUrl = document.getElementById('focusAppUrl');
  if (app && focusAppUrl) {
    focusAppUrl.value = app.url || '';
  }
}

function switchFocusPair() {
  if (!state.currentTask || !state.currentTask.refId) return;
  const pairType = state.currentTask.type === 'application' ? 'tailoring' : 'application';
  const today = getTodayISO();
  const todayTasks = state.dailyTasks[today] || [];
  const pair = todayTasks.find(t => t.refId === state.currentTask.refId && t.type === pairType && !t.completed);
  if (pair) {
    pauseTask();
    enterFocus(pair.id);
  } else {
    // Create paired task if missing
    const newTask = { id: generateId(), type: pairType, refId: state.currentTask.refId, completed: false, estimatedTime: pairType === 'tailoring' ? 40 : 20, notes: '' };
    state.dailyTasks[today].push(newTask);
    saveToFirebase();
    pauseTask();
    enterFocus(newTask.id);
  }
}

function completeTask() {
  if (!state.currentTask) return;
  
  try {
    const today = getTodayISO();
    if (!state.dailyTasks[today]) {
      console.error('No tasks for today');
      return;
    }
    
    const task = state.dailyTasks[today].find(t => t.id === state.currentTask.id);
    
    if (!task) {
      console.error('Task not found');
      return;
    }
    
    task.completed = true;
    task.completedAt = new Date().toISOString();
    
    const elapsed = Math.floor((Date.now() - state.focusStartTime) / 1000 / 60);
    const taskId = task.id;
    const previousTime = state.taskProgress[taskId] || 0;
    const totalTime = previousTime + elapsed;
    
    task.actualTime = totalTime;
    
    if (!state.dailyTimeTracking[today]) {
      state.dailyTimeTracking[today] = { optimization: 0, execution: 0 };
    }
    
    if (isOptimizationTask(task)) {
      state.dailyTimeTracking[today].optimization += totalTime;
    } else {
      state.dailyTimeTracking[today].execution += totalTime;
    }
    
    if (state.taskProgress[taskId]) {
      delete state.taskProgress[taskId];
    }
    
    if (task.type === 'application') {
      state.completedThisWeek.apps++;
      
      const app = state.applications.find(a => a.id === task.refId);
      if (app) {
        if (app.status === 'queued') app.status = 'tailoring';
        else if (app.status === 'tailoring' || app.status === 'ready') {
          app.status = 'sent';
          app.dateSent = today;
        }
      }
      // Auto-complete paired tailoring task if present
      const pair = state.dailyTasks[today].find(t => t.refId === task.refId && t.type === 'tailoring' && !t.completed);
      if (pair) {
        pair.completed = true;
        pair.completedAt = new Date().toISOString();
        pair.actualTime = pair.actualTime || 0;
      }
    } else if (task.type === 'networking') {
      state.completedThisWeek.networking++;
      
      const contact = state.contacts.find(c => c.id === task.refId);
      if (contact) {
        contact.lastContact = today;
        contact.status = 'contacted';
      }
    } else if (task.type === 'event') {
      state.completedThisWeek.events++;
      
      const event = state.events.find(e => e.id === task.refId);
      if (event) event.attended = true;
    }
    
    updateStreaks();
    checkMilestones();
    
    saveToFirebase();
    
    exitFocus();
    
    setTimeout(() => {
      showCelebration(task);
    }, 100);
    
  } catch (err) {
    console.error('Error completing task:', err);
    alert('Error completing task. Your progress has been saved.');
    exitFocus();
  }
}

function getCompletionCriteria(task) {
  if (task.type === 'application') {
    const app = state.applications.find(a => a.id === task.refId);
    if (app) {
      if (app.status === 'queued') return 'Open the job posting, read through requirements, save any questions or notes';
      if (app.status === 'tailoring') return 'Update resume & cover letter to match job description, highlight relevant experience, save tailored versions';
      if (app.status === 'ready') return 'Submit application through their system, attach tailored resume, note confirmation number';
    }
  }
  
  if (task.type === 'networking') {
    return 'Draft and send your message, personalize based on your relationship, set follow-up reminder if needed';
  }
  
  if (task.type === 'tailoring') {
    return 'Match keywords from target job descriptions, lead with relevant achievements, quantify impact where possible, keep resume concise and scannable, customize cover letter for each role';
  }
  
  if (task.type === 'event') {
    return 'Attend the event, take notes on key connections, follow up with contacts made';
  }
  
  return 'Complete the task as planned';
}

function updateStreaks() {
  const today = getTodayISO();
  const yesterday = addDays(today, -1);
  
  if (state.streaks.lastActiveDate === yesterday) {
    state.streaks.current++;
  } else if (state.streaks.lastActiveDate !== today) {
    state.streaks.current = 1;
  }
  
  state.streaks.lastActiveDate = today;
  
  if (state.streaks.current > state.streaks.longest) {
    state.streaks.longest = state.streaks.current;
  }
  
  saveToFirebase();
}

function checkMilestones() {
  const milestones = [
    { id: 'first_app', condition: state.completedThisWeek.apps >= 1 },
    { id: 'five_apps', condition: state.completedThisWeek.apps >= 5 },
    { id: 'ten_apps', condition: state.completedThisWeek.apps >= 10 },
    { id: 'week_complete', condition: state.completedThisWeek.apps >= state.targets.apps },
    { id: 'streak_3', condition: state.streaks.current >= 3 },
    { id: 'streak_7', condition: state.streaks.current >= 7 }
  ];
  
  milestones.forEach(milestone => {
    if (milestone.condition && !state.milestones.includes(milestone.id)) {
      state.milestones.push(milestone.id);
    }
  });
}

function showCelebration(task) {
  createConfetti();
  
  let emoji = 'ð';
  let title = 'Great work!';
  let message = 'Task completed successfully!';
  
  if (task.type === 'application') {
    emoji = 'ð¼';
    title = 'Application sent!';
    message = 'One step closer to your next role!';
  } else if (task.type === 'networking') {
    emoji = 'ð¤';
    title = 'Connection made!';
    message = 'Your network is growing!';
  } else if (task.type === 'tailoring') {
    emoji = 'â¨';
    title = 'Resume & cover letter polished!';
    message = 'Now go apply!';
  }
  
  document.getElementById('celebrationEmoji').textContent = emoji;
  document.getElementById('celebrationTitle').textContent = title;
  document.getElementById('celebrationMessage').textContent = message;
  document.getElementById('celebrationOverlay').classList.add('active');
  
  setTimeout(() => {
    closeCelebration();
  }, 2000);
}

function createConfetti() {
  const colors = ['#5ad0ff', '#79dd94', '#ffbe5a', '#ff6b6b'];
  for (let i = 0; i < 30; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti-piece';
    confetti.style.left = Math.random() * 100 + '%';
    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
    confetti.style.animationDelay = Math.random() * 0.5 + 's';
    document.body.appendChild(confetti);
    
    setTimeout(() => confetti.remove(), 3000);
  }
}

function closeCelebration() {
  document.getElementById('celebrationOverlay').classList.remove('active');
  startBreathingBreak();
}

function startBreathingBreak() {
  const today = getTodayISO();
  const remaining = (state.dailyTasks[today] || []).filter(t => !t.completed);
  
  if (remaining.length === 0) {
    alert('All done for today! Great work!');
    return;
  }
  
  document.getElementById('breathingBreak').classList.add('active');
  
  const phases = [
    { text: 'Breathe in...', duration: 4000 },
    { text: 'Hold...', duration: 7000 },
    { text: 'Breathe out...', duration: 8000 }
  ];
  
  let phaseIndex = 0;
  
  function nextPhase() {
    if (phaseIndex >= phases.length) {
      skipBreathing();
      return;
    }
    
    const breathingText = document.getElementById('breathingText');
    if (breathingText) {
      breathingText.textContent = phases[phaseIndex].text;
    }
    
    state.breathingTimeout = setTimeout(() => {
      phaseIndex++;
      nextPhase();
    }, phases[phaseIndex].duration);
    
    phaseIndex++;
  }
  
  nextPhase();
}

function skipBreathing() {
  if (state.breathingTimeout) {
    clearTimeout(state.breathingTimeout);
  }
  document.getElementById('breathingBreak').classList.remove('active');
  showNextTaskOptions();
}

function showNextTaskOptions() {
  const today = getTodayISO();
  const remaining = (state.dailyTasks[today] || []).filter(t => !t.completed);
  
  if (remaining.length === 0) {
    alert('All done for today! Great work!');
    return;
  }
  
  const recommended = getRecommendedTask(remaining);
  if (recommended) {
    const detail = getTaskDetail(recommended);
    document.getElementById('recommendedTaskText').textContent = detail.title;
  }
  
  document.getElementById('nextTaskModal').classList.add('active');
}

function getRecommendedTask(tasks) {
  const urgent = tasks.filter(t => getTaskUrgency(t) === 'urgent');
  if (urgent.length > 0) return urgent[0];
  
  const soon = tasks.filter(t => getTaskUrgency(t) === 'soon');
  if (soon.length > 0) return soon[0];
  
  const lastType = state.currentTask?.type;
  const different = tasks.filter(t => t.type !== lastType);
  if (different.length > 0) return different[0];
  
  return tasks[0];
}

function nextTaskRecommended() {
  document.getElementById('nextTaskModal').classList.remove('active');
  const today = getTodayISO();
  const remaining = state.dailyTasks[today].filter(t => !t.completed);
  const recommended = getRecommendedTask(remaining);
  if (recommended) enterFocus(recommended.id);
}

function nextTaskRandom() {
  document.getElementById('nextTaskModal').classList.remove('active');
  const today = getTodayISO();
  const remaining = state.dailyTasks[today].filter(t => !t.completed);
  const random = remaining[Math.floor(Math.random() * remaining.length)];
  if (random) enterFocus(random.id);
}

function nextTaskManual() {
  document.getElementById('nextTaskModal').classList.remove('active');
  renderTodayTasks();
}

// Plan screen
function renderPlanScreen() {
  document.getElementById('planAppsProgress').textContent = state.completedThisWeek.apps;
  document.getElementById('planAppsTarget').textContent = state.targets.apps;
  document.getElementById('planAppsBar').value = state.completedThisWeek.apps;
  document.getElementById('planAppsBar').max = state.targets.apps;
  
  document.getElementById('planNetProgress').textContent = state.completedThisWeek.networking;
  document.getElementById('planNetTarget').textContent = state.targets.networking;
  document.getElementById('planNetBar').value = state.completedThisWeek.networking;
  document.getElementById('planNetBar').max = state.targets.networking;
  
  document.getElementById('planEventsProgress').textContent = state.completedThisWeek.events;
  document.getElementById('planEventsTarget').textContent = state.targets.events;
  
  const appsList = document.getElementById('appsList');
  const pipelineApps = state.applications.filter(app => app.status !== 'queued');
  
  if (pipelineApps.length === 0) {
    appsList.innerHTML = '<div class="empty-state"><div class="empty-state-emoji">ð¼</div><p>No applications in pipeline yet</p><p style="font-size: 14px;">Add jobs from the Job Queue</p></div>';
  } else {
    appsList.innerHTML = pipelineApps.map(app => `
      <div class="list-item">
        <div style="flex: 1;">
          <div class="list-item-title">
            ${app.company} - ${app.role}
            <span class="badge ${app.status}">${app.status}</span>
          </div>
          <div class="list-item-meta">
            ${app.deadline ? `Deadline: ${formatDate(app.deadline)}` : 'No deadline'}
            ${app.url ? ` â¢ <a href="#" onclick="openJobUrl('${app.id}'); return false;" style="color: var(--accent);">View posting</a>` : ''}
          </div>
          ${app.notes ? `<div style="margin-top: 8px; font-size: 14px;">${app.notes}</div>` : ''}
        </div>
        <div class="item-actions">
          <button class="icon-btn" onclick="deleteApp('${app.id}')" title="Delete">ðï¸</button>
          <button class="icon-btn" onclick="editApplication('${app.id}')" title="Edit">âï¸</button>
        </div>
      </div>
    `).join('');
  }
  
  const contactsList = document.getElementById('contactsList');
  if (state.contacts.length === 0) {
    contactsList.innerHTML = '<div class="empty-state"><div class="empty-state-emoji">ð¤</div><p>No contacts yet</p></div>';
  } else {
    contactsList.innerHTML = state.contacts.map(contact => `
      <div class="list-item">
        <div style="flex: 1;">
          <div class="list-item-title">
            ${contact.name}
            ${contact.status ? `<span class="badge ${contact.status}">${contact.status}</span>` : ''}
          </div>
          <div class="list-item-meta">
            ${contact.relationship}${contact.company ? ` â¢ ${contact.company}` : ''}
            ${contact.lastContact ? ` â¢ Last contact: ${formatDate(contact.lastContact)}` : ''}
          </div>
          ${contact.notes ? `<div style="margin-top: 8px; font-size: 14px;">${contact.notes}</div>` : ''}
        </div>
        <div class="item-actions">
          <button class="icon-btn" onclick="deleteContact('${contact.id}')" title="Delete">ðï¸</button>
          <button class="icon-btn" onclick="editContact('${contact.id}')" title="Edit">âï¸</button>
        </div>
      </div>
    `).join('');
  }
  
  const eventsList = document.getElementById('eventsList');
  if (state.events.length === 0) {
    eventsList.innerHTML = '<div class="empty-state"><div class="empty-state-emoji">ð</div><p>No events scheduled</p></div>';
  } else {
    eventsList.innerHTML = state.events.map(event => `
      <div class="list-item">
        <div style="flex: 1;">
          <div class="list-item-title">
            ${event.name}
            ${event.attended ? '<span class="badge ready">attended</span>' : ''}
          </div>
          <div class="list-item-meta">
            ${formatDate(event.date)} â¢ ${event.duration} min â¢ ${event.type}
          </div>
          ${event.notes ? `<div style="margin-top: 8px; font-size: 14px;">${event.notes}</div>` : ''}
          ${event.link ? `<div style="margin-top: 6px; font-size: 12px;"><a href="${event.link}" target="_blank" style="color: var(--accent);">ð Open Link</a></div>` : ''}
          ${event.calendarUrl ? `<div style="margin-top: 6px; font-size: 12px;"><a href="${event.calendarUrl}" target="_blank" style="color: var(--accent);">ð Open calendar</a></div>` : ''}
        </div>
        <div class="item-actions">
          <button class="icon-btn" onclick="downloadEventICal('${event.id}')" title="Download iCal">ð</button>
          <button class="icon-btn" onclick="deleteEvent('${event.id}')" title="Delete">ðï¸</button>
          <button class="icon-btn" onclick="editEvent('${event.id}')" title="Edit">âï¸</button>
        </div>
      </div>
    `).join('');
  }
}

function deleteApp(appId) {
  if (!confirm('Delete this application? This will also remove related tasks.')) return;
  
  state.applications = state.applications.filter(a => a.id !== appId);
  
  Object.keys(state.dailyTasks).forEach(day => {
    state.dailyTasks[day] = state.dailyTasks[day].filter(t => t.refId !== appId);
  });
  
  saveToFirebase();
  renderPlanScreen();
  renderTodayTasks();
}

function deleteContact(contactId) {
  if (!confirm('Delete this contact? This will also remove related tasks.')) return;
  
  state.contacts = state.contacts.filter(c => c.id !== contactId);
  
  Object.keys(state.dailyTasks).forEach(day => {
    state.dailyTasks[day] = state.dailyTasks[day].filter(t => t.refId !== contactId);
  });
  
  saveToFirebase();
  renderPlanScreen();
  renderTodayTasks();
}

function deleteEvent(eventId) {
  if (!confirm('Delete this event? This will also remove related tasks.')) return;
  
  state.events = state.events.filter(e => e.id !== eventId);
  
  Object.keys(state.dailyTasks).forEach(day => {
    state.dailyTasks[day] = state.dailyTasks[day].filter(t => t.refId !== eventId);
  });
  
  saveToFirebase();
  renderPlanScreen();
  renderTodayTasks();
}

// Progress screen
function renderProgress() {
  const today = getTodayISO();
  const dayOfWeek = getDaysDifference(today, state.weekStart);
  
  // Aggregate weekly time
  let weekOptTime = 0;
  let weekExecTime = 0;
  for (let i = 0; i < 7; i++) {
    const day = addDays(state.weekStart, i);
    const tracking = state.dailyTimeTracking[day] || { optimization: 0, execution: 0 };
    weekOptTime += tracking.optimization;
    weekExecTime += tracking.execution;
  }
  
  // Any event scheduled this week?
  let anyEventThisWeek = false;
  for (let i = 0; i < 7; i++) {
    const day = addDays(state.weekStart, i);
    if ((state.events || []).some(e => e.date === day)) { anyEventThisWeek = true; break; }
  }
  
  // Build condensed dashboard
  const dash = `
    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 12px; margin-bottom: 20px;">
      <div style="background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 16px;">
        <div style="display:flex; justify-content: space-between; align-items:center;">
          <div style="color: var(--muted);">Week</div>
          <div style="font-weight:600;">Day ${dayOfWeek + 1} of 7</div>
        </div>
        <div style="display:flex; gap:8px; margin-top:8px;" id="progressWeekDots"></div>
      </div>
      <div style="background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 16px; text-align:center;">
        <div style="font-size: 32px;">ð¥</div>
        <div style="font-size: 28px; font-weight: 700;" id="progressStreakCount">${state.streaks.current || 0}</div>
        <div style="font-size: 12px; color: var(--muted);">day streak (best ${state.streaks.longest || 0})</div>
      </div>
      <div style="background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 16px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <span>Applications</span>
          <span id="progressAppsStatus">${state.completedThisWeek.apps}/${state.targets.apps}</span>
        </div>
        <progress id="progressAppsBar" value="${state.completedThisWeek.apps}" max="${state.targets.apps}" style="width:100%"></progress>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px;">
          <span>Networking</span>
          <span id="progressNetStatus">${state.completedThisWeek.networking}/${state.targets.networking}</span>
        </div>
        <progress id="progressNetBar" value="${state.completedThisWeek.networking}" max="${state.targets.networking}" style="width:100%"></progress>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px;">
          <span>Events</span>
          <span id="progressEventsStatus">${state.completedThisWeek.events}/${state.targets.events}</span>
        </div>
        <progress id="progressEventsBar" value="${state.completedThisWeek.events}" max="${state.targets.events}" style="width:100%"></progress>
      </div>
      <div style="background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 16px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <span>Optimization</span>
          <span id="progressWeekOptTime">${weekOptTime} min</span>
        </div>
        <div style="font-size: 12px; color: var(--muted);">Resume tweaking, strategy</div>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-top:12px;">
          <span>Execution</span>
          <span id="progressWeekExecTime">${weekExecTime} min</span>
        </div>
        <div style="font-size: 12px; color: var(--muted);">Applications, networking, events</div>
      </div>
    </div>
  `;
  const dashRoot = document.getElementById('progressDashboard');
  if (dashRoot) dashRoot.innerHTML = dash;
  
  // Week dots
  const dotsHtml = Array.from({length: 7}, (_, i) => {
    const isPast = i < dayOfWeek;
    const isToday = i === dayOfWeek;
    const color = isPast ? 'var(--ok)' : isToday ? 'var(--accent)' : 'var(--line)';
    return `<div style=\"flex: 1; height: 8px; background: ${color}; border-radius: 4px;\"></div>`;
  }).join('');
  const dotsEl = document.getElementById('progressWeekDots');
  if (dotsEl) dotsEl.innerHTML = dotsHtml;
  
  // Events denominator color
  const eventsStatusEl = document.getElementById('progressEventsStatus');
  if (eventsStatusEl) {
    const parts = eventsStatusEl.textContent.split('/');
    const numerator = parts[0];
    const denom = parts[1];
    eventsStatusEl.innerHTML = `${numerator}/<span style=\"color:${anyEventThisWeek ? 'var(--ok)' : 'var(--bad)'}\">${denom}</span>`;
  }
  
  // History list - only show finished applications (sent, interview, offer, rejected)
  const historyEl = document.getElementById('applicationHistory');
  if (historyEl) {
    const finishedStatuses = ['sent', 'interview', 'offer', 'rejected'];
    const finishedApps = state.applications.filter(app => finishedStatuses.includes(app.status));
    
    if (finishedApps.length === 0) {
      historyEl.innerHTML = '<p style=\"color: var(--muted); text-align: center;\">No finished applications yet</p>';
    } else {
      historyEl.innerHTML = finishedApps.map(app => {
        let totalTime = 0;
        Object.values(state.dailyTasks).forEach(dayTasks => {
          dayTasks.forEach(t => {
            if (t.refId === app.id && t.completed) {
              totalTime += t.actualTime || 0;
            }
          });
        });
        
        const statusEmoji = {
          'sent': 'ð¤',
          'interview': 'ð¯',
          'offer': 'ð',
          'rejected': 'â'
        }[app.status] || 'ð';
        
        return `
          <div class=\"list-item\">
            <div>
              <div style=\"font-weight: 600; margin-bottom: 4px;\">${statusEmoji} ${app.company} - ${app.role}</div>
              <div style=\"font-size: 14px; color: var(--muted);\">${totalTime > 0 ? `${totalTime} min invested` : 'Not started'} â¢ ${app.status}</div>
            </div>
          </div>
        `;
      }).join('');
    }
  }
  
  // Render Analytics section
  renderAnalytics();
}

function renderAnalytics() {
  const today = getTodayISO();
  const currentDay = state.timeBlocking?.currentDay;
  
  // Daily Focus Summary
  renderDailyFocusSummary(currentDay, today);
  
  // Weekly Overview
  renderWeeklyOverview(today);
  
  // Badges
  renderBadges();
  
  // Insights
  renderInsights(currentDay, today);
}

function renderDailyFocusSummary(currentDay, today) {
  const card = document.getElementById('dailyFocusCard');
  if (!card) return;
  
  if (!currentDay || currentDay.date !== today) {
    card.innerHTML = `
      <div style="color: var(--muted); font-size: 14px; margin-bottom: 8px;">No focus session today</div>
      <div style="font-size: 12px; color: var(--muted);">Start a focus session to see your analytics</div>
    `;
    return;
  }
  
  const { goalBlocks, completedBlocks, startTime, activeChunk } = currentDay;
  const onTaskTime = activeChunk?.onTaskTime || 0;
  const offTaskTime = activeChunk?.offTaskTime || 0;
  const totalTime = onTaskTime + offTaskTime;
  const onTaskPct = totalTime > 0 ? Math.round((onTaskTime / totalTime) * 100) : 0;
  
  card.innerHTML = `
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 16px; margin-bottom: 16px;">
      <div style="text-align: center;">
        <div class="mono" style="font-size: 24px; font-weight: 600; color: var(--accent);">${completedBlocks}</div>
        <div style="font-size: 12px; color: var(--muted);">Blocks</div>
        <div style="font-size: 10px; color: var(--muted);">of ${goalBlocks}</div>
      </div>
      <div style="text-align: center;">
        <div class="mono" style="font-size: 24px; font-weight: 600; color: var(--ok);">${onTaskPct}%</div>
        <div style="font-size: 12px; color: var(--muted);">On-task</div>
        <div class="mono" style="font-size: 10px; color: var(--muted);">${Math.floor(onTaskTime/60)}h ${onTaskTime%60}m</div>
      </div>
      <div style="text-align: center;">
        <div class="mono" style="font-size: 24px; font-weight: 600; color: var(--warn);">${Math.floor(offTaskTime/60)}h ${offTaskTime%60}m</div>
        <div style="font-size: 12px; color: var(--muted);">Off-task</div>
        <div style="font-size: 10px; color: var(--muted);">Started ${startTime}</div>
      </div>
    </div>
    <div style="display: flex; gap: 4px; justify-content: center; flex-wrap: wrap;">
      ${Array.from({length: goalBlocks}, (_, i) => 
        `<div class="focus-block" style="width: 16px; height: 16px; ${i < completedBlocks ? 'background: var(--ok); border-color: var(--ok);' : ''}"></div>`
      ).join('')}
    </div>
  `;
}

function renderWeeklyOverview(today) {
  const grid = document.getElementById('weeklyFocusGrid');
  const totalBlocks = document.getElementById('weeklyTotalBlocks');
  const onTaskPct = document.getElementById('weeklyOnTaskPct');
  const streak = document.getElementById('weeklyStreak');
  
  if (!grid) return;
  
  // Calculate week data
  let weekTotalBlocks = 0;
  let weekOnTaskTime = 0;
  let weekTotalTime = 0;
  let currentStreak = 0;
  
  const weekDays = [];
  for (let i = 0; i < 7; i++) {
    const day = addDays(state.weekStart, i);
    const dayData = state.timeBlocking?.history?.[day] || {};
    const blocks = dayData.completedBlocks || 0;
    const onTask = dayData.totalOnTaskTime || 0;
    const total = dayData.totalTime || 0;
    
    weekTotalBlocks += blocks;
    weekOnTaskTime += onTask;
    weekTotalTime += total;
    
    if (blocks > 0) {
      currentStreak++;
    } else if (day <= today) {
      currentStreak = 0;
    }
    
    weekDays.push({
      date: day,
      blocks,
      onTask,
      total,
      isToday: day === today
    });
  }
  
  // Render week grid
  grid.innerHTML = weekDays.map((day, i) => {
    const dayName = ['S', 'M', 'T', 'W', 'T', 'F', 'S'][i];
    const isPast = day.date < today;
    const isToday = day.isToday;
    const hasBlocks = day.blocks > 0;
    
    let bgColor = 'rgba(0,0,0,0.1)';
    if (hasBlocks) bgColor = 'var(--ok)';
    else if (isPast) bgColor = 'var(--bad)';
    else if (isToday) bgColor = 'var(--accent)';
    
    return `
      <div style="text-align: center; padding: 6px 4px; background: ${bgColor}; border-radius: 6px; opacity: ${isPast && !hasBlocks ? 0.5 : 1}; min-width: 0;">
        <div style="font-size: 11px; font-weight: 600; margin-bottom: 2px;">${dayName}</div>
        <div style="font-size: 14px; font-weight: 700;">${day.blocks}</div>
        <div style="font-size: 9px; color: var(--muted);">blocks</div>
      </div>
    `;
  }).join('');
  
  // Update stats
  if (totalBlocks) totalBlocks.textContent = weekTotalBlocks;
  if (onTaskPct) onTaskPct.textContent = weekTotalTime > 0 ? Math.round((weekOnTaskTime / weekTotalTime) * 100) + '%' : '0%';
  if (streak) streak.textContent = currentStreak;
}

function renderInsights(currentDay, today) {
  const title = document.getElementById('insightTitle');
  const subtitle = document.getElementById('insightSubtitle');
  const text = document.getElementById('insightText');
  
  if (!title || !subtitle || !text) return;
  
  if (!currentDay || currentDay.date !== today) {
    title.textContent = 'Ready to Focus';
    subtitle.textContent = 'Start your first focus session to unlock insights';
    text.textContent = 'Your focus analytics will appear here once you start tracking your work sessions.';
    return;
  }
  
  const { goalBlocks, completedBlocks, activeChunk } = currentDay;
  const onTaskTime = activeChunk?.onTaskTime || 0;
  const offTaskTime = activeChunk?.offTaskTime || 0;
  const totalTime = onTaskTime + offTaskTime;
  const onTaskPct = totalTime > 0 ? Math.round((onTaskTime / totalTime) * 100) : 0;
  
  // Generate insights based on current progress
  let insight = '';
  let emoji = 'ð¯';
  
  if (completedBlocks === 0) {
    insight = 'Ready to start your focus journey! Set a goal and begin your first chunk.';
    emoji = 'ð';
  } else if (completedBlocks < goalBlocks / 2) {
    insight = `Great start! You've completed ${completedBlocks} of ${goalBlocks} blocks. Keep the momentum going!`;
    emoji = 'ðª';
  } else if (completedBlocks < goalBlocks) {
    insight = `You're ${Math.round((completedBlocks / goalBlocks) * 100)}% to your goal! ${goalBlocks - completedBlocks} more blocks to go.`;
    emoji = 'ð¥';
  } else {
    insight = `Amazing! You've crushed your daily goal of ${goalBlocks} blocks! ð`;
    emoji = 'ð';
  }
  
  if (onTaskPct >= 90) {
    insight += ' Your focus is laser-sharp today!';
  } else if (onTaskPct < 70 && totalTime > 30) {
    insight += ' Try to minimize distractions to boost your on-task percentage.';
  }
  
  title.textContent = insight.split('!')[0] + '!';
  subtitle.textContent = `${completedBlocks}/${goalBlocks} blocks â¢ ${onTaskPct}% on-task`;
  text.textContent = insight;
  
  // Update emoji
  const emojiEl = document.querySelector('#insightsCard .font-size-24px');
  if (emojiEl) emojiEl.textContent = emoji;
}

function renderBadges() {
  const badgesGrid = document.getElementById('badgesGrid');
  const currentStreak = document.getElementById('currentStreak');
  const longestStreak = document.getElementById('longestStreak');
  const totalBadges = document.getElementById('totalBadges');
  
  if (!badgesGrid) return;
  
  const achievements = state.timeBlocking?.achievements;
  const earnedBadges = achievements?.badges || [];
  const streaks = achievements?.streaks || {};
  
  // Render earned badges
  if (earnedBadges.length === 0) {
    badgesGrid.innerHTML = `
      <div style="grid-column: 1 / -1; text-align: center; padding: 20px; color: var(--muted);">
        <div style="font-size: 32px; margin-bottom: 8px;">ð</div>
        <div>No badges yet</div>
        <div style="font-size: 12px; margin-top: 4px;">Start focusing to earn achievements!</div>
      </div>
    `;
  } else {
    badgesGrid.innerHTML = earnedBadges.map(badge => `
      <div style="text-align: center; padding: 12px; background: rgba(0,0,0,0.1); border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);">
        <div style="font-size: 24px; margin-bottom: 4px;">${badge.icon}</div>
        <div style="font-size: 11px; font-weight: 600; color: var(--text); margin-bottom: 2px;">${badge.name}</div>
        <div style="font-size: 9px; color: var(--muted);">${badge.description}</div>
      </div>
    `).join('');
  }
  
  // Update streak stats
  if (currentStreak) currentStreak.textContent = streaks.currentWorkStreak || 0;
  if (longestStreak) longestStreak.textContent = streaks.longestWork || 0;
  if (totalBadges) totalBadges.textContent = earnedBadges.length;
}

function saveDailyDataToHistory() {
  if (!state.timeBlocking?.currentDay) return;
  
  const currentDay = state.timeBlocking.currentDay;
  const today = getTodayISO();
  
  // Calculate total times from all chunks
  let totalOnTaskTime = 0;
  let totalOffTaskTime = 0;
  let totalTime = 0;
  
  // Add active chunk times
  if (currentDay.activeChunk) {
    totalOnTaskTime += currentDay.activeChunk.onTaskTime || 0;
    totalOffTaskTime += currentDay.activeChunk.offTaskTime || 0;
  }
  
  // Add completed chunks times
  currentDay.chunks.forEach(chunk => {
    totalOnTaskTime += chunk.onTaskTime || 0;
    totalOffTaskTime += chunk.offTaskTime || 0;
  });
  
  totalTime = totalOnTaskTime + totalOffTaskTime;
  
  // Save to history
  if (!state.timeBlocking.history) {
    state.timeBlocking.history = {};
  }
  
  state.timeBlocking.history[today] = {
    date: today,
    goalBlocks: currentDay.goalBlocks,
    completedBlocks: currentDay.completedBlocks,
    startTime: currentDay.startTime,
    endTime: new Date().toLocaleTimeString('en-US', { 
      hour: 'numeric', 
      minute: '2-digit',
      hour12: true,
      timeZone: 'America/Los_Angeles'
    }),
    totalOnTaskTime,
    totalOffTaskTime,
    totalTime,
    chunks: currentDay.chunks,
    sessions: currentDay.sessions || []
  };
  
  saveToFirebase();
}

function startNewDay() {
  const today = getTodayISO();
  
  // Save previous day to history if it exists
  if (state.timeBlocking?.currentDay && state.timeBlocking.currentDay.date !== today) {
    saveDailyDataToHistory();
  }
  
  // Initialize new day
  const goalBlocks = parseInt(document.getElementById('focusGoalInput').value) || 12;
  const now = new Date();
  const startTime = now.toLocaleTimeString('en-US', { 
    hour: 'numeric', 
    minute: '2-digit',
    hour12: true,
    timeZone: 'America/Los_Angeles'
  });
  
  state.timeBlocking = {
    ...state.timeBlocking,
    currentDay: {
      date: today,
      startTime,
      endTime: null,
      goalBlocks,
      completedBlocks: 0,
      activeChunk: null,
      chunks: [],
      currentMode: 'on-task',
      modeStartTime: now.toISOString(),
      sessions: []
    },
    history: state.timeBlocking?.history || {}
  };
  
  saveToFirebase();
  renderFocusPanel();
}

// Gamification System
const BADGES = {
  // Week badges
  BRONZE_WEEK: { id: 'bronze_week', name: 'Bronze Week', description: 'Complete 10+ blocks in a week', icon: 'ð¥', requirement: 10, type: 'week' },
  SILVER_WEEK: { id: 'silver_week', name: 'Silver Week', description: 'Complete 20+ blocks in a week', icon: 'ð¥', requirement: 20, type: 'week' },
  GOLD_WEEK: { id: 'gold_week', name: 'Gold Week', description: 'Complete 30+ blocks in a week', icon: 'ð¥', requirement: 30, type: 'week' },
  
  // Streak badges
  THREE_DAY_STREAK: { id: 'three_day_streak', name: 'Getting Started', description: '3-day work streak', icon: 'ð¥', requirement: 3, type: 'streak' },
  SEVEN_DAY_STREAK: { id: 'seven_day_streak', name: 'Week Warrior', description: '7-day work streak', icon: 'â¡', requirement: 7, type: 'streak' },
  THIRTY_DAY_STREAK: { id: 'thirty_day_streak', name: 'Month Master', description: '30-day work streak', icon: 'ð', requirement: 30, type: 'streak' },
  
  // Focus badges
  FOCUSED_MIND: { id: 'focused_mind', name: 'Focused Mind', description: '95%+ on-task for a day', icon: 'ð¯', requirement: 95, type: 'focus' },
  LASER_FOCUS: { id: 'laser_focus', name: 'Laser Focus', description: '98%+ on-task for a day', icon: 'â¡', requirement: 98, type: 'focus' },
  PERFECT_DAY: { id: 'perfect_day', name: 'Perfect Day', description: 'Complete daily goal', icon: 'â¨', requirement: 100, type: 'goal' },
  
  // Milestone badges
  FIRST_SESSION: { id: 'first_session', name: 'First Steps', description: 'Complete your first focus session', icon: 'ð¶', requirement: 1, type: 'milestone' },
  HUNDRED_BLOCKS: { id: 'hundred_blocks', name: 'Centurion', description: 'Complete 100 total blocks', icon: 'ð¯', requirement: 100, type: 'milestone' },
  FIVE_HUNDRED_BLOCKS: { id: 'five_hundred_blocks', name: 'Block Master', description: 'Complete 500 total blocks', icon: 'ð', requirement: 500, type: 'milestone' }
};

function checkAchievements() {
  if (!state.timeBlocking?.achievements) return;
  
  const achievements = state.timeBlocking.achievements;
  const newBadges = [];
  
  // Calculate current stats
  const stats = calculateAchievementStats();
  
  // Check week badges
  if (stats.weeklyBlocks >= 10 && !hasBadge('bronze_week')) {
    newBadges.push(BADGES.BRONZE_WEEK);
  }
  if (stats.weeklyBlocks >= 20 && !hasBadge('silver_week')) {
    newBadges.push(BADGES.SILVER_WEEK);
  }
  if (stats.weeklyBlocks >= 30 && !hasBadge('gold_week')) {
    newBadges.push(BADGES.GOLD_WEEK);
  }
  
  // Check streak badges
  if (stats.currentWorkStreak >= 3 && !hasBadge('three_day_streak')) {
    newBadges.push(BADGES.THREE_DAY_STREAK);
  }
  if (stats.currentWorkStreak >= 7 && !hasBadge('seven_day_streak')) {
    newBadges.push(BADGES.SEVEN_DAY_STREAK);
  }
  if (stats.currentWorkStreak >= 30 && !hasBadge('thirty_day_streak')) {
    newBadges.push(BADGES.THIRTY_DAY_STREAK);
  }
  
  // Check focus badges
  if (stats.todayOnTaskPct >= 95 && !hasBadge('focused_mind')) {
    newBadges.push(BADGES.FOCUSED_MIND);
  }
  if (stats.todayOnTaskPct >= 98 && !hasBadge('laser_focus')) {
    newBadges.push(BADGES.LASER_FOCUS);
  }
  if (stats.todayGoalComplete && !hasBadge('perfect_day')) {
    newBadges.push(BADGES.PERFECT_DAY);
  }
  
  // Check milestone badges
  if (stats.totalSessions >= 1 && !hasBadge('first_session')) {
    newBadges.push(BADGES.FIRST_SESSION);
  }
  if (stats.totalBlocks >= 100 && !hasBadge('hundred_blocks')) {
    newBadges.push(BADGES.HUNDRED_BLOCKS);
  }
  if (stats.totalBlocks >= 500 && !hasBadge('five_hundred_blocks')) {
    newBadges.push(BADGES.FIVE_HUNDRED_BLOCKS);
  }
  
  // Award new badges
  newBadges.forEach(badge => {
    achievements.badges.push({
      ...badge,
      earnedAt: new Date().toISOString(),
      earnedOn: getTodayISO()
    });
    showBadgeCelebration(badge);
  });
  
  // Update streaks
  updateStreaks(stats);
  
  if (newBadges.length > 0) {
    saveToFirebase();
  }
}

function hasBadge(badgeId) {
  return state.timeBlocking?.achievements?.badges?.some(b => b.id === badgeId) || false;
}

function calculateAchievementStats() {
  const today = getTodayISO();
  const currentDay = state.timeBlocking?.currentDay;
  const history = state.timeBlocking?.history || {};
  
  // Calculate weekly blocks
  let weeklyBlocks = 0;
  for (let i = 0; i < 7; i++) {
    const day = addDays(state.weekStart, i);
    const dayData = history[day];
    if (dayData) {
      weeklyBlocks += dayData.completedBlocks || 0;
    }
  }
  
  // Calculate today's stats
  const todayOnTaskPct = currentDay ? calculateTodayOnTaskPct(currentDay) : 0;
  const todayGoalComplete = currentDay ? currentDay.completedBlocks >= currentDay.goalBlocks : false;
  
  // Calculate total stats
  let totalBlocks = 0;
  let totalSessions = 0;
  Object.values(history).forEach(day => {
    totalBlocks += day.completedBlocks || 0;
    totalSessions += day.chunks?.length || 0;
  });
  
  // Calculate work streak
  let currentWorkStreak = 0;
  let checkDate = today;
  while (history[checkDate] && (history[checkDate].completedBlocks || 0) > 0) {
    currentWorkStreak++;
    checkDate = addDays(checkDate, -1);
  }
  
  return {
    weeklyBlocks,
    todayOnTaskPct,
    todayGoalComplete,
    totalBlocks,
    totalSessions,
    currentWorkStreak
  };
}

function calculateTodayOnTaskPct(currentDay) {
  const onTaskTime = currentDay.activeChunk?.onTaskTime || 0;
  const offTaskTime = currentDay.activeChunk?.offTaskTime || 0;
  const totalTime = onTaskTime + offTaskTime;
  return totalTime > 0 ? Math.round((onTaskTime / totalTime) * 100) : 0;
}

function updateStreaks(stats) {
  const achievements = state.timeBlocking.achievements;
  
  // Update current streaks
  achievements.streaks.currentWorkStreak = stats.currentWorkStreak;
  
  // Update longest streaks
  if (stats.currentWorkStreak > achievements.streaks.longestWork) {
    achievements.streaks.longestWork = stats.currentWorkStreak;
  }
  
  // Update total stats
  achievements.stats.totalBlocks = stats.totalBlocks;
  achievements.stats.totalSessions = stats.totalSessions;
  if (stats.todayGoalComplete) {
    achievements.stats.perfectDays++;
  }
}

function showBadgeCelebration(badge) {
  // Create celebration overlay
  const overlay = document.createElement('div');
  overlay.className = 'celebration-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fadeUp 0.5s ease-out;
  `;
  
  // Create badge popup
  const popup = document.createElement('div');
  popup.style.cssText = `
    background: var(--glass-bg);
    backdrop-filter: var(--backdrop-blur);
    border: 1px solid var(--glass-border);
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    box-shadow: var(--shadow-lift);
    animation: celebrationPulse 2s ease-in-out;
    max-width: 400px;
    margin: 20px;
  `;
  
  popup.innerHTML = `
    <div style="font-size: 64px; margin-bottom: 16px; animation: sparkle 1s ease-in-out infinite;">${badge.icon}</div>
    <h2 style="margin: 0 0 8px 0; color: var(--accent); font-size: 24px;">${badge.name}</h2>
    <p style="margin: 0 0 20px 0; color: var(--muted); font-size: 16px;">${badge.description}</p>
    <button onclick="this.parentElement.parentElement.remove()" class="modern-button primary" style="padding: 12px 24px;">
      Awesome! ð
    </button>
  `;
  
  overlay.appendChild(popup);
  document.body.appendChild(overlay);
  
  // Auto-remove after 5 seconds
  setTimeout(() => {
    if (overlay.parentElement) {
      overlay.remove();
    }
  }, 5000);
  
  // Add confetti
  createConfetti();
}

function createConfetti() {
  const colors = ['#5ad0ff', '#79dd94', '#ffbe5a', '#ff6b6b', '#d97706'];
  const confettiCount = 50;
  
  for (let i = 0; i < confettiCount; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti-piece';
    confetti.style.cssText = `
      position: fixed;
      width: 10px;
      height: 10px;
      background: ${colors[Math.floor(Math.random() * colors.length)]};
      left: ${Math.random() * 100}vw;
      top: -10px;
      animation: confetti 3s ease-out forwards;
      z-index: 9999;
    `;
    document.body.appendChild(confetti);
    
    // Remove after animation
    setTimeout(() => confetti.remove(), 3000);
  }
}

function isOnTrack() {
  const today = getTodayISO();
  const dayOfWeek = getDaysDifference(today, state.weekStart);
  const daysLeft = 7 - dayOfWeek;
  
  const appsNeeded = state.targets.apps - state.completedThisWeek.apps;
  const netNeeded = state.targets.networking - state.completedThisWeek.networking;
  
  if (appsNeeded <= 0 && netNeeded <= 0) {
    return { status: 'ahead', message: '' };
  }
  
  const appsDailyNeeded = Math.ceil(appsNeeded / daysLeft);
  const netDailyNeeded = Math.ceil(netNeeded / daysLeft);
  
  if (appsDailyNeeded <= 3 && netDailyNeeded <= 2) {
    return { status: 'on_track', message: '' };
  }
  
  return { 
    status: 'behind', 
    message: `Need ${appsDailyNeeded} apps/day to catch up` 
  };
}

// App initialization
// Display app version info
function displayVersionInfo() {
  const versionEl = document.getElementById('app-version');
  const buildDateEl = document.getElementById('app-build-date');
  const deployTimeEl = document.getElementById('app-deploy-time');
  const statusEl = document.getElementById('version-status');
  
  if (versionEl) versionEl.textContent = APP_VERSION;
  if (buildDateEl) buildDateEl.textContent = APP_BUILD_DATE;
  if (deployTimeEl) deployTimeEl.textContent = APP_DEPLOY_TIME;
  if (statusEl) statusEl.textContent = 'â Up to date';
  
  console.log(`ð Career Chute v${APP_VERSION} (${APP_BUILD_DATE})`);
}

async function initializeApp() {
  console.log('Initializing Career Chute...');
  
  // Display version info
  displayVersionInfo();
  
  // Initialize Google auth UI
  updateGoogleAuthUI();
  
  // Migrate Gmail Client ID to Google section if needed
  if (state.gmail.clientId && !state.google.clientId) {
    state.google.clientId = state.gmail.clientId;
    console.log('â Migrated Gmail Client ID to Google section');
  }
  
  // Initialize Google APIs for Sheets functionality
  if (typeof gapi !== 'undefined' && !gapiInited) {
    initGoogleAPI().then(() => {
      console.log('â Google APIs loaded for Sheets functionality');
    }).catch(error => {
      console.warn('Google API initialization failed:', error);
    });
  }
  
  // Show loading state
  updateSyncStatus('syncing', 'Starting...');
  
  // Check for timer conflicts on app load
  checkTimerConflicts();
  
  // Global timeout - if nothing happens in 10 seconds, go offline
  const globalTimeout = setTimeout(() => {
    console.warn('App initialization timeout - forcing offline mode');
    updateSyncStatus('error', 'Offline');
    loadFromLocalStorage();
  }, 10000);
  
  try {
    // Try to initialize Firebase with timeout
    const firebaseReady = await initializeFirebase();
    clearTimeout(globalTimeout);
    
    if (firebaseReady) {
      console.log('Firebase ready, loading from cloud...');
      loadFromFirebase();
    } else {
      console.log('Firebase unavailable, loading from local storage...');
      updateSyncStatus('error', 'Offline');
      loadFromLocalStorage();
    }
    
    // Initialize Gmail API after Firebase loads
    if (state.gmail && state.gmail.clientId) {
      initGoogleAPI().catch(error => {
        console.warn('Gmail API initialization failed:', error);
      });
    }
  } catch (error) {
    clearTimeout(globalTimeout);
    console.error('App initialization error:', error);
    updateSyncStatus('error', 'Offline');
    loadFromLocalStorage();
  }
}

// Start the app when page loads
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded, starting app...');
  
  // Emergency fallback - if app doesn't load in 5 seconds, force offline
  setTimeout(() => {
    const syncText = document.getElementById('syncText');
    if (syncText && syncText.textContent === 'Loading...') {
      console.warn('Emergency fallback triggered - forcing offline mode');
      updateSyncStatus('error', 'Offline');
      loadFromLocalStorage();
    }
  }, 5000);
  
  initializeApp();
});

// Cleanup timers when page unloads
window.addEventListener('beforeunload', function() {
  if (chunkTimerInterval) {
    clearInterval(chunkTimerInterval);
  }
});

// Also start if DOM is already loaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeApp);
} else {
  initializeApp();
}

// Modal and UI functions
function showAddTaskModal() {
  document.getElementById('addTaskModal').classList.add('active');
  updateTaskModalForType();
}

function showAddAppModal() {
  // Clear form fields
  document.getElementById('newAppCompany').value = '';
  document.getElementById('newAppRole').value = '';
  document.getElementById('newAppUrl').value = '';
  document.getElementById('newAppDeadline').value = '';
  document.getElementById('newAppNotes').value = '';
  
  document.getElementById('addAppModal').classList.add('active');
}

function showAddContactModal() {
  // Clear form fields
  document.getElementById('newContactName').value = '';
  document.getElementById('newContactRel').value = 'Friend/Ally';
  document.getElementById('newContactCompany').value = '';
  document.getElementById('newContactLinkedIn').value = '';
  document.getElementById('newContactNotes').value = '';
  
  document.getElementById('addContactModal').classList.add('active');
}

function showAddEventModal() {
  // Clear form fields
  document.getElementById('newEventName').value = '';
  document.getElementById('newEventDate').value = '';
  document.getElementById('newEventStartTime').value = '';
  document.getElementById('newEventEndTime').value = '';
  document.getElementById('newEventType').value = 'fair';
  document.getElementById('newEventLink').value = '';
  document.getElementById('newEventAddress').value = '';
  document.getElementById('newEventNotes').value = '';
  document.getElementById('favoritesGroup').style.display = 'none';
  document.getElementById('newEventFavorites').value = '';
  
  document.getElementById('addEventModal').classList.add('active');
}

function closeModal(modalId) {
  document.getElementById(modalId).classList.remove('active');
}

function updateTaskModalForType() {
  const type = document.getElementById('newTaskType').value;
  const selectSection = document.getElementById('taskSelectSection');
  const quickSection = document.getElementById('quickAddSection');
  const refSelect = document.getElementById('newTaskRef');
  const toggle = document.getElementById('quickAddToggle');
  
  // Clear existing options
  refSelect.innerHTML = '<option value="">-- Select --</option>';
  
  if (type === 'application') {
    const today = getTodayISO();
    const todayTaskIds = (state.dailyTasks[today] || []).map(task => task.refId).filter(id => id);
    
    state.applications.forEach(app => {
      // Only show applications that aren't already in today's queue
      if (!todayTaskIds.includes(app.id)) {
        const option = document.createElement('option');
        option.value = app.id;
        option.textContent = `${app.company} - ${app.role}`;
        refSelect.appendChild(option);
      }
    });
    selectSection.style.display = 'block';
  } else if (type === 'networking') {
    state.contacts.forEach(contact => {
      const option = document.createElement('option');
      option.value = contact.id;
      option.textContent = contact.name;
      refSelect.appendChild(option);
    });
    selectSection.style.display = 'block';
  } else if (type === 'event') {
    state.events.forEach(event => {
      const option = document.createElement('option');
      option.value = event.id;
      option.textContent = event.name;
      refSelect.appendChild(option);
    });
    selectSection.style.display = 'block';
  } else {
    selectSection.style.display = 'none';
  }
  
  quickSection.style.display = 'none';
  if (type === 'application') toggle.textContent = '+ Quick add application';
  else if (type === 'networking') toggle.textContent = '+ Quick add contact';
  else if (type === 'event') toggle.textContent = '+ Quick add event';
}

function toggleQuickAdd() {
  const quickSection = document.getElementById('quickAddSection');
  const toggle = document.getElementById('quickAddToggle');
  
  if (quickSection.style.display === 'none') {
    const type = document.getElementById('newTaskType').value;
    let html = '';
    
    if (type === 'application') {
      html = `
        <div class="form-group">
          <label>Company Name</label>
          <input type="text" id="quickAppCompany" placeholder="Acme Corp">
        </div>
        <div class="form-group">
          <label>Job Title</label>
          <input type="text" id="quickAppRole" placeholder="Product Manager">
        </div>
        <div class="form-group">
          <label>Job URL</label>
          <input type="url" id="quickAppUrl" placeholder="https://...">
        </div>
      `;
    } else if (type === 'networking') {
      html = `
        <div class="form-group">
          <label>Contact Name</label>
          <input type="text" id="quickContactName" placeholder="John Smith">
        </div>
        <div class="form-group">
          <label>Contact URL (LinkedIn, website)</label>
          <input type="url" id="quickContactUrl" placeholder="https://linkedin.com/in/...">
        </div>
      `;
    } else if (type === 'event') {
      html = `
        <div class="form-group">
          <label>Event Name</label>
          <input type="text" id="quickEventName" placeholder="Career Fair">
        </div>
        <div class="form-group">
          <label>Date</label>
          <input type="date" id="quickEventDate">
        </div>
        <div class="form-group">
          <label>Start Time</label>
          <input type="time" id="quickEventStartTime">
        </div>
        <div class="form-group">
          <label>End Time</label>
          <input type="time" id="quickEventEndTime">
        </div>
        <div class="form-group">
          <label>Type</label>
          <select id="quickEventType">
            <option value="fair">Career Fair</option>
            <option value="workshop">Workshop</option>
            <option value="info_session">Info Session</option>
            <option value="networking">Networking Event</option>
            <option value="interview">Interview</option>
            <option value="volunteer">Volunteer Shift</option>
            <option value="mindfulness">Mindfulness Event</option>
            <option value="balloon_gig">Balloon Gig</option>
            <option value="dog_gig">Dog Gig</option>
          </select>
        </div>
        <div class="form-group">
          <label>Calendar Link (optional)</label>
          <input type="url" id="quickEventCalendarUrl" placeholder="https://calendar.google.com/...">
        </div>
      `;
    }
    
    quickSection.innerHTML = html;
    quickSection.style.display = 'block';
    // Keep label static; user can cancel modal to exit
    if (type === 'application') toggle.textContent = '+ Quick add application';
    else if (type === 'networking') toggle.textContent = '+ Quick add contact';
    else if (type === 'event') toggle.textContent = '+ Quick add event';
  } else {
    quickSection.style.display = 'none';
    const type = document.getElementById('newTaskType').value;
    if (type === 'application') toggle.textContent = '+ Quick add application';
    else if (type === 'networking') toggle.textContent = '+ Quick add contact';
    else if (type === 'event') toggle.textContent = '+ Quick add event';
  }
}

function addTaskToToday() {
  const type = document.getElementById('newTaskType').value;
  const refId = document.getElementById('newTaskRef').value;
  const today = getTodayISO();
  
  if (!state.dailyTasks[today]) {
    state.dailyTasks[today] = [];
  }
  
  let task = {
    id: generateId(),
    type: type,
    completed: false,
    estimatedTime: type === 'tailoring' ? 20 : type === 'application' ? 10 : type === 'networking' ? 15 : 60,
    notes: ''
  };
  
  // Handle quick add
  const quickSection = document.getElementById('quickAddSection');
  if (quickSection.style.display !== 'none') {
    if (type === 'application') {
      const company = document.getElementById('quickAppCompany').value.trim();
      const role = document.getElementById('quickAppRole').value.trim();
      const url = document.getElementById('quickAppUrl').value.trim();
      if (!company || !role) {
        alert('Please fill in company and role');
        return;
      }
      
      // Create new application
      const app = {
        id: generateId(),
        company: company,
        role: role,
        status: 'queued',
        dateAdded: today,
        url: url,
        notes: ''
      };
      state.applications.push(app);
      task.refId = app.id;
      // Also auto-create tailoring task for today
      const tailoringTask = { id: generateId(), type: 'tailoring', refId: app.id, completed: false, estimatedTime: 20, notes: '' };
      state.dailyTasks[today].push(tailoringTask);
    } else if (type === 'networking') {
      const name = document.getElementById('quickContactName').value.trim();
      const contactUrl = document.getElementById('quickContactUrl').value.trim();
      if (!name) {
        alert('Please fill in contact name');
        return;
      }
      
      // Create new contact
      const contact = {
        id: generateId(),
        name: name,
        relationship: 'Professional Contact',
        company: '',
        notes: '',
        url: contactUrl
      };
      state.contacts.push(contact);
      task.refId = contact.id;
    } else if (type === 'event') {
      const name = document.getElementById('quickEventName').value.trim();
      if (!name) {
        alert('Please fill in event name');
        return;
      }
      
      // Create new event
      const event = {
        id: generateId(),
        name: name,
        date: document.getElementById('quickEventDate').value || today,
        duration: parseInt(document.getElementById('quickEventDuration').value || '120'),
        type: document.getElementById('quickEventType').value || 'networking',
        notes: '',
        calendarUrl: document.getElementById('quickEventCalendarUrl') ? document.getElementById('quickEventCalendarUrl').value.trim() : ''
      };
      state.events.push(event);
      task.refId = event.id;
    }
  } else if (refId) {
    task.refId = refId;
    // If adding application task, also create paired tailoring task
    if (type === 'application') {
      const tailoringTask = { id: generateId(), type: 'tailoring', refId: refId, completed: false, estimatedTime: 20, notes: '' };
      state.dailyTasks[today].push(tailoringTask);
      
      // Update application status to 'queued' if it was 'applied'
      const app = state.applications.find(a => a.id === refId);
      if (app && app.status === 'applied') {
        app.status = 'queued';
        app.dateApplied = null;
      }
    }
  } else {
    alert('Please select an item or use quick add');
    return;
  }

  // Prevent duplicate tasks for same ref on same day
  const duplicate = (state.dailyTasks[today] || []).some(t => t.type === task.type && t.refId === task.refId && !t.completed);
  if (duplicate) {
    alert('This task already exists for today.');
  } else {
    state.dailyTasks[today].push(task);
  }
  saveToFirebase();
  
  closeModal('addTaskModal');
  renderTodayTasks();
  renderPlanScreen();
}

// Edit/Delete helpers for queue and pipeline
function editQueueItem(taskId) {
  const today = getTodayISO();
  const task = (state.dailyTasks[today] || []).find(t => t.id === taskId);
  if (!task) return;
  // Open unified edit modal pre-filled like quick add
  openEditModalForTask(task);
}

function deleteQueueItem(taskId) {
  const today = getTodayISO();
  if (!state.dailyTasks[today]) return;
  if (!confirm('Remove this task from today?')) return;
  state.dailyTasks[today] = state.dailyTasks[today].filter(t => t.id !== taskId);
  saveToFirebase();
  renderTodayTasks();
}

function editApplication(appId) { const app = state.applications.find(a => a.id === appId); if (!app) return; openEditModal('application', app); }
function editContact(contactId) { const contact = state.contacts.find(c => c.id === contactId); if (!contact) return; openEditModal('networking', contact); }
function editEvent(eventId) { const event = state.events.find(e => e.id === eventId); if (!event) return; openEditModal('event', event); }

// Unified edit modal using existing add modals' layout
function openEditModalForTask(task) {
  if (task.type === 'application' || task.type === 'tailoring') {
    const app = state.applications.find(a => a.id === task.refId);
    if (app) return openEditModal('application', app);
  }
  if (task.type === 'networking') {
    const contact = state.contacts.find(c => c.id === task.refId);
    if (contact) return openEditModal('networking', contact);
  }
  if (task.type === 'event') {
    const event = state.events.find(e => e.id === task.refId);
    if (event) return openEditModal('event', event);
  }
}

function openEditModal(type, entity) {
  // Reuse add modals with prefill and a Save button
  if (type === 'application') {
    document.getElementById('newAppCompany').value = entity.company || '';
    document.getElementById('newAppRole').value = entity.role || '';
    document.getElementById('newAppUrl').value = entity.url || '';
    document.getElementById('newAppDeadline').value = entity.deadline || '';
    document.getElementById('newAppNotes').value = entity.notes || '';
    const modal = document.getElementById('addAppModal');
    modal.classList.add('active');
    // Swap primary button to Save
    const btns = modal.querySelectorAll('.btn-group button');
    if (btns[0]) { btns[0].textContent = 'Save'; btns[0].onclick = function() { saveEditedApplication(entity.id); }; }
  } else if (type === 'networking') {
    document.getElementById('newContactName').value = entity.name || '';
    document.getElementById('newContactRel').value = entity.relationship || 'Professional Contact';
    document.getElementById('newContactCompany').value = entity.company || '';
    document.getElementById('newContactNotes').value = entity.notes || '';
    const modal = document.getElementById('addContactModal');
    modal.classList.add('active');
    const btns = modal.querySelectorAll('.btn-group button');
    if (btns[0]) { btns[0].textContent = 'Save'; btns[0].onclick = function() { saveEditedContact(entity.id); }; }
  } else if (type === 'event') {
    document.getElementById('newEventName').value = entity.name || '';
    document.getElementById('newEventDate').value = entity.date || '';
    document.getElementById('newEventDuration').value = entity.duration || 120;
    document.getElementById('newEventType').value = entity.type || 'networking';
    document.getElementById('newEventLink').value = entity.link || '';
    document.getElementById('newEventAddress').value = entity.address || '';
    document.getElementById('newEventNotes').value = entity.notes || '';
    const modal = document.getElementById('addEventModal');
    modal.classList.add('active');
    const btns = modal.querySelectorAll('.btn-group button');
    if (btns[0]) { btns[0].textContent = 'Save'; btns[0].onclick = function() { saveEditedEvent(entity.id); }; }
  }
}

function saveEditedApplication(appId) {
  const app = state.applications.find(a => a.id === appId);
  if (!app) return;
  
  app.company = document.getElementById('newAppCompany').value.trim();
  app.role = document.getElementById('newAppRole').value.trim();
  let url = document.getElementById('newAppUrl').value.trim();
  app.deadline = document.getElementById('newAppDeadline').value || null;
  app.notes = document.getElementById('newAppNotes').value.trim();
  
  // Validate URL if provided
  if (url) {
    const validation = isValidUrl(url);
    if (!validation.isValid) {
      const newUrl = promptForValidUrl(url, app.company, app.role);
      if (newUrl === null) return; // User cancelled
      url = newUrl;
    }
  }
  
  app.url = url;
  saveToFirebase();
  closeModal('addAppModal');
  renderPlanScreen();
  renderTodayTasks();
  
  // Update focus session UI if currently focused on this application
  updateFocusSessionUI();
}

function saveEditedContact(contactId) {
  const contact = state.contacts.find(c => c.id === contactId);
  if (!contact) return;
  contact.name = document.getElementById('newContactName').value.trim();
  contact.relationship = document.getElementById('newContactRel').value;
  contact.company = document.getElementById('newContactCompany').value.trim();
  contact.notes = document.getElementById('newContactNotes').value.trim();
  saveToFirebase();
  closeModal('addContactModal');
  renderPlanScreen();
  renderTodayTasks();
  
  // Update focus session UI if currently focused on this contact
  updateFocusSessionUI();
}

function saveEditedEvent(eventId) {
  const event = state.events.find(e => e.id === eventId);
  if (!event) return;
  event.name = document.getElementById('newEventName').value.trim();
  event.date = document.getElementById('newEventDate').value;
  event.duration = parseInt(document.getElementById('newEventDuration').value) || 120;
  event.type = document.getElementById('newEventType').value;
  event.link = document.getElementById('newEventLink').value.trim();
  event.address = document.getElementById('newEventAddress').value.trim();
  event.notes = document.getElementById('newEventNotes').value.trim();
  saveToFirebase();
  closeModal('addEventModal');
  renderPlanScreen();
  renderTodayTasks();
  
  // Update focus session UI if currently focused on this event
  updateFocusSessionUI();
}

function addApplication() {
  const company = document.getElementById('newAppCompany').value.trim();
  const role = document.getElementById('newAppRole').value.trim();
  let url = document.getElementById('newAppUrl').value.trim();
  const deadline = document.getElementById('newAppDeadline').value;
  const notes = document.getElementById('newAppNotes').value.trim();
  
  if (!company || !role) {
    alert('Please fill in company and role');
    return;
  }
  
  // Validate URL if provided
  if (url) {
    const validation = isValidUrl(url);
    if (!validation.isValid) {
      const newUrl = promptForValidUrl(url, company, role);
      if (newUrl === null) return; // User cancelled
      url = newUrl;
    }
  }
  
  const app = {
    id: generateId(),
    company: company,
    role: role,
    status: 'queued',
    dateAdded: getTodayISO(),
    url: url,
    deadline: deadline || null,
    notes: notes
  };
  
  state.applications.push(app);
  saveToFirebase();
  
  // Clear form
  document.getElementById('newAppCompany').value = '';
  document.getElementById('newAppRole').value = '';
  document.getElementById('newAppUrl').value = '';
  document.getElementById('newAppDeadline').value = '';
  document.getElementById('newAppNotes').value = '';
  
  closeModal('addAppModal');
  renderPlanScreen();
}

function addContact() {
  const name = document.getElementById('newContactName').value.trim();
  const relationship = document.getElementById('newContactRel').value;
  const company = document.getElementById('newContactCompany').value.trim();
  const linkedin = document.getElementById('newContactLinkedIn').value.trim();
  const notes = document.getElementById('newContactNotes').value.trim();
  
  if (!name) {
    alert('Please fill in contact name');
    return;
  }
  
  const contact = {
    id: generateId(),
    name: name,
    relationship: relationship,
    company: company,
    linkedin: linkedin,
    notes: notes,
    lastContact: null,
    addedDate: getTodayISO()
  };
  
  state.contacts.push(contact);
  saveToFirebase();
  
  // Auto-sync to Google Sheets if enabled
  if (state.sheets.enabled && state.sheets.autoSync) {
    syncContactsToGoogleSheets().catch(err => console.warn('Auto-sync contacts failed:', err));
  }
  
  // Clear form
  document.getElementById('newContactName').value = '';
  document.getElementById('newContactRel').value = 'Friend/Ally';
  document.getElementById('newContactCompany').value = '';
  document.getElementById('newContactLinkedIn').value = '';
  document.getElementById('newContactNotes').value = '';
  
  closeModal('addContactModal');
  renderPlanScreen();
}

function addEvent() {
  const name = document.getElementById('newEventName').value.trim();
  const date = document.getElementById('newEventDate').value;
  const startTime = document.getElementById('newEventStartTime').value;
  const endTime = document.getElementById('newEventEndTime').value;
  const type = document.getElementById('newEventType').value;
  const notes = document.getElementById('newEventNotes').value.trim();
  const link = document.getElementById('newEventLink').value.trim();
  const address = document.getElementById('newEventAddress').value.trim();
  const favorite = document.getElementById('newEventFavorites').value;
  
  if (!name || !date || !startTime || !endTime) {
    alert('Please fill in event name, date, start time, and end time');
    return;
  }
  
  // Calculate duration from start and end time
  const start = new Date(`2000-01-01T${startTime}`);
  const end = new Date(`2000-01-01T${endTime}`);
  const duration = Math.round((end - start) / (1000 * 60)); // duration in minutes
  
  if (duration <= 0) {
    alert('End time must be after start time');
    return;
  }
  
  const event = {
    id: generateId(),
    name: name,
    date: date,
    startTime: startTime,
    endTime: endTime,
    duration: duration,
    type: type,
    notes: notes,
    link: link,
    address: address,
    favorite: type === 'volunteer' ? favorite : null,
    attended: false
  };
  
  state.events.push(event);
  saveToFirebase();
  
  // Clear form
  document.getElementById('newEventName').value = '';
  document.getElementById('newEventDate').value = '';
  document.getElementById('newEventStartTime').value = '';
  document.getElementById('newEventEndTime').value = '';
  document.getElementById('newEventType').value = 'fair';
  document.getElementById('newEventLink').value = '';
  document.getElementById('newEventAddress').value = '';
  document.getElementById('newEventNotes').value = '';
  document.getElementById('favoritesGroup').style.display = 'none';
  document.getElementById('newEventFavorites').value = '';
  
  closeModal('addEventModal');
  renderPlanScreen();
}

function saveSettings() {
  state.targets.apps = parseInt(document.getElementById('targetApps').value);
  state.targets.networking = parseInt(document.getElementById('targetNet').value);
  state.targets.events = parseInt(document.getElementById('targetEvents').value);
  
  if (state.guardrails) {
    state.guardrails.maxTailorTime = parseInt(document.getElementById('maxTailorTime').value);
    state.guardrails.maxOptimizationTime = parseInt(document.getElementById('maxOptimizationTime').value);
    state.guardrails.warningThreshold = parseInt(document.getElementById('warningThreshold').value);
  }
  
  saveToFirebase();
  alert('Settings saved!');
  renderProgress();
  renderPlanScreen();
}

function toggleGuardrails() {
  const enabled = document.getElementById('guardrailsEnabled').checked;
  const settings = document.getElementById('guardrailsSettings');
  
  state.guardrails.enabled = enabled;
  settings.style.display = enabled ? 'block' : 'none';
  
  saveToFirebase();
}

function renderSettings() {
  document.getElementById('targetApps').value = state.targets.apps;
  document.getElementById('targetNet').value = state.targets.networking;
  document.getElementById('targetEvents').value = state.targets.events;
  document.getElementById('userId').textContent = userId;
  
  // Update theme toggle (checked = light mode)
  const themeToggle = document.getElementById('themeToggle');
  if (themeToggle) {
    themeToggle.checked = state.theme === 'light';
  }
  
  // Update color theme dropdown
  const colorThemeSelect = document.getElementById('colorThemeSelect');
  if (colorThemeSelect) {
    colorThemeSelect.value = state.colorTheme || 'A1';
    
    // Add custom themes to dropdown
    if (state.customThemes) {
      Object.keys(state.customThemes).forEach(themeName => {
        // Check if option already exists
        const existingOption = Array.from(colorThemeSelect.options).find(option => option.value === themeName);
        if (!existingOption) {
          const newOption = document.createElement('option');
          newOption.value = themeName;
          newOption.textContent = `${themeName} - Custom Theme`;
          colorThemeSelect.appendChild(newOption);
        }
      });
    }
  }
  
  // Apply theme immediately
  applyTheme();
  
  // Apply color theme
  if (state.colorTheme) {
    document.documentElement.setAttribute('data-color-theme', state.colorTheme);
  }
  
  // Load custom colors
  loadCustomColors();
  
  // Initialize styling center
  initializeStylingCenter();
  
  // Update guardrails settings
  if (state.guardrails) {
    document.getElementById('guardrailsEnabled').checked = state.guardrails.enabled;
    document.getElementById('maxTailorTime').value = state.guardrails.maxTailorTime;
    document.getElementById('maxOptimizationTime').value = state.guardrails.maxOptimizationTime;
    document.getElementById('warningThreshold').value = state.guardrails.warningThreshold;
    document.getElementById('guardrailsSettings').style.display = state.guardrails.enabled ? 'block' : 'none';
  }
  
  // Update Gmail settings (if element exists)
  if (state.gmail && document.getElementById('gmailClientId')) {
    document.getElementById('gmailClientId').value = state.gmail.clientId || '';
    updateGmailUI();
  }
  
  // Update Google Sheets UI
  updateSheetsUI();
}

// Gmail Integration Functions
function handleGmailClientIdChange(clientId) {
  state.gmail.clientId = clientId;
  saveToFirebase();
  
  // Initialize Gmail API if we have a client ID
  if (clientId && typeof gapi !== 'undefined') {
    initGoogleAPI().catch(error => {
      console.warn('Gmail API initialization failed:', error);
    });
  }
}

function loadOAuthConfig(environment) {
  const configs = {
    netlify: {
      clientId: '906932405437-9r5i8d63ssle5sqas1fob1k7u4k57bfq.apps.googleusercontent.com',
      redirectUri: 'https://cchute.netlify.app',
      origin: 'https://cchute.netlify.app'
    },
    localhost: {
      clientId: '906932405437-9r5i8d63ssle5sqas1fob1k7u4k57bfq.apps.googleusercontent.com',
      redirectUri: 'http://localhost:8000',
      origin: 'http://localhost:8000'
    }
  };
  
  const config = configs[environment];
  if (config) {
    document.getElementById('gmailClientId').value = config.clientId;
    state.gmail.clientId = config.clientId;
    state.gmail.redirectUri = config.redirectUri;
    saveToFirebase();
    
    // Initialize GAPI if needed
    if (typeof gapi !== 'undefined' && !gapiInited) {
      initGoogleAPI().then(() => {
        // Initialize GIS after GAPI is ready
        initGIS();
      }).catch(error => {
        console.warn('Gmail API initialization failed:', error);
      });
    } else if (gapiInited && !gisInited) {
      // GAPI already initialized, just initialize GIS
      initGIS();
    }
    
    console.log(`Loaded ${environment} OAuth config`);
  }
}

function saveOAuthConfig() {
  const clientId = document.getElementById('gmailClientId').value;
  if (clientId) {
    state.gmail.clientId = clientId;
    saveToFirebase();
    console.log('OAuth config saved');
  }
}

function testOAuthConfig() {
  const currentOrigin = window.location.origin;
  const clientId = state.gmail.clientId;
  const redirectUri = state.gmail.redirectUri;
  
  console.log('=== OAuth Configuration Test ===');
  console.log('Current Origin:', currentOrigin);
  console.log('Client ID:', clientId);
  console.log('Redirect URI:', redirectUri);
  
  let message = `OAuth Configuration Test:\n\n`;
  message += `Current Origin: ${currentOrigin}\n`;
  message += `Client ID: ${clientId ? 'Set' : 'Not Set'}\n`;
  message += `Redirect URI: ${redirectUri || 'Not Set'}\n\n`;
  
  if (currentOrigin === 'https://cchute.netlify.app') {
    message += `For Netlify, you need to add to Google Cloud Console:\n`;
    message += `- Authorized JavaScript origins: https://cchute.netlify.app\n`;
    message += `- Authorized redirect URIs: https://cchute.netlify.app\n\n`;
  } else if (currentOrigin === 'http://localhost:8000') {
    message += `For Localhost, you need to add to Google Cloud Console:\n`;
    message += `- Authorized JavaScript origins: http://localhost:8000\n`;
    message += `- Authorized redirect URIs: http://localhost:8000\n\n`;
  }
  
  message += `Click "Netlify" or "Localhost" button to configure for your current domain.`;
  
  alert(message);
}

function resetGmailAPI() {
  if (typeof gapi !== 'undefined' && gapi.auth2) {
    const authInstance = gapi.auth2.getAuthInstance();
    if (authInstance) {
      authInstance.disconnect();
      console.log('Gmail API disconnected');
    }
  }
  
  // Clear the state
  state.gmail.connected = false;
  state.gmail.userEmail = null;
  state.gmail.accessToken = null;
  state.gmail.tokenExpiry = null;
  
  updateGmailUI();
  saveToFirebase();
  
  console.log('Gmail API reset, you can now try connecting again');
  alert('Gmail API reset. Please try connecting again.');
}

let tokenClient = null;
let gapiInited = false;
let gisInited = false;

function initGoogleAPI() {
  if (typeof gapi === 'undefined') {
    console.error('Google APIs not loaded');
    return Promise.reject('Google APIs not loaded');
  }
  
  // Initialize GAPI client
  return new Promise((resolve, reject) => {
    gapi.load('client', async () => {
      try {
        await gapi.client.init({
          discoveryDocs: [
            'https://gmail.googleapis.com/$discovery/rest?version=v1',
            'https://sheets.googleapis.com/$discovery/rest?version=v4'
          ]
        });
        
        // Load Gmail and Sheets APIs
        await gapi.client.load('gmail', 'v1');
        await gapi.client.load('sheets', 'v4');
        
        gapiInited = true;
        console.log('GAPI client initialized with Gmail and Sheets APIs');
        resolve();
      } catch (error) {
        console.error('GAPI initialization failed:', error);
        reject(error);
      }
    });
  });
}

function initGIS() {
  if (typeof google === 'undefined' || !google.accounts) {
    console.error('Google Identity Services not loaded');
    return;
  }
  
  if (!state.gmail.clientId) {
    console.warn('No client ID configured');
    return;
  }
  
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: state.gmail.clientId,
    scope: 'https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/gmail.modify https://www.googleapis.com/auth/spreadsheets',
    callback: (response) => {
      if (response.error) {
        console.error('OAuth error:', response);
        alert('Failed to connect: ' + response.error);
        return;
      }
      
      // Successfully got token
      state.gmail.connected = true;
      state.gmail.accessToken = response.access_token;
      state.gmail.tokenExpiry = Date.now() + (response.expires_in * 1000);
      
      // Set the token for API calls
      gapi.client.setToken({
        access_token: response.access_token
      });
      
      // Get user email
      if (gapi.client.gmail) {
        gapi.client.gmail.users.getProfile({ userId: 'me' }).then(profile => {
          state.gmail.userEmail = profile.result.emailAddress;
          updateGmailUI();
          saveToFirebase();
          console.log('Gmail connected successfully');
          alert(`Gmail connected as ${state.gmail.userEmail}`);
        }).catch(error => {
          console.error('Error getting profile:', error);
          // Still mark as connected even if profile fails
          updateGmailUI();
          saveToFirebase();
          alert('Gmail connected successfully!');
        });
      } else {
        // API not loaded yet, just save the connection
        updateGmailUI();
        saveToFirebase();
        alert('Gmail connected! Please wait a moment for APIs to load.');
      }
    },
  });
  
  gisInited = true;
  console.log('Google Identity Services initialized');
}

function connectGmail() {
  if (!state.gmail.clientId) {
    alert('Please click "Netlify" or "Localhost" button first to configure OAuth');
    return;
  }
  
  if (!gapiInited || !gisInited) {
    console.log('Initializing Google services...');
    
    // Initialize GIS if not already done
    if (!gisInited) {
      initGIS();
    }
    
    // Wait a moment for initialization
    if (!gapiInited || !gisInited) {
      alert('Google services are still loading. Please try again in a moment.');
      return;
    }
  }
  
  if (!tokenClient) {
    alert('OAuth not configured. Please click "Netlify" or "Localhost" button first.');
    return;
  }
  
  console.log('Starting Gmail OAuth flow with Google Identity Services...');
  console.log('Client ID:', state.gmail.clientId);
  
  // Request access token
  tokenClient.requestAccessToken({ prompt: 'consent' });
}

function disconnectGmail() {
  // Revoke the token using Google Identity Services
  if (state.gmail.accessToken && typeof google !== 'undefined' && google.accounts) {
    google.accounts.oauth2.revoke(state.gmail.accessToken, () => {
      console.log('Token revoked');
    });
  }
  
  state.gmail.connected = false;
  state.gmail.userEmail = null;
  state.gmail.accessToken = null;
  state.gmail.tokenExpiry = null;
  state.gmail.lastScanTime = null;
  state.gmail.lastScanResults = { added: 0, duplicates: 0, emailsProcessed: 0 };
  
  updateGmailUI();
  saveToFirebase();
  
  console.log('Gmail disconnected');
}

async function refreshGmailToken() {
  if (!state.gmail.accessToken || !state.gmail.tokenExpiry) {
    throw new Error('No token to refresh');
  }
  
  // Check if token is actually expired (allow small buffer for in-flight requests)
  if (Date.now() < state.gmail.tokenExpiry - 60000) { // 1 minute buffer
    console.log('Token still valid, no refresh needed');
    return;
  }
  
  console.log('Refreshing Gmail token...');
  
  // Use Google Identity Services to refresh the token
  if (typeof google !== 'undefined' && google.accounts && tokenClient) {
    return new Promise((resolve, reject) => {
      // Request new token silently (no popup if user still logged in)
      tokenClient.callback = (response) => {
        if (response.error) {
          console.error('Token refresh error:', response.error);
          reject(new Error(response.error));
          return;
        }
        
        if (response.access_token) {
        state.gmail.accessToken = response.access_token;
        state.gmail.tokenExpiry = Date.now() + (response.expires_in * 1000);
        
        // Set the token for API calls
        if (gapi && gapi.client) {
          gapi.client.setToken({
            access_token: response.access_token
          });
        }
        
        saveToFirebase();
          console.log('Gmail token refreshed successfully. New expiry:', new Date(state.gmail.tokenExpiry).toLocaleTimeString());
        resolve();
        } else {
          reject(new Error('No access token in response'));
        }
      };
      
      // Request token without showing popup (prompt: 'none')
      tokenClient.requestAccessToken({ prompt: '' });
    });
  } else {
    throw new Error('Google Identity Services not available for token refresh');
  }
}

async function checkTokenExpiry() {
  if (!state.gmail.connected || !state.gmail.tokenExpiry) {
    return;
  }
  
  const now = Date.now();
  const timeUntilExpiry = state.gmail.tokenExpiry - now;
  
  // Refresh token if it expires in less than 5 minutes
  if (timeUntilExpiry < 5 * 60 * 1000) {
    console.log(`Token expires in ${Math.round(timeUntilExpiry / 60000)} minutes, refreshing...`);
    try {
      await refreshGmailToken();
      console.log('Automatic token refresh successful');
    } catch (error) {
      console.error('Automatic token refresh failed:', error);
      // Don't disconnect immediately, let user continue until actual API call fails
      console.warn('Will attempt refresh on next API call');
    }
  }
}

function updateGmailUI() {
  const statusText = document.getElementById('gmailStatusText');
  const connectBtn = document.getElementById('connectGmailBtn');
  const disconnectBtn = document.getElementById('disconnectGmailBtn');
  const scanBtn = document.getElementById('scanEmailsBtn');
  
  // Return early if Gmail UI elements don't exist (archived)
  if (!statusText || !connectBtn || !disconnectBtn || !scanBtn) {
    return;
  }
  
  if (state.gmail.connected) {
    let statusMessage = `Connected as ${state.gmail.userEmail}`;
    
    // Show token expiry time for debugging
    if (state.gmail.tokenExpiry) {
      const timeUntilExpiry = state.gmail.tokenExpiry - Date.now();
      const minutesLeft = Math.round(timeUntilExpiry / 60000);
      
      if (minutesLeft > 0) {
        statusMessage += ` (token valid for ${minutesLeft}m)`;
      } else {
        statusMessage += ` (token expired!)`;
        statusText.style.color = '#ea580c'; // Orange warning
      }
    }
    
    statusText.textContent = statusMessage;
    statusText.style.color = 'var(--ok)';
    
    if (connectBtn) connectBtn.style.display = 'none';
    if (disconnectBtn) disconnectBtn.style.display = 'inline-block';
    if (scanBtn) scanBtn.style.display = 'inline-block';
    
    // Show last scan info if available
    if (state.gmail.lastScanTime) {
      const lastScanInfo = document.getElementById('gmailLastScan');
      if (lastScanInfo) {
        lastScanInfo.innerHTML = `
          <div style="font-size: 12px; color: var(--muted); margin-top: 4px;">
            Last scan: ${formatDateTime(state.gmail.lastScanTime)}<br>
            Added: ${state.gmail.lastScanResults.added} jobs, 
            Duplicates: ${state.gmail.lastScanResults.duplicates}, 
            Processed: ${state.gmail.lastScanResults.emailsProcessed} emails
          </div>
        `;
      }
    }
  } else {
    statusText.textContent = 'Not connected';
    statusText.style.color = 'var(--muted)';
    
    if (connectBtn) connectBtn.style.display = 'inline-block';
    if (disconnectBtn) disconnectBtn.style.display = 'none';
    if (scanBtn) scanBtn.style.display = 'none';
    
    const lastScanInfo = document.getElementById('gmailLastScan');
    if (lastScanInfo) {
      lastScanInfo.innerHTML = '';
    }
  }
}

// Job Queue Functions
function renderJobQueue() {
  const container = document.getElementById('jobQueueTable');
  if (!container) return;
  
  // Get all applications and sort by score
  const jobs = (state.applications || []).map(app => ({
    ...app,
    matchScore: calculateJobScore(app)
  })).sort((a, b) => b.matchScore - a.matchScore);
  
  console.log('Rendering job queue with', jobs.length, 'jobs');
  
  if (jobs.length === 0) {
    container.innerHTML = `
      <div style="padding: 40px; text-align: center; color: var(--muted);">
        <div style="font-size: 48px; margin-bottom: 16px;">ð</div>
        <h3>No jobs in queue</h3>
        <p>Scan Gmail or add jobs manually to get started</p>
        <p style="font-size: 12px; margin-top: 8px;">Current applications: ${state.applications?.length || 0}</p>
      </div>
    `;
    return;
  }
  
  // Create table header (optimized for benefits column)
  const tableHTML = `
    <div style="display: grid; grid-template-columns: 30px 2fr 60px 80px 120px 100px 70px 80px; gap: 6px; padding: 10px 12px; background: var(--glass-bg); border-bottom: 1px solid var(--line); font-weight: 600; font-size: 12px;">
      <div>â</div>
      <div>Company & Role</div>
      <div style="text-align: center;">Source</div>
      <div style="text-align: center;">Salary</div>
      <div style="text-align: center;">Benefits</div>
      <div style="text-align: center;">Location</div>
      <div style="text-align: center;">Status</div>
      <div style="text-align: center;">Actions</div>
    </div>
    <div id="jobQueueRows">
      ${jobs.map(job => renderJobRow(job)).join('')}
    </div>
  `;
  
  container.innerHTML = tableHTML;
}

/**
 * Generate confidence indicator badge
 */
function getConfidenceIndicator(confidence, fieldName) {
  const colors = {
    'high': { emoji: 'ð¢', bg: '#dcfce7', text: '#166534', tooltip: 'High confidence - verified from structured data' },
    'medium': { emoji: 'ð¡', bg: '#fef3c7', text: '#92400e', tooltip: 'Medium confidence - extracted from patterns' },
    'low': { emoji: 'ð´', bg: '#fee2e2', text: '#991b1b', tooltip: 'Low confidence - needs review' },
    'none': { emoji: 'âª', bg: '#f3f4f6', text: '#6b7280', tooltip: 'Not found' }
  };
  
  const color = colors[confidence] || colors.none;
  
  return `<span 
    style="
      display: inline-block; 
      font-size: 10px; 
      padding: 2px 4px; 
      border-radius: 3px; 
      background: ${color.bg}; 
      color: ${color.text};
      margin-left: 4px;
      cursor: help;
    " 
    title="${color.tooltip}"
  >${color.emoji}</span>`;
}

function renderJobRow(job) {
  const statusColor = getStatusColor(job.status);
  const roleTitle = (job.role || '').trim();
  const grade = state.roleGrades[roleTitle] || 'ungraded';
  const gradeColors = {
    'A': { bg: '#16a34a', text: 'white' },
    'B': { bg: '#ea580c', text: 'white' },
    'C': { bg: '#dc2626', text: 'white' },
    'ungraded': { bg: '#6b7280', text: 'white' }
  };
  const roleColor = gradeColors[grade];
  
  // Determine source from job data
  const source = job.source || (job.notes ? job.notes.replace('Found via ', '').replace(' job alert', '') : 'Unknown');
  
  // Get confidence indicators if available
  const hasMetadata = job._meta && job._meta.overallConfidence;
  const companyConfidence = hasMetadata ? job._meta.company.confidence : 'none';
  const roleConfidence = hasMetadata ? job._meta.role.confidence : 'none';
  const locationConfidence = hasMetadata ? job._meta.location.confidence : 'none';
  const salaryConfidence = hasMetadata ? job._meta.salary.confidence : 'none';
  const overallConfidence = hasMetadata ? job._meta.overallConfidence : 'none';
  
  return `
    <div style="display: grid; grid-template-columns: 30px 2fr 60px 80px 120px 100px 70px 80px; gap: 6px; padding: 8px 12px; border-bottom: 1px solid var(--line); align-items: center; font-size: 12px;">
      <div>
        <input type="checkbox" onchange="updateSelectedCount()" data-job-id="${job.id}" style="width: 14px; height: 14px;">
      </div>
      <div style="min-width: 0;">
        <div style="font-weight: 600; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; gap: 4px;">
          <span style="flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
            ${job.company}
            ${hasMetadata ? getConfidenceIndicator(companyConfidence, 'company') : ''}
          </span>
          <button 
            onclick="blockEmployer('${job.company.replace(/'/g, "\\'")}')" 
            style="
              background: #6b7280; 
              color: white; 
              border: none; 
              width: 12px; 
              height: 12px; 
              border-radius: 50%; 
              font-size: 8px; 
              cursor: pointer;
              display: inline-flex;
              align-items: center;
              justify-content: center;
              flex-shrink: 0;
              padding: 0;
              margin: 0;
              line-height: 1;
              min-width: 12px;
              max-width: 12px;
            "
            title="Block this employer (never see jobs from them again)"
          >Ã</button>
        </div>
        <div style="display: flex; align-items: center; gap: 4px;">
        <button 
          onclick="cycleRoleGrade('${roleTitle.replace(/'/g, "\\'")}')" 
          style="
            background: ${roleColor.bg}; 
            color: ${roleColor.text}; 
            border: none; 
            padding: 3px 8px; 
            border-radius: 4px; 
            font-size: 10px; 
            cursor: pointer;
            transition: opacity 0.2s;
            white-space: normal;
            word-wrap: break-word;
            height: auto;
            min-height: 20px;
            display: inline-block;
            text-align: center;
          "
          onmouseover="this.style.opacity='0.8'"
          onmouseout="this.style.opacity='1'"
          title="Click to cycle grade: ${grade === 'ungraded' ? 'Not graded' : 'Grade ' + grade}"
        >${job.role}</button>
          ${hasMetadata ? getConfidenceIndicator(roleConfidence, 'role') : ''}
        </div>
      </div>
      <div style="text-align: center; color: var(--muted); font-size: 11px;">
        ${source}
        ${hasMetadata ? `<div style="margin-top: 2px; font-size: 9px;">${getConfidenceIndicator(overallConfidence, 'overall')}</div>` : ''}
      </div>
      <div style="text-align: center; color: var(--muted); font-size: 11px;">
        ${job.salary || 'N/A'}
        ${hasMetadata && job.salary ? getConfidenceIndicator(salaryConfidence, 'salary') : ''}
      </div>
      <div style="text-align: center; color: var(--muted); font-size: 10px; max-height: 40px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; line-height: 1.2;" title="${job.benefits || 'No benefits listed'}">
        ${job.benefits ? (job.benefits.length > 50 ? job.benefits.substring(0, 47) + '...' : job.benefits) : 'N/A'}
      </div>
            <div style="text-align: center;">
              ${job.location ? (() => {
                const city = job.location.split(',')[0].trim();
                const grade = state.cityGrades[city] || 'ungraded';
                const gradeColors = {
                  'A': { bg: '#16a34a', text: 'white' },
                  'B': { bg: '#ea580c', text: 'white' },
                  'C': { bg: '#dc2626', text: 'white' },
                  'ungraded': { bg: '#6b7280', text: 'white' }
                };
                const color = gradeColors[grade];
                
                return `<div style="display: flex; align-items: center; gap: 4px; justify-content: center;">
                  <button 
                    onclick="cycleCityGrade('${city.replace(/'/g, "\\'")}')" 
                    data-city="${city}"
                    style="
                      background: ${color.bg}; 
                      color: ${color.text}; 
                      border: none; 
                      padding: 3px 8px; 
                      border-radius: 4px; 
                      font-size: 10px; 
                      cursor: pointer;
                      transition: opacity 0.2s;
                      white-space: normal;
                      word-wrap: break-word;
                      height: auto;
                      min-height: 20px;
                      display: inline-block;
                      text-align: center;
                    "
                    onmouseover="this.style.opacity='0.8'"
                    onmouseout="this.style.opacity='1'"
                    title="Click to cycle grade: ${grade === 'ungraded' ? 'Not graded' : 'Grade ' + grade}"
                  >${city}</button>
                  ${hasMetadata ? getConfidenceIndicator(locationConfidence, 'location') : ''}
                  <button 
                    onclick="blockCity('${city.replace(/'/g, "\\'")}')" 
                    style="
                      background: #dc2626; 
                      color: white; 
                      border: none; 
                      width: 12px; 
                      height: 12px; 
                      border-radius: 50%; 
                      font-size: 8px; 
                      cursor: pointer;
                      display: inline-flex;
                      align-items: center;
                      justify-content: center;
                      flex-shrink: 0;
                      padding: 0;
                      margin: 0;
                      line-height: 1;
                      min-width: 12px;
                      max-width: 12px;
                    "
                    title="Block this city (never see jobs from here again)"
                  >Ã</button>
                </div>`;
              })() : 'N/A'}
            </div>
      <div style="text-align: center;">
        <span style="background: ${statusColor}; color: white; padding: 3px 6px; border-radius: 10px; font-size: 10px;">
          ${job.status}
        </span>
      </div>
      <div style="display: flex; gap: 4px; justify-content: center;">
        <button class="icon-btn" onclick="viewJobDetails('${job.id}')" title="View job details and link" style="font-size: 14px;">ðï¸</button>
        <button class="icon-btn" onclick="deleteJob('${job.id}')" title="Remove from queue" style="font-size: 14px;">ðï¸</button>
      </div>
    </div>
  `;
}

function calculateJobScore(job) {
  // Primary scoring based on role grade (manual user grading)
  const roleTitle = (job.role || '').trim();
  const grade = state.roleGrades[roleTitle];
  
  let score = 50; // Base score for ungraded roles
  
  // Grade-based scoring (most important factor)
  if (grade === 'A') {
    score = 85; // Excellent fit
  } else if (grade === 'B') {
    score = 65; // Moderate fit
  } else if (grade === 'C') {
    score = 35; // Low fit
  }
  
  // Small bonus for tech companies (if available)
  if (job.company) {
    const company = job.company.toLowerCase();
    if (company.includes('tech') || company.includes('saas') || company.includes('software')) {
      score += 5;
    }
  }
  
  // Status-based bonus
  if (job.status === 'pipeline') score += 5;
  if (job.status === 'sent') score += 10;
  if (job.status === 'interview') score += 15;
  
  return Math.min(100, Math.max(0, score));
}

function getJobPriority(job) {
  const score = calculateJobScore(job);
  if (score >= 80) return 'Hot';
  if (score >= 60) return 'High';
  if (score >= 40) return 'Medium';
  return 'Low';
}

function getPriorityColor(priority) {
  const colors = {
    'Hot': 'var(--bad)',
    'High': 'var(--warn)',
    'Medium': 'var(--accent)',
    'Low': 'var(--muted)'
  };
  return colors[priority] || 'var(--muted)';
}

function getStatusColor(status) {
  const colors = {
    'queued': 'var(--muted)',
    'tailoring': 'var(--warn)',
    'ready': 'var(--accent)',
    'sent': 'var(--ok)',
    'interview': 'var(--accent)',
    'rejected': 'var(--bad)',
    'offer': 'var(--ok)'
  };
  return colors[status] || 'var(--muted)';
}

function getScoreColor(score) {
  if (score >= 80) return 'var(--ok)';
  if (score >= 60) return 'var(--warn)';
  return 'var(--bad)';
}

// Google OAuth Functions (for Sheets only)
function configureGoogleAuth() {
  const clientId = document.getElementById('google-client-id').value.trim();
  
  if (!clientId) {
    alert('Please enter your Google Client ID first');
    return;
  }
  
  // Store client ID
  state.google.clientId = clientId;
  saveToFirebase();
  
  // Initialize Google Identity Services
  if (typeof google !== 'undefined' && google.accounts) {
    google.accounts.oauth2.initTokenClient({
      client_id: clientId,
      scope: 'https://www.googleapis.com/auth/spreadsheets',
      callback: (response) => {
        if (response.access_token) {
          state.google.accessToken = response.access_token;
          state.google.connected = true;
          state.google.lastConnected = new Date().toISOString();
          saveToFirebase();
          updateGoogleAuthUI();
          alert('â Google authentication successful! You can now use Google Sheets sync.');
        } else {
          alert('â Google authentication failed. Please try again.');
        }
      }
    }).requestAccessToken();
  } else {
    alert('Google Identity Services not loaded. Please refresh the page and try again.');
  }
}

function disconnectGoogle() {
  if (confirm('Disconnect Google authentication?\n\nThis will disable Google Sheets sync until you reconnect.')) {
    state.google.connected = false;
    state.google.accessToken = null;
    state.google.lastConnected = null;
    state.sheets.spreadsheetId = null;
    state.sheets.spreadsheetUrl = null;
    state.sheets.lastSync = null;
    saveToFirebase();
    updateGoogleAuthUI();
    updateSheetsUI();
    alert('Google authentication disconnected.');
  }
}

function updateGoogleAuthUI() {
  const statusEl = document.getElementById('google-auth-status');
  const clientIdInput = document.getElementById('google-client-id');
  
  if (state.google.clientId) {
    clientIdInput.value = state.google.clientId;
  }
  
  if (state.google.connected) {
    statusEl.innerHTML = 'â Connected to Google<br><small>Sheets sync enabled</small>';
    statusEl.style.color = 'var(--ok)';
  } else if (state.google.clientId) {
    statusEl.innerHTML = 'â ï¸ Not connected<br><small>Click "Configure Google Auth" to connect</small>';
    statusEl.style.color = 'var(--warn)';
  } else {
    statusEl.innerHTML = 'â Not configured<br><small>Enter Client ID and click "Configure Google Auth"</small>';
    statusEl.style.color = 'var(--muted)';
  }
}

// Google Sheets Integration Functions
function resetSpreadsheet() {
  if (confirm('Reset spreadsheet connection?\n\nThis will disconnect the current sheet and let you create a new one. Your app data is safe.')) {
    if (confirm('Are you sure? This will break the link to your existing Google Sheet.\n\nYou can always reconnect to the same sheet later if needed.')) {
      state.sheets.spreadsheetId = null;
      state.sheets.spreadsheetUrl = null;
      state.sheets.lastSync = null;
      saveToFirebase();
      updateSheetsUI();
      alert('Spreadsheet connection reset! Click "Create Spreadsheet" to start fresh.');
    }
  }
}

async function initializeSpreadsheet() {
  if (!state.google.connected) {
    alert('Please configure Google authentication first to use Google Sheets');
    return;
  }
  
  // Ensure Sheets API is loaded
  if (!gapi || !gapi.client || !gapi.client.sheets) {
    console.log('Google Sheets API not ready, attempting to load...');
    
    // Try to initialize Google APIs if not already done
    if (!gapiInited) {
      try {
        await initGoogleAPI();
        console.log('â Google APIs loaded successfully');
      } catch (error) {
        console.error('Failed to load Google APIs:', error);
        alert('Failed to load Google APIs. Please refresh the page and try again.');
        return;
      }
    }
    
    // Check again after initialization
    if (!gapi || !gapi.client || !gapi.client.sheets) {
      alert('Google Sheets API still not loaded. Please refresh the page and try again.');
      console.error('Sheets API not ready after initialization:', { gapi: !!gapi, client: !!gapi?.client, sheets: !!gapi?.client?.sheets });
      return;
    }
  }
  
  try {
    // Check if spreadsheet already exists and is accessible
    if (state.sheets.spreadsheetId) {
      try {
        const response = await gapi.client.sheets.spreadsheets.get({
          spreadsheetId: state.sheets.spreadsheetId
        });
        console.log('Existing spreadsheet found:', response.result.properties.title);
        alert('Spreadsheet already connected!\n\nClick "Open Sheet" to view it.\n\nTo create a new sheet, use "Reset Sheet Connection" first.');
        return state.sheets.spreadsheetId;
      } catch (error) {
        // Spreadsheet not accessible (deleted/trashed), clear the ID
        console.log('Spreadsheet not accessible, creating new one...');
        state.sheets.spreadsheetId = null;
        state.sheets.spreadsheetUrl = null;
      }
    }
    
    // Create new spreadsheet
    const response = await gapi.client.sheets.spreadsheets.create({
      properties: {
        title: 'Career Chute - Job Applications'
      },
      sheets: [{
        properties: {
          title: 'Job Queue',
          gridProperties: {
            frozenRowCount: 1
          }
        }
      }]
    });
    
    const spreadsheetId = response.result.spreadsheetId;
    const spreadsheetUrl = response.result.spreadsheetUrl;
    
    state.sheets.spreadsheetId = spreadsheetId;
    state.sheets.spreadsheetUrl = spreadsheetUrl;
    state.sheets.enabled = true;
    
    // Add header row with ID column first
    await gapi.client.sheets.spreadsheets.values.update({
      spreadsheetId: spreadsheetId,
      range: 'Job Queue!A1:O1',
      valueInputOption: 'RAW',
      resource: {
        values: [[
          'ID',
          'Company',
          'Role',
          'Source',
          'Salary',
          'Benefits',
          'Location',
          'Status',
          'Added to Queue',
          'Added to Pipeline',
          'Application Sent',
          'Notes',
          'URL'
        ]]
      }
    });
    
    saveToFirebase();
    updateSheetsUI();
    console.log('Spreadsheet created:', spreadsheetUrl);
    alert(`Spreadsheet created!\n\nOpen it here:\n${spreadsheetUrl}`);
    
    return spreadsheetId;
  } catch (error) {
    console.error('Error initializing spreadsheet:', error);
    alert('Failed to create spreadsheet: ' + (error.result?.error?.message || error.message));
  }
}

async function syncToGoogleSheets() {
  if (!state.gmail.connected) {
    alert('Please connect Gmail first');
    return;
  }
  
  try {
    // Initialize spreadsheet if needed
    if (!state.sheets.spreadsheetId) {
      await initializeSpreadsheet();
    }
    
    // Sync both jobs and contacts
    console.log('Syncing jobs to Google Sheets...');
    await syncJobsToGoogleSheets();
    
    console.log('Syncing contacts to Google Sheets...');
    await syncContactsToGoogleSheets();
    
    console.log('â Synced all data to Google Sheets');
    updateSheetsUI();
    
    // Show success message with details
    const jobCount = state.applications.filter(app => app.status !== 'queued').length;
    const contactCount = state.contacts.length;
    alert(`â Synced to Google Sheets!\n\nð Jobs: ${jobCount} applications\nð¥ Contacts: ${contactCount} networking contacts\n\nCheck your spreadsheet for the "Networking Contacts" tab.`);
  } catch (error) {
    console.error('Error syncing to Google Sheets:', error);
    alert('Failed to sync: ' + (error.result?.error?.message || error.message));
  }
}

async function syncJobsToGoogleSheets() {
  // Only sync jobs that are in pipeline (not queued)
  const pipelineJobs = state.applications.filter(app => app.status !== 'queued');
  
  if (pipelineJobs.length === 0) {
    console.log('No pipeline jobs to sync');
    return;
  }
  
  try {
    // Read existing sheet data to find rows by ID
    const existingData = await gapi.client.sheets.spreadsheets.values.get({
      spreadsheetId: state.sheets.spreadsheetId,
      range: 'Job Queue!A2:O1000' // Read up to 1000 rows
    });
    
    const existingRows = existingData.result.values || [];
    const existingIds = new Map(); // Map ID to row number
    
    existingRows.forEach((row, index) => {
      if (row[0]) { // If ID exists
        existingIds.set(row[0], index + 2); // +2 because: 0-indexed + header row
      }
    });
    
    let updatedCount = 0;
    let addedCount = 0;
    
    // Process each pipeline job
    for (const app of pipelineJobs) {
      // Determine source from job data
      const source = app.source || (app.notes ? app.notes.replace('Found via ', '').replace(' job alert', '') : 'Unknown');
      
      const rowData = [
        app.id,
        app.company || '',
        app.role || '',
        source,
        app.salary || '',
        app.benefits || '',
        app.location || '',
        app.status || '',
        app.addedToQueue ? formatDateTime(app.addedToQueue, true) : '',
        app.addedToPipeline ? formatDateTime(app.addedToPipeline, true) : '',
        app.appliedDate ? formatDate(app.appliedDate) : '',
        app.notes || '',
        app.url || ''
      ];
      
      if (existingIds.has(app.id)) {
        // Update existing row
        const rowNumber = existingIds.get(app.id);
        await gapi.client.sheets.spreadsheets.values.update({
          spreadsheetId: state.sheets.spreadsheetId,
          range: `Job Queue!A${rowNumber}:O${rowNumber}`,
          valueInputOption: 'RAW',
          resource: { values: [rowData] }
        });
        updatedCount++;
      } else {
        // Append new row
        await gapi.client.sheets.spreadsheets.values.append({
          spreadsheetId: state.sheets.spreadsheetId,
          range: 'Job Queue!A2:O2',
          valueInputOption: 'RAW',
          insertDataOption: 'INSERT_ROWS',
          resource: { values: [rowData] }
        });
        addedCount++;
      }
    }
    
    state.sheets.lastSync = new Date().toISOString();
    saveToFirebase();
    
    console.log(`Synced to Sheets: ${addedCount} added, ${updatedCount} updated`);
    alert(`â Synced to Sheets!\n\nð Added: ${addedCount} new\nð Updated: ${updatedCount} existing\n\nOnly pipeline jobs are synced.`);
  } catch (error) {
    console.error('Error syncing to Google Sheets:', error);
    alert('Failed to sync: ' + (error.result?.error?.message || error.message));
  }
}

async function syncContactsToGoogleSheets() {
  if (!state.gmail.connected) {
    console.log('Gmail not connected, skipping contacts sync');
    return;
  }
  
  try {
    console.log('Starting contacts sync to Google Sheets...');
    
    // Initialize spreadsheet if needed
    if (!state.sheets.spreadsheetId) {
      console.log('No spreadsheet ID, initializing...');
      await initializeSpreadsheet();
    }
    
    console.log('Getting spreadsheet info...');
    // Create Contacts sheet if it doesn't exist
    const spreadsheet = await gapi.client.sheets.spreadsheets.get({
      spreadsheetId: state.sheets.spreadsheetId
    });
    
    const hasContactsSheet = spreadsheet.result.sheets.some(s => s.properties.title === 'Networking Contacts');
    console.log('Has contacts sheet:', hasContactsSheet);
    
    if (!hasContactsSheet) {
      console.log('Creating Networking Contacts sheet...');
      // Add Contacts sheet
      await gapi.client.sheets.spreadsheets.batchUpdate({
        spreadsheetId: state.sheets.spreadsheetId,
        resource: {
          requests: [{
            addSheet: {
              properties: {
                title: 'Networking Contacts',
                gridProperties: {
                  frozenRowCount: 1
                }
              }
            }
          }]
        }
      });
      
      console.log('Adding header row...');
      // Add header row
      await gapi.client.sheets.spreadsheets.values.update({
        spreadsheetId: state.sheets.spreadsheetId,
        range: 'Networking Contacts!A1:G1',
        valueInputOption: 'RAW',
        resource: {
          values: [[
            'Name',
            'Relationship',
            'Company',
            'LinkedIn Profile',
            'Last Contact',
            'Added Date',
            'Notes'
          ]]
        }
      });
    }
    
    console.log('Preparing contact data...');
    // Prepare contact rows with formatted dates (absolute for spreadsheet)
    const rows = state.contacts.map(contact => [
      contact.name || '',
      contact.relationship || '',
      contact.company || '',
      contact.linkedin || '',
      contact.lastContact ? formatDate(contact.lastContact) : '',
      contact.addedDate ? formatDateTime(contact.addedDate, true) : '',
      contact.notes || ''
    ]);
    
    console.log('Contact rows prepared:', rows.length);
    
    if (rows.length > 0) {
      console.log('Updating spreadsheet with contact data...');
      // Update spreadsheet
      await gapi.client.sheets.spreadsheets.values.update({
        spreadsheetId: state.sheets.spreadsheetId,
        range: 'Networking Contacts!A2:G' + (rows.length + 1),
        valueInputOption: 'RAW',
        resource: {
          values: rows
        }
      });
      console.log('â Successfully synced', rows.length, 'contacts to Google Sheets');
    
    // Show success message if called directly (not from main sync)
    if (arguments.callee.caller && arguments.callee.caller.name !== 'syncToGoogleSheets') {
      alert(`â Synced ${rows.length} contacts to Google Sheets!\n\nCheck your spreadsheet for the "Networking Contacts" tab.`);
    }
    } else {
      console.log('No contacts to sync');
      if (arguments.callee.caller && arguments.callee.caller.name !== 'syncToGoogleSheets') {
        alert('No contacts to sync. Add some contacts first!');
      }
    }
  } catch (error) {
    console.error('â Error syncing contacts to Google Sheets:', error);
    // Re-throw the error so it can be caught by the calling function
    throw error;
  }
}

function openJobUrl(appId) {
  const app = state.applications.find(a => a.id === appId);
  if (!app) return;
  
  if (!app.url || app.url.trim() === '') {
    alert('No URL available for this job posting.');
    return;
  }
  
  const validation = isValidUrl(app.url);
  if (!validation.isValid) {
    // Prompt user to fix the URL
    const newUrl = promptForValidUrl(app.url, app.company, app.role);
    if (newUrl !== null) {
      app.url = newUrl;
      saveToFirebase();
      renderPlanScreen(); // Refresh the UI
      
      if (newUrl) {
        window.open(newUrl, '_blank');
      }
    }
  } else {
    // URL is valid, open it
    window.open(app.url, '_blank');
  }
}

function openSpreadsheet() {
  if (state.sheets.spreadsheetUrl) {
    window.open(state.sheets.spreadsheetUrl, '_blank');
  } else {
    alert('No spreadsheet configured yet. Click "Create Spreadsheet" first.');
  }
}

// CSV Import Functions
function showCSVImport() {
  document.getElementById('csvImportModal').style.display = 'flex';
}

function closeCSVImport() {
  document.getElementById('csvImportModal').style.display = 'none';
  document.getElementById('csvData').value = '';
}

function copyPrompt() {
  const promptText = document.getElementById('claudePrompt');
  promptText.select();
  document.execCommand('copy');
  alert('Claude prompt copied to clipboard!');
}

function importCSVData() {
  let csvData = document.getElementById('csvData').value.trim();
  
  if (!csvData) {
    alert('Please paste CSV data from Claude first.');
    return;
  }
  
  // Remove markdown code block delimiters if present
  csvData = csvData.replace(/^```csv\s*\n?/i, '').replace(/\n?```\s*$/, '');
  
  try {
    const lines = csvData.split('\n').filter(line => line.trim() !== '');
    if (lines.length < 2) {
      alert('CSV data must have at least a header row and one data row.');
      return;
    }
    
    // Parse header using proper CSV parsing
    const headers = parseCSVLine(lines[0]).map(h => h.trim().toLowerCase());
    const expectedHeaders = ['company', 'role', 'location', 'salary', 'url', 'benefits', 'source', 'notes'];
    
    console.log('Parsed headers:', headers);
    console.log('Expected headers:', expectedHeaders);
    
    // Check if headers match
    const missingHeaders = expectedHeaders.filter(h => !headers.includes(h));
    if (missingHeaders.length > 0) {
      alert(`Missing required columns: ${missingHeaders.join(', ')}\n\nExpected: ${expectedHeaders.join(', ')}\n\nFound: ${headers.join(', ')}`);
      return;
    }
    
    let imported = 0;
    let duplicates = 0;
    let errors = 0;
    
    // Process each data row
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      
      try {
        const values = parseCSVLineRobust(line);
        if (values.length !== headers.length) {
          console.warn(`Row ${i + 1}: Column count mismatch`);
          errors++;
          continue;
        }
        
        // Create job object
        const job = {
          id: generateId(),
          company: values[headers.indexOf('company')] || '',
          role: values[headers.indexOf('role')] || '',
          location: values[headers.indexOf('location')] || '',
          salary: values[headers.indexOf('salary')] || '',
          url: values[headers.indexOf('url')] || '',
          benefits: values[headers.indexOf('benefits')] || '',
          source: values[headers.indexOf('source')] || 'CSV Import',
          notes: values[headers.indexOf('notes')] || '',
          status: 'pipeline',
          dateApplied: null,
          priority: 'medium',
          createdAt: new Date().toISOString(),
          addedToPipeline: new Date().toISOString()
        };
        
        // Check for duplicates
        const isDuplicate = state.applications.some(app => 
          app.company.toLowerCase() === job.company.toLowerCase() && 
          app.role.toLowerCase() === job.role.toLowerCase()
        );
        
        if (isDuplicate) {
          duplicates++;
        } else {
          state.applications.push(job);
          imported++;
        }
        
      } catch (error) {
        console.error(`Error processing row ${i + 1}:`, error);
        errors++;
      }
    }
    
    // Save and update UI
    saveToFirebase();
    renderApplications();
    closeCSVImport();
    
    // Show results
    let message = `â Import Complete!\n\nð¥ Imported: ${imported} jobs\n`;
    if (duplicates > 0) message += `ð Duplicates: ${duplicates} jobs\n`;
    if (errors > 0) message += `â Errors: ${errors} rows\n`;
    
    alert(message);
    
  } catch (error) {
    console.error('CSV import error:', error);
    alert('Error importing CSV data: ' + error.message);
  }
}

function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      result.push(current.trim());
      current = '';
    } else {
      current += char;
    }
  }
  
  result.push(current.trim());
  
  // Debug logging
  console.log('Parsed line:', line);
  console.log('Result:', result);
  console.log('Column count:', result.length);
  
  return result;
}

// Alternative CSV parsing for unquoted fields with commas
function parseCSVLineRobust(line) {
  // First try the standard parsing
  const standardResult = parseCSVLine(line);
  
  // If we get the expected number of columns, return it
  if (standardResult.length === 8) {
    return standardResult;
  }
  
  // If we have more columns than expected, try to intelligently merge
  if (standardResult.length > 8) {
    console.log('Too many columns, attempting to merge...');
    console.log('Original split:', standardResult);
    
    // The issue is likely that benefits field has unquoted commas
    // We need to reconstruct the proper 8 columns
    const result = [
      standardResult[0], // company
      standardResult[1], // role  
      standardResult[2], // location
      standardResult[3], // salary
      standardResult[4], // url
      '', // benefits - we'll reconstruct this
      '', // source - we'll reconstruct this
      ''  // notes - we'll reconstruct this
    ];
    
    // Merge the middle parts into benefits
    const middleParts = standardResult.slice(5, standardResult.length - 2);
    result[5] = middleParts.join(', '); // benefits
    
    // The last two parts should be source and notes
    if (standardResult.length >= 7) {
      result[6] = standardResult[standardResult.length - 2]; // source
      result[7] = standardResult[standardResult.length - 1]; // notes
    }
    
    console.log('Merged result:', result);
    return result;
  }
  
  return standardResult;
}

// CSV Import from Add Application Modal
function importFromCSVText() {
  let csvData = document.getElementById('csvImportText').value.trim();
  
  if (!csvData) {
    alert('Please paste CSV data first.');
    return;
  }
  
  // Remove markdown code block delimiters if present
  csvData = csvData.replace(/^```csv\s*\n?/i, '').replace(/\n?```\s*$/, '');
  
  try {
    const lines = csvData.split('\n').filter(line => line.trim() !== '');
    if (lines.length < 2) {
      alert('CSV data must have at least a header row and one data row.');
      return;
    }
    
    // Parse header using proper CSV parsing
    const headers = parseCSVLine(lines[0]).map(h => h.trim().toLowerCase());
    const expectedHeaders = ['company', 'role', 'location', 'salary', 'url', 'benefits', 'source', 'notes'];
    
    console.log('Parsed headers:', headers);
    console.log('Expected headers:', expectedHeaders);
    
    // Check if headers match
    const missingHeaders = expectedHeaders.filter(h => !headers.includes(h));
    if (missingHeaders.length > 0) {
      alert(`Missing required columns: ${missingHeaders.join(', ')}\n\nExpected: ${expectedHeaders.join(', ')}\n\nFound: ${headers.join(', ')}`);
      return;
    }
    
    let imported = 0;
    let duplicates = 0;
    let errors = 0;
    
    // Process each data row
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      
      try {
        const values = parseCSVLineRobust(line);
        if (values.length !== headers.length) {
          console.warn(`Row ${i + 1}: Column count mismatch`);
          errors++;
          continue;
        }
        
        // Create job object
        const job = {
          id: generateId(),
          company: values[headers.indexOf('company')] || '',
          role: values[headers.indexOf('role')] || '',
          location: values[headers.indexOf('location')] || '',
          salary: values[headers.indexOf('salary')] || '',
          url: values[headers.indexOf('url')] || '',
          benefits: values[headers.indexOf('benefits')] || '',
          source: values[headers.indexOf('source')] || 'CSV Import',
          notes: values[headers.indexOf('notes')] || '',
          status: 'pipeline',
          dateApplied: null,
          priority: 'medium',
          createdAt: new Date().toISOString(),
          addedToPipeline: new Date().toISOString()
        };
        
        // Check for duplicates
        const isDuplicate = state.applications.some(app => 
          app.company.toLowerCase() === job.company.toLowerCase() && 
          app.role.toLowerCase() === job.role.toLowerCase()
        );
        
        if (isDuplicate) {
          duplicates++;
        } else {
          state.applications.push(job);
          imported++;
        }
        
      } catch (error) {
        console.error(`Error processing row ${i + 1}:`, error);
        errors++;
      }
    }
    
    // Save and update UI
    saveToFirebase();
    renderPlanScreen();
    closeModal('addAppModal');
    clearCSVText();
    
    // Show brief success message
    alert(`â Success! Imported ${imported} jobs${duplicates > 0 ? ` (${duplicates} duplicates skipped)` : ''}`);
    
  } catch (error) {
    console.error('CSV import error:', error);
    alert('Error importing CSV data: ' + error.message);
  }
}

function clearCSVText() {
  document.getElementById('csvImportText').value = '';
}

function updateSheetsUI() {
  const statusText = document.getElementById('sheetsStatusText');
  const openBtn = document.getElementById('openSheetBtn');
  const lastSyncEl = document.getElementById('sheetsLastSync');
  
  if (!state.google.connected) {
    statusText.textContent = 'â Google Auth Required';
    statusText.style.color = 'var(--bad)';
    if (openBtn) openBtn.style.display = 'none';
    if (lastSyncEl) lastSyncEl.textContent = 'Connect Google below to enable Sheets sync';
  } else if (state.sheets.enabled && state.sheets.spreadsheetId) {
    statusText.textContent = 'â Connected';
    statusText.style.color = 'var(--ok)';
    if (openBtn) openBtn.style.display = 'inline-block';
    
    if (state.sheets.lastSync && lastSyncEl) {
      const lastSync = new Date(state.sheets.lastSync);
      lastSyncEl.textContent = `Last synced: ${lastSync.toLocaleString()}`;
    }
  } else {
    statusText.textContent = 'â ï¸ Not Connected';
    statusText.style.color = 'var(--warn)';
    if (openBtn) openBtn.style.display = 'none';
    if (lastSyncEl) lastSyncEl.textContent = 'Click "Create Spreadsheet" to get started';
  }
}

async function scanJobAlerts() {
  if (!state.gmail.connected) {
    alert('Please connect Gmail first');
    return;
  }
  
  // Check if token is expired and refresh if needed
  if (state.gmail.tokenExpiry && Date.now() > state.gmail.tokenExpiry) {
    console.log('Gmail token expired, attempting to refresh...');
    try {
      await refreshGmailToken();
    } catch (error) {
      console.error('Token refresh failed:', error);
      alert('Gmail session expired. Please reconnect Gmail.');
      disconnectGmail();
      return;
    }
  }
  
  // Make sure Gmail API is loaded
  if (!gapi || !gapi.client || !gapi.client.gmail) {
    console.log('Gmail API not ready, attempting to reinitialize...');
    try {
      await initGoogleAPI();
      // Wait a moment for initialization
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      if (!gapi.client.gmail) {
        alert('Gmail API still not ready. Please:\n1. Disconnect and reconnect Gmail\n2. Wait a moment after connecting\n3. Try scanning again');
        return;
      }
    } catch (error) {
      console.error('Failed to reinitialize Gmail API:', error);
      alert('Gmail API not ready. Please:\n1. Disconnect and reconnect Gmail\n2. Wait a moment after connecting\n3. Try scanning again');
      return;
    }
  }
  
  try {
    // Show progress
    const scanBtn = document.getElementById('scanEmailsBtn');
    const originalText = scanBtn.textContent;
    scanBtn.textContent = 'ð Scanning...';
    scanBtn.disabled = true;
    
    // Set the access token for the API call
    gapi.client.setToken({
      access_token: state.gmail.accessToken
    });
    
    // Search for job alert emails from the last 7 days (expanded sources)
    // Search for job alert emails - start with unread, then fall back to older emails
    let query = 'from:(linkedin.com OR indeed.com OR glassdoor.com OR greenhouse.io OR lever.co OR ziprecruiter.com OR angel.co OR remote.co OR weworkremotely.com) subject:(job OR hiring OR position OR opportunity OR career) is:unread newer_than:30d';
    
    // If no unread emails, search older emails
    let response = await gapi.client.gmail.users.messages.list({
      userId: 'me',
      q: query,
      maxResults: 50
    });
    
    if (!response.result.messages || response.result.messages.length === 0) {
      console.log('No unread job emails found, searching older emails...');
      query = 'from:(linkedin.com OR indeed.com OR glassdoor.com OR greenhouse.io OR lever.co OR ziprecruiter.com OR angel.co OR remote.co OR weworkremotely.com) subject:(job OR hiring OR position OR opportunity OR career) newer_than:30d';
      response = await gapi.client.gmail.users.messages.list({
        userId: 'me',
        q: query,
        maxResults: 50
      });
    }
    
    const messages = response.result.messages || [];
    console.log(`Found ${messages.length} job alert emails`);
    
    if (messages.length === 0) {
      alert('No job alerts found in the last 7 days.\n\nMake sure you have job alerts set up from:\nâ¢ LinkedIn\nâ¢ Indeed\nâ¢ Greenhouse\nâ¢ Lever');
      scanBtn.textContent = originalText;
      scanBtn.disabled = false;
      return;
    }
    
    let addedCount = 0;
    let duplicateCount = 0;
    let skippedCount = 0;
    let rejectedCount = 0;
    
    // Reset rejected listings tracker
    window._rejectedListings = [];
    
    // Process each message
    for (const message of messages.slice(0, 30)) { // Increased to 30
      const fullMessage = await gapi.client.gmail.users.messages.get({
        userId: 'me',
        id: message.id,
        format: 'full'
      });
      
      // Try to extract multiple listings from HTML
      const headers = fullMessage.result.payload.headers;
      const from = headers.find(h => h.name === 'From')?.value || '';
      
      let htmlBody = '';
      if (fullMessage.result.payload.parts) {
        const htmlPart = fullMessage.result.payload.parts.find(part => part.mimeType === 'text/html');
        if (htmlPart && htmlPart.body.data) {
          htmlBody = atob(htmlPart.body.data.replace(/-/g, '+').replace(/_/g, '/'));
        }
      }
      
      let jobListings = [];
      if (htmlBody) {
        jobListings = extractJobListingsFromHTML(htmlBody, headers.find(h => h.name === 'Subject')?.value || '', from);
        
        // Validate each listing
        jobListings = jobListings.filter(listing => {
          const validation = isValidListing(listing, htmlBody);
          if (!validation.isValid) {
            rejectedCount++;
            return false;
          }
          return true;
        });
      }
      
      // If HTML extraction didn't work, fall back to standard parsing
      if (jobListings.length === 0) {
        const jobData = parseJobEmail(fullMessage.result);
      if (jobData) {
          jobListings = [jobData];
        } else {
          rejectedCount++; // Counted as rejected if returned null
        }
      }
      
      // Process all listings found in this email
      for (const jobData of jobListings) {
        console.log('Parsed job:', jobData.company, '-', jobData.role);
        
        // Check for duplicates
        const isDuplicate = state.applications.some(app => 
          app.company === jobData.company && 
          app.role === jobData.role
        );
        
        if (!isDuplicate) {
          // Check if employer is blocked - skip these
          if (state.blockedEmployers[jobData.company]) {
            console.log('Skipping blocked employer:', jobData.company, '-', jobData.role);
            skippedCount++;
            continue;
          }
          
          // Check if role is marked as Grade C (red) - skip these
          const roleTitle = jobData.role.trim();
          const grade = state.roleGrades[roleTitle];
          
          if (grade === 'C') {
            console.log('Skipping Grade C job:', jobData.company, '-', jobData.role);
            skippedCount++;
            continue;
          }
          
          // Check if city is marked as Grade C (red) - skip these
          if (jobData.location) {
            const city = jobData.location.split(',')[0].trim();
            const cityGrade = state.cityGrades[city];
            const isBlocked = state.blockedCities && state.blockedCities[city];
            
            if (cityGrade === 'C' || isBlocked) {
              console.log('Skipping city job:', jobData.company, '-', jobData.role, 'in', city, 
                         cityGrade === 'C' ? '(Grade C)' : '(Blocked)');
              skippedCount++;
              continue;
            }
          }
          
          // Add to applications
          const newJob = {
            id: 'job_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            ...jobData,
            status: 'pipeline',
            addedToQueue: new Date().toISOString()
            // source will come from jobData (parsed from notes)
          };
          
          state.applications.push(newJob);
          addedCount++;
          
          // Mark email as read
          try {
            await gapi.client.gmail.users.messages.modify({
              userId: 'me',
              id: message.id,
              resource: {
                removeLabelIds: ['UNREAD']
              }
            });
            console.log('Marked email as read:', message.id);
          } catch (error) {
            console.warn('Failed to mark email as read:', error);
          }
        } else {
          duplicateCount++;
        }
      } // End of jobListings loop
      
      // Small delay to avoid rate limits
      await new Promise(resolve => setTimeout(resolve, 100));
    } // End of messages loop
    
    // Save and update UI
    state.gmail.lastScanTime = new Date().toISOString();
    state.gmail.lastScanResults = {
      added: addedCount,
      duplicates: duplicateCount,
      rejected: rejectedCount,
      skipped: skippedCount,
      emailsProcessed: messages.length
    };
    
    // Update parser statistics
    if (!state.parserStats) {
      state.parserStats = {
        totalEmailsProcessed: 0,
        correctionsMade: 0,
        lastScanTime: null,
        accuracyRate: 0
      };
    }
    state.parserStats.totalEmailsProcessed += messages.length;
    state.parserStats.lastScanTime = state.gmail.lastScanTime;
    
    saveToFirebase();
    renderJobQueue();
    updateGmailUI();
    updateParserStats();
    
    // Auto-sync to Google Sheets
    if (state.sheets.enabled && state.sheets.autoSync && addedCount > 0) {
      await syncToGoogleSheets();
    }
    
    // Update prioritization rules UI with new roles and cities
    if (addedCount > 0) {
      renderPrioritizationSettings();
      renderCityGradingSettings();
    }
    
    // Show detailed results
    const blockedEmployerCount = Object.keys(state.blockedEmployers).length;
    const blockedCityCount = Object.keys(state.blockedCities || {}).length;
    const gradeCCount = (state.applications || []).filter(job => {
      const roleTitle = (job.role || '').trim();
      const grade = state.roleGrades[roleTitle];
      return grade === 'C';
    }).length;
    
    let resultsMessage = `â Scan Complete!\n\nð¥ Added: ${addedCount} new jobs\nð Duplicates: ${duplicateCount}\nð§ Emails processed: ${messages.length}`;
    
    if (rejectedCount > 0) {
      resultsMessage += `\nâ Rejected: ${rejectedCount} (invalid listings)`;
    }
    
    if (skippedCount > 0) {
      resultsMessage += `\nâ ï¸  Skipped: ${skippedCount} jobs\n\nð Breakdown:\nâ¢ Blocked employers: ${blockedEmployerCount}\nâ¢ Blocked cities: ${blockedCityCount}\nâ¢ Red grades: ${gradeCCount}`;
    }
    
    if (rejectedCount > 0) {
      resultsMessage += `\n\nð¡ Tip: Open console to view rejected listings\n   Run: viewRejectedListings()`;
    }
    
    alert(resultsMessage);
    
    scanBtn.textContent = originalText;
    scanBtn.disabled = false;
    
  } catch (error) {
    console.error('Error scanning Gmail:', error);
    alert('Failed to scan Gmail: ' + (error.result?.error?.message || error.message));
    
    const scanBtn = document.getElementById('scanEmailsBtn');
    if (scanBtn) {
      scanBtn.textContent = 'Scan for Jobs Now';
      scanBtn.disabled = false;
    }
  }
}

/**
 * View rejected listings (for debugging)
 * Run in console: viewRejectedListings()
 */
function viewRejectedListings() {
  if (!window._rejectedListings || window._rejectedListings.length === 0) {
    console.log('â No rejected listings in last scan!');
    return;
  }
  
  console.log(`\nâ REJECTED LISTINGS (${window._rejectedListings.length})\n${'='.repeat(80)}\n`);
  
  window._rejectedListings.forEach((rejected, index) => {
    console.log(`\n[${index + 1}] From: ${rejected.from}`);
    console.log(`Subject: ${rejected.subject}`);
    console.log(`\nExtracted Data:`);
    console.log(`  Company: "${rejected.extracted.company}"`);
    console.log(`  Role: "${rejected.extracted.role}"`);
    console.log(`  Location: "${rejected.extracted.location || 'N/A'}"`);
    console.log(`  Salary: "${rejected.extracted.salary || 'N/A'}"`);
    console.log(`  URL: "${rejected.extracted.url || 'N/A'}"`);
    console.log(`\nRejection Reasons:`);
    rejected.reasons.forEach(reason => console.log(`  â¢ ${reason}`));
    console.log(`\n${'-'.repeat(80)}`);
  });
  
  console.log(`\nð¡ To export rejected listings:\n   copy(window._rejectedListings)\n`);
}

// Make it globally available
window.viewRejectedListings = viewRejectedListings;

// ============================================
// STRUCTURED PARSING HELPERS (JobSpy-inspired)
// ============================================

/**
 * Parse salary string into structured data with confidence scoring
 * Inspired by JobSpy's compensation parsing approach
 */
function parseStructuredSalary(salaryString, bodyText = '') {
  const result = {
    raw: salaryString || '',
    interval: null,
    min: null,
    max: null,
    currency: 'USD',
    confidence: 'none',
    source: 'not_found'
  };
  
  if (!salaryString) return result;
  
  // Pattern: $80,000 - $100,000 or $80k - $100k
  const rangeMatch = salaryString.match(/\$\s*([\d,]+\.?\d*)\s*k?\s*[-âto]+\s*\$?\s*([\d,]+\.?\d*)\s*k?/i);
  if (rangeMatch) {
    let min = rangeMatch[1].replace(/,/g, '');
    let max = rangeMatch[2].replace(/,/g, '');
    
    // Handle 'k' notation (80k = 80,000)
    if (/k/i.test(salaryString)) {
      min = parseFloat(min) * 1000;
      max = parseFloat(max) * 1000;
    } else {
      min = parseFloat(min);
      max = parseFloat(max);
    }
    
    result.min = min;
    result.max = max;
    result.confidence = 'high';
    result.source = 'direct_data';
  } else {
    // Single value: $80,000 or $80k
    const singleMatch = salaryString.match(/\$\s*([\d,]+\.?\d*)\s*k?/i);
    if (singleMatch) {
      let value = singleMatch[1].replace(/,/g, '');
      if (/k/i.test(salaryString)) {
        value = parseFloat(value) * 1000;
      } else {
        value = parseFloat(value);
      }
      result.min = value;
      result.max = value;
      result.confidence = 'medium';
      result.source = 'direct_data';
    }
  }
  
  // Detect interval from context
  if (result.min || result.max) {
    const avgValue = result.max || result.min;
    
    if (/hour|hr|\/h/i.test(salaryString)) {
      result.interval = 'hourly';
    } else if (/month|monthly|\/mo/i.test(salaryString)) {
      result.interval = 'monthly';
    } else if (/week|weekly|\/wk/i.test(salaryString)) {
      result.interval = 'weekly';
    } else if (/year|annual|yearly|\/yr/i.test(salaryString)) {
      result.interval = 'yearly';
    } else {
      // Infer from amount
      if (avgValue >= 30000) {
        result.interval = 'yearly';
      } else if (avgValue >= 2000) {
        result.interval = 'monthly';
      } else if (avgValue >= 400) {
        result.interval = 'weekly';
      } else if (avgValue < 400) {
        result.interval = 'hourly';
      }
    }
  }
  
  return result;
}

/**
 * Parse location string into structured data
 * Inspired by JobSpy's location parsing approach
 */
function parseStructuredLocation(locationString) {
  const result = {
    raw: locationString || '',
    city: null,
    state: null,
    country: 'USA',
    isRemote: false,
    confidence: 'none'
  };
  
  if (!locationString) return result;
  
  // Check for remote indicators
  if (/\b(remote|work from home|wfh|anywhere)\b/i.test(locationString)) {
    result.isRemote = true;
    result.confidence = 'high';
    
    // Still try to extract location if "Remote in California" pattern
    const remoteInMatch = locationString.match(/remote\s+in\s+([^,]+)(?:,\s*([A-Z]{2}))?/i);
    if (remoteInMatch) {
      result.city = remoteInMatch[1]?.trim();
      result.state = remoteInMatch[2]?.trim();
    }
    return result;
  }
  
  // Pattern: "San Francisco, CA" or "New York, NY"
  const cityStateMatch = locationString.match(/^([^,]+),\s*([A-Z]{2})$/);
  if (cityStateMatch) {
    result.city = cityStateMatch[1].trim();
    result.state = cityStateMatch[2].trim();
    result.confidence = 'high';
    return result;
  }
  
  // Pattern: "San Francisco" (city only)
  const cityOnlyMatch = locationString.match(/^([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)$/);
  if (cityOnlyMatch) {
    result.city = cityOnlyMatch[1].trim();
    result.confidence = 'medium';
    return result;
  }
  
  // Pattern: "CA" (state only)
  const stateOnlyMatch = locationString.match(/^([A-Z]{2})$/);
  if (stateOnlyMatch) {
    result.state = stateOnlyMatch[1];
    result.confidence = 'medium';
    return result;
  }
  
  // Fallback: use raw string as city
  result.city = locationString.trim();
  result.confidence = 'low';
  
  return result;
}

/**
 * Normalize job type to standard enum values
 * Inspired by JobSpy's job_type enumeration
 */
function normalizeJobType(rawText) {
  if (!rawText) return null;
  
  const text = rawText.toLowerCase();
  
  if (/full.?time|permanent/i.test(text)) return 'fulltime';
  if (/part.?time/i.test(text)) return 'parttime';
  if (/intern|internship|co-?op/i.test(text)) return 'internship';
  if (/contract|freelance|temp|consultant/i.test(text)) return 'contract';
  
  return null;
}

/**
 * Calculate overall confidence score for a parsed job
 */
function calculateJobConfidence(jobData) {
  let score = 0;
  let maxScore = 0;
  
  // Company (weight: 30)
  if (jobData._meta?.company?.confidence === 'high') score += 30;
  else if (jobData._meta?.company?.confidence === 'medium') score += 20;
  else if (jobData._meta?.company?.confidence === 'low') score += 10;
  maxScore += 30;
  
  // Role (weight: 30)
  if (jobData._meta?.role?.confidence === 'high') score += 30;
  else if (jobData._meta?.role?.confidence === 'medium') score += 20;
  else if (jobData._meta?.role?.confidence === 'low') score += 10;
  maxScore += 30;
  
  // Location (weight: 20)
  if (jobData._meta?.location?.confidence === 'high') score += 20;
  else if (jobData._meta?.location?.confidence === 'medium') score += 13;
  else if (jobData._meta?.location?.confidence === 'low') score += 7;
  maxScore += 20;
  
  // Salary (weight: 10)
  if (jobData._meta?.salary?.confidence === 'high') score += 10;
  else if (jobData._meta?.salary?.confidence === 'medium') score += 6;
  else if (jobData._meta?.salary?.confidence === 'low') score += 3;
  maxScore += 10;
  
  // URL (weight: 10)
  if (jobData._meta?.url?.confidence === 'high') score += 10;
  else if (jobData._meta?.url?.confidence === 'medium') score += 6;
  maxScore += 10;
  
  const percentage = maxScore > 0 ? Math.round((score / maxScore) * 100) : 0;
  
  if (percentage >= 80) return 'high';
  if (percentage >= 50) return 'medium';
  return 'low';
}

// ============================================
// LISTING VALIDATION & QUALITY CONTROL
// ============================================

/**
 * Validate if extracted data represents a real job listing
 * Rejects marketing fluff, incomplete data, and garbage
 */
function isValidListing(listing, emailBody = '') {
  const reasons = [];
  
  // CRITICAL: Must have company and role
  if (!listing.company || listing.company === 'Unknown') {
    reasons.push('No company name found');
    return { isValid: false, reasons, confidence: 'rejected' };
  }
  
  if (!listing.role || listing.role === 'Various Roles') {
    reasons.push('No specific role title found');
    return { isValid: false, reasons, confidence: 'rejected' };
  }
  
  // Blacklist: Marketing/system terms that aren't companies
  const companyBlacklist = [
    /career advisor/i,
    /your coach/i,
    /recruiter team/i,
    /support team/i,
    /phil|zippy|indeed assist/i, // AI mascots
    /unsubscribe/i,
    /click here/i,
    /view (all|more)/i,
    /^(and|or|the|a)\s/i, // Starts with article
  ];
  
  for (const pattern of companyBlacklist) {
    if (pattern.test(listing.company)) {
      reasons.push(`Company name looks like marketing text: "${listing.company}"`);
      return { isValid: false, reasons, confidence: 'rejected' };
    }
  }
  
  // Blacklist: Role titles that are clearly not jobs
  const roleBlacklist = [
    /think this job/i,
    /might be right/i,
    /new job(s)? (at|for)/i,
    /career advisor/i,
    /hi |hello |hey /i, // Greetings
    /^(and|or|the|a)\s/i,
    /unsubscribe/i,
    /click here/i,
    /view details/i,
    /apply now/i,
    /^(welcome|thanks|congratulations)/i,
  ];
  
  for (const pattern of roleBlacklist) {
    if (pattern.test(listing.role)) {
      reasons.push(`Role title looks like marketing text: "${listing.role}"`);
      return { isValid: false, reasons, confidence: 'rejected' };
    }
  }
  
  // Role must contain job-related terms
  const jobTerms = /engineer|developer|manager|analyst|designer|architect|scientist|specialist|coordinator|director|associate|assistant|supervisor|lead|senior|junior|intern|administrator|technician|consultant|representative|officer|operator|worker|assembler|mechanic|driver|nurse|teacher|accountant|sales|marketing|product|project/i;
  
  if (!jobTerms.test(listing.role)) {
    reasons.push(`Role doesn't contain job-related terms: "${listing.role}"`);
    return { isValid: false, reasons, confidence: 'rejected' };
  }
  
  // URL validation (if present)
  if (listing.url) {
    // Reject image URLs
    if (/\.(jpg|jpeg|png|gif|svg|webp)/i.test(listing.url)) {
      reasons.push(`URL is an image file: "${listing.url}"`);
      return { isValid: false, reasons, confidence: 'rejected' };
    }
    
    // Reject unsubscribe/preferences links
    if (/unsubscribe|preferences|settings|profile/i.test(listing.url)) {
      reasons.push(`URL is not a job link: "${listing.url}"`);
      return { isValid: false, reasons, confidence: 'rejected' };
    }
  }
  
  // Location validation: Check for truncated city names
  if (listing.location) {
    // Single word locations without state are suspicious (except known cities)
    const knownCities = /^(remote|austin|boston|chicago|dallas|denver|houston|miami|phoenix|portland|seattle|atlanta|anywhere)$/i;
    const hasState = /,\s*[A-Z]{2}/.test(listing.location);
    const isSingleWord = !/\s/.test(listing.location.trim());
    
    if (isSingleWord && !hasState && !knownCities.test(listing.location)) {
      reasons.push(`Location might be truncated: "${listing.location}" (missing city prefix?)`);
      // Don't reject, just warn
    }
  }
  
  // Company name length check (very short names are suspicious)
  if (listing.company.length < 2) {
    reasons.push(`Company name too short: "${listing.company}"`);
    return { isValid: false, reasons, confidence: 'rejected' };
  }
  
  // Role length check (too short or too long)
  if (listing.role.length < 3) {
    reasons.push(`Role title too short: "${listing.role}"`);
    return { isValid: false, reasons, confidence: 'rejected' };
  }
  
  if (listing.role.length > 150) {
    reasons.push(`Role title too long (probably a paragraph): "${listing.role.substring(0, 50)}..."`);
    return { isValid: false, reasons, confidence: 'rejected' };
  }
  
  // If we got here, it's probably valid
  if (reasons.length > 0) {
    return { isValid: true, reasons, confidence: 'low' }; // Valid but with warnings
  }
  
  return { isValid: true, reasons: [], confidence: 'acceptable' };
}

/**
 * Extract job listings from HTML structure
 * Finds repeating job blocks instead of parsing marketing text
 */
function extractJobListingsFromHTML(htmlBody, subject, from) {
  if (!htmlBody) return [];
  
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlBody, 'text/html');
    const listings = [];
    
    // Strategy 1: Find all links that look like job links
    const potentialJobLinks = doc.querySelectorAll('a[href]');
    const jobLinks = Array.from(potentialJobLinks).filter(link => {
      const href = link.href || '';
      const text = link.textContent || '';
      
      // Must be a real URL
      if (!href.startsWith('http')) return false;
      
      // Exclude marketing links
      if (/unsubscribe|preferences|settings|facebook|twitter|linkedin\.com\/company/i.test(href)) return false;
      
      // Exclude image links
      if (/\.(jpg|jpeg|png|gif|svg)/i.test(href)) return false;
      
      // Include if URL contains job-related terms
      if (/job|apply|career|position|opening|vacancy/i.test(href)) return true;
      
      // Include if link text is job-related
      if (/apply|view job|see details|learn more/i.test(text)) return true;
      
      return false;
    });
    
    console.log(`Found ${jobLinks.length} potential job links in email`);
    
    // For each job link, extract the surrounding context
    for (const link of jobLinks) {
      const listing = extractListingFromContext(link, doc);
      
      if (listing) {
        listing.url = link.href;
        listings.push(listing);
      }
    }
    
    // Remove duplicates (same URL)
    const uniqueListings = [];
    const seenUrls = new Set();
    
    for (const listing of listings) {
      if (!seenUrls.has(listing.url)) {
        seenUrls.add(listing.url);
        uniqueListings.push(listing);
      }
    }
    
    console.log(`Extracted ${uniqueListings.length} unique listings from HTML structure`);
    return uniqueListings;
    
  } catch (error) {
    console.error('Error parsing HTML structure:', error);
    return [];
  }
}

/**
 * Extract listing data from the context around a job link
 */
function extractListingFromContext(linkElement, doc) {
  // Find the container element (usually a <td>, <div>, or <table>)
  let container = linkElement.parentElement;
  let depth = 0;
  
  // Walk up the DOM tree to find a substantial container
  while (container && depth < 8) {
    const text = container.textContent || '';
    
    // Stop if we found a container with enough text (30-1500 chars for LinkedIn)
    if (text.length > 30 && text.length < 1500) {
      break;
    }
    
    container = container.parentElement;
    depth++;
  }
  
  if (!container) {
    console.log('â ï¸  No container found for link');
    return null;
  }
  
  const text = container.textContent || '';
  const html = container.innerHTML || '';
  
  // DEBUG: Log first 200 chars to see what we're working with
  console.log('ð Container text preview:', text.substring(0, 200).replace(/\s+/g, ' '));
  
  // Extract company name - LinkedIn specific patterns
  let company = '';
  const companyPatterns = [
    // "Company Name" (in quotes)
    /"([^"]{3,50})"/,
    // Company at the start of a line followed by newline
    /^([A-Z][A-Za-z0-9\s&,.-]{2,50})\s*\n/m,
    // After "at" or "@"
    /(?:at|@)\s+([A-Z][A-Za-z0-9\s&,.-]{2,50})(?:\s+in|\s+\||$|â¢)/i,
    // In strong/bold tags
    /<(?:strong|b)>([A-Z][A-Za-z0-9\s&,.-]{2,50})<\/(?:strong|b)>/,
    // Second line (often company name on LinkedIn)
    /\n([A-Z][A-Za-z0-9\s&,.-]{2,50})\s*\n/,
    // Before location (City, STATE pattern)
    /([A-Z][A-Za-z0-9\s&,.-]{2,50})\s+[A-Z][a-z]+,\s*[A-Z]{2}/,
  ];
  
  for (const pattern of companyPatterns) {
    const match = text.match(pattern) || html.match(pattern);
    if (match && match[1]) {
      const candidate = match[1].trim();
      // Filter out obvious non-companies
      if (!/^(view|see|apply|learn|more|details|click)/i.test(candidate)) {
        company = candidate;
        console.log('â Found company:', company);
        break;
      }
    }
  }
  
  // Extract role title
  let role = '';
  const roleElement = container.querySelector('h1, h2, h3, h4, h5, h6, strong, b');
  if (roleElement && roleElement.textContent.length > 3 && roleElement.textContent.length < 100) {
    role = roleElement.textContent.trim();
    console.log('â Found role from element:', role);
  } else {
    // Try first substantial line of text
    const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 3 && l.length < 100);
    if (lines.length > 0) {
      // First line is usually the role title
      role = lines[0];
      console.log('â Found role from first line:', role);
    }
  }
  
  // Extract location
  let location = '';
  const locationPatterns = [
    // City, STATE
    /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*,\s*[A-Z]{2})(?:\s|$|â¢|\||Â·)/,
    // "Location:" label
    /(?:location|located in)\s*:?\s*([A-Za-z\s]+,\s*[A-Z]{2})/i,
    // Remote patterns
    /(Remote|Anywhere)/i,
  ];
  
  for (const pattern of locationPatterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      location = match[1].trim();
      console.log('â Found location:', location);
      break;
    }
  }
  
  // Extract salary
  let salary = '';
  const salaryMatch = text.match(/\$[\d,]+(?:\.\d{2})?\s*[-âto]+\s*\$?[\d,]+(?:\.\d{2})?(?:\s*(?:per|\/)\s*(?:hour|hr|year|yr|month|mo))?/i);
  if (salaryMatch) {
    salary = salaryMatch[0];
    console.log('â Found salary:', salary);
  }
  
  const result = {
    company,
    role,
    location,
    salary,
    url: '', // Will be set by caller
    rawContext: text.substring(0, 300), // Keep first 300 chars for debugging
  };
  
  console.log('ð¦ Extracted:', { company: company || 'MISSING', role: role || 'MISSING', location, salary });
  
  return result;
}

// ============================================
// END LISTING VALIDATION & QUALITY CONTROL
// ============================================

function parseJobEmail(message) {
  try {
    const headers = message.payload.headers;
    const subject = headers.find(h => h.name === 'Subject')?.value || '';
    const from = headers.find(h => h.name === 'From')?.value || '';
    
    console.log('ð§ Parsing email from:', from, '| Subject:', subject);
    
    // Get email body (prefer HTML for structure parsing)
    let htmlBody = '';
    let textBody = '';
    
    if (message.payload.parts) {
      const htmlPart = message.payload.parts.find(part => part.mimeType === 'text/html');
      const textPart = message.payload.parts.find(part => part.mimeType === 'text/plain');
      
      if (htmlPart && htmlPart.body.data) {
        htmlBody = atob(htmlPart.body.data.replace(/-/g, '+').replace(/_/g, '/'));
      }
      if (textPart && textPart.body.data) {
        textBody = atob(textPart.body.data.replace(/-/g, '+').replace(/_/g, '/'));
      }
    } else if (message.payload.body.data) {
      const body = atob(message.payload.body.data.replace(/-/g, '+').replace(/_/g, '/'));
      // Guess if it's HTML or text
      if (/<html|<body|<div/i.test(body)) {
        htmlBody = body;
      } else {
        textBody = body;
      }
    }
    
    const body = htmlBody || textBody; // Use whatever we got
    
    // STRATEGY 1: Try HTML structure extraction (best quality)
    if (htmlBody) {
      console.log('ð Attempting HTML structure extraction...');
      const htmlListings = extractJobListingsFromHTML(htmlBody, subject, from);
      
      if (htmlListings.length > 0) {
        console.log(`â Found ${htmlListings.length} listings via HTML extraction`);
        
        // Validate and return the first valid listing
        for (const listing of htmlListings) {
          const validation = isValidListing(listing, htmlBody);
          
          if (validation.isValid) {
            console.log('â Valid listing found via HTML extraction');
            listing.source = from.includes('linkedin.com') ? 'LinkedIn' :
                           from.includes('indeed.com') ? 'Indeed' :
                           from.includes('glassdoor.com') ? 'Glassdoor' :
                           from.includes('ziprecruiter.com') ? 'ZipRecruiter' : 'Unknown';
            listing.notes = `Found via ${listing.source} job alert (HTML extraction)`;
            
            // Add metadata
            listing._meta = {
              company: { confidence: 'high', source: 'html_structure' },
              role: { confidence: 'high', source: 'html_structure' },
              location: { confidence: listing.location ? 'medium' : 'none', source: 'html_structure' },
              salary: { confidence: listing.salary ? 'medium' : 'none', source: 'html_structure' },
              url: { confidence: 'high', source: 'html_structure' },
              overallConfidence: 'high',
              extractionMethod: 'html_structure',
              validationWarnings: validation.reasons
            };
            
            return listing;
          } else {
            console.log('â HTML-extracted listing failed validation:', validation.reasons.join(', '));
          }
        }
      } else {
        console.log('â ï¸  No listings found via HTML extraction, falling back to text parsing');
      }
    }
    
    // STRATEGY 2: Fall back to text-based parsing
    console.log('ð Attempting text-based parsing...');
    let jobData = mapEmailFields(subject, body, from);
    
    // Try specific parsers if universal mapper fails
    if (!jobData || jobData.company === 'Unknown' || jobData.role === 'Various Roles') {
      if (from.includes('linkedin.com')) {
        jobData = parseLinkedInJob(subject, body);
      } else if (from.includes('indeed.com')) {
        jobData = parseIndeedJob(subject, body);
      } else if (from.includes('glassdoor.com')) {
        jobData = parseGlassdoorJob(subject, body);
      } else if (from.includes('greenhouse.io') || from.includes('lever.co')) {
        jobData = parseATSJob(subject, body);
      } else {
        jobData = parseGenericJob(subject, body, from);
      }
    }
    
    // VALIDATION: Check if we got garbage
    if (jobData) {
      const validation = isValidListing(jobData, body);
      
      if (!validation.isValid) {
        console.log('â REJECTED: Listing failed validation');
        console.log('   Company:', jobData.company);
        console.log('   Role:', jobData.role);
        console.log('   Reasons:', validation.reasons.join('; '));
        
        // Track rejected listing
        if (!window._rejectedListings) window._rejectedListings = [];
        window._rejectedListings.push({
          timestamp: new Date().toISOString(),
          from,
          subject,
          extracted: jobData,
          reasons: validation.reasons
        });
        
        return null; // Don't import garbage
      }
      
      // Add validation warnings to metadata if present
      if (validation.reasons.length > 0) {
        if (!jobData._meta) jobData._meta = {};
        jobData._meta.validationWarnings = validation.reasons;
        console.log('â ï¸  Valid but with warnings:', validation.reasons.join('; '));
      } else {
        console.log('â Listing passed validation');
      }
    }
    
    return jobData;
  } catch (error) {
    console.error('ð¥ Error parsing email:', error);
    return null;
  }
}

function parseLinkedInJob(subject, body) {
  // LinkedIn format: "Company is hiring: Job Title"
  const match = subject.match(/(.+?)\s+is\s+hiring[:\s]+(.+)/i);
  
  if (match) {
    const company = match[1].trim();
    const role = match[2].trim();
    
    // Try to extract location
    const locationMatch = body.match(/location[:\s]+([^<\n]+)/i) || 
                         body.match(/([A-Z][a-z]+,\s*[A-Z]{2})/);
    const location = locationMatch ? locationMatch[1].trim() : '';
    
    // Try to extract salary
    const salaryMatch = body.match(/\$[\d,]+\s*-\s*\$[\d,]+/);
    const salary = salaryMatch ? salaryMatch[0] : '';
    
    // Try to extract URL
    const urlMatch = body.match(/https:\/\/www\.linkedin\.com\/jobs\/view\/\d+/);
    const url = urlMatch ? urlMatch[0] : '';
    
    return {
      company,
      role,
      location,
      salary,
      url,
      source: 'LinkedIn',
      notes: 'Found via LinkedIn job alert'
    };
  }
  
  return null;
}

function parseIndeedJob(subject, body) {
  // Indeed uses multiple formats:
  // Format 1: "Role @ Company"
  // Format 2: "Role at Company in Location and X more new jobs"
  // Format 3: "Role - Company"
  // Format 4: "Company is hiring for Role. X more jobs..."
  
  let role = '';
  let company = '';
  let location = '';
  
  // Try Format 4: "Company is hiring for Role. X more..."
  let match = subject.match(/(.+?)\s+is\s+hiring\s+for\s+(.+?)\.(?:\s+\d+\s+more|$)/i);
  if (match) {
    company = match[1].trim();
    role = match[2].trim();
  } else {
    // Try Format 1: "Role @ Company"
    match = subject.match(/(.+?)\s+@\s+(.+)/);
    if (match) {
      role = match[1].trim();
      company = match[2].trim();
    } else {
      // Try Format 2: "Role at Company in Location and..."
      match = subject.match(/(.+?)\s+at\s+(.+?)\s+in\s+(.+?)(?:\s+and\s+\d+\s+more|$)/i);
      if (match) {
        role = match[1].trim();
        company = match[2].trim();
        location = match[3].trim();
      } else {
        // Try Format 3: "Role - Company"
        match = subject.match(/(.+?)\s+[-â]\s+(.+)/);
        if (match) {
          role = match[1].trim();
          company = match[2].trim();
        }
      }
    }
  }
  
  if (!role || !company) {
    return null;
  }
  
  // Try to extract location from body if not found in subject
  if (!location) {
    const locationMatch = body.match(/Location[:\s]+([^<\n]+)/i);
    location = locationMatch ? locationMatch[1].trim() : '';
  }
  
  // Try to extract salary
  const salaryMatch = body.match(/\$[\d,]+\s*-\s*\$[\d,]+/);
  const salary = salaryMatch ? salaryMatch[0] : '';
  
  // Try to extract URL
  const urlMatch = body.match(/https:\/\/www\.indeed\.com\/viewjob[^\s"<]+/);
  const url = urlMatch ? urlMatch[0] : '';
  
  return {
    company,
    role,
    location,
    salary,
    url,
    source: 'Indeed',
    notes: 'Found via Indeed job alert'
  };
}

function parseGlassdoorJob(subject, body) {
  // Glassdoor formats:
  // Format 1: "New Job Alert: Job Title at Company"
  // Format 2: "Job Title at Company - Glassdoor"
  // Format 3: "Company is hiring: Job Title"
  
  let role = '';
  let company = '';
  let location = '';
  
  // Try Format 1: "New Job Alert: Job Title at Company"
  let match = subject.match(/New Job Alert[:\s]+(.+?)\s+at\s+(.+)/i);
  if (match) {
    role = match[1].trim();
    company = match[2].trim();
  } else {
    // Try Format 2: "Job Title at Company - Glassdoor"
    match = subject.match(/(.+?)\s+at\s+(.+?)\s*-\s*Glassdoor/i);
    if (match) {
      role = match[1].trim();
      company = match[2].trim();
    } else {
      // Try Format 3: "Company is hiring: Job Title"
      match = subject.match(/(.+?)\s+is\s+hiring[:\s]+(.+)/i);
      if (match) {
        company = match[1].trim();
        role = match[2].trim();
      }
    }
  }
  
  if (!role || !company) {
    return null;
  }
  
  // Try to extract location from body
  const locationMatch = body.match(/Location[:\s]+([^<\n]+)/i);
  location = locationMatch ? locationMatch[1].trim() : '';
  
  // Try to extract salary
  const salaryMatch = body.match(/\$[\d,]+\s*-\s*\$[\d,]+/);
  const salary = salaryMatch ? salaryMatch[0] : '';
  
  // Try to extract URL
  const urlMatch = body.match(/https:\/\/www\.glassdoor\.com[^\s"<]+/);
  const url = urlMatch ? urlMatch[0] : '';
  
  return {
    company,
    role,
    location,
    salary,
    url,
    source: 'Glassdoor',
    notes: 'Found via Glassdoor job alert'
  };
}

function parseATSJob(subject, body) {
  // ATS systems (Greenhouse, Lever) usually have cleaner formats
  const lines = body.split('\n').map(l => l.trim()).filter(l => l);
  
  let company = '';
  let role = subject;
  let location = '';
  let url = '';
  
  // Try to find company and role in body
  for (let i = 0; i < Math.min(lines.length, 10); i++) {
    if (lines[i].toLowerCase().includes('company') || lines[i].toLowerCase().includes('organization')) {
      company = lines[i + 1] || '';
    }
    if (lines[i].toLowerCase().includes('position') || lines[i].toLowerCase().includes('role')) {
      role = lines[i + 1] || role;
    }
    if (lines[i].toLowerCase().includes('location')) {
      location = lines[i + 1] || '';
    }
  }
  
  // Try to extract URL
  const urlMatch = body.match(/https?:\/\/[^\s"<]+(?:greenhouse\.io|lever\.co)[^\s"<]+/);
  url = urlMatch ? urlMatch[0] : '';
  
  return {
    company: company || 'Unknown Company',
    role,
    location,
    salary: '',
    url,
    source: 'ATS',
    notes: 'Found via ATS job alert'
  };
}

// Universal field mapper - similar to Zapier/Make.com
function mapEmailFields(subject, body, from) {
  // Determine source from email domain
  let source = 'Unknown';
  if (from.includes('linkedin.com')) source = 'linkedin';
  else if (from.includes('indeed.com')) source = 'indeed';
  else if (from.includes('glassdoor.com')) source = 'glassdoor';
  else if (from.includes('ziprecruiter.com')) source = 'ziprecruiter';
  else if (from.includes('angel.co')) source = 'angel';
  else if (from.includes('remote.co')) source = 'remote';
  else if (from.includes('weworkremotely.com')) source = 'weworkremotely';
  else {
    const domainMatch = from.match(/@(.+)/);
    source = domainMatch ? domainMatch[1] : 'unknown';
  }
  
  // Get parser config for this source
  const parserConfig = state.emailParsers[source] || state.emailParsers.linkedin; // fallback
  
  let company = '';
  let role = '';
  let location = '';
  let salary = '';
  let url = '';
  
  // Track confidence for each field
  let companyConfidence = 'none';
  let roleConfidence = 'none';
  let locationConfidence = 'none';
  let salaryConfidence = 'none';
  let urlConfidence = 'none';
  
  let companySource = 'not_found';
  let roleSource = 'not_found';
  let locationSource = 'not_found';
  let salarySource = 'not_found';
  let urlSource = 'not_found';
  
  // Try subject line patterns first (high confidence)
  for (const pattern of parserConfig.patterns.subject) {
    const match = subject.match(pattern);
    if (match) {
      if (pattern.source.includes('at') && pattern.source.includes('in')) {
        // Format: "Role at Company in Location"
        role = match[1]?.trim() || '';
        company = match[2]?.trim() || '';
        location = match[3]?.trim() || '';
        roleConfidence = 'high';
        companyConfidence = 'high';
        locationConfidence = 'high';
        roleSource = 'subject_line';
        companySource = 'subject_line';
        locationSource = 'subject_line';
      } else if (pattern.source.includes('@')) {
        // Format: "Role @ Company"
        role = match[1]?.trim() || '';
        company = match[2]?.trim() || '';
        roleConfidence = 'high';
        companyConfidence = 'high';
        roleSource = 'subject_line';
        companySource = 'subject_line';
      } else if (pattern.source.includes('for')) {
        // Format: "Company for Role"
        company = match[1]?.trim() || '';
        role = match[2]?.trim() || '';
        companyConfidence = 'high';
        roleConfidence = 'high';
        companySource = 'subject_line';
        roleSource = 'subject_line';
      } else if (pattern.source.includes('in') && pattern.source.includes('Apply')) {
        // Format: "Company1, Company2 in Location. Apply Now"
        const companies = match[1]?.trim().split(',').map(c => c.trim()) || [];
        company = companies[0] || 'Unknown';
        location = match[2]?.trim() || '';
        role = 'Various Roles';
        companyConfidence = 'medium';
        locationConfidence = 'high';
        roleConfidence = 'low';
        companySource = 'subject_line';
        locationSource = 'subject_line';
        roleSource = 'fallback';
      } else if (pattern.source.includes('is hiring')) {
        // Format: "Company is hiring"
        company = match[1]?.trim() || '';
        role = 'Various Roles';
        companyConfidence = 'high';
        roleConfidence = 'low';
        companySource = 'subject_line';
        roleSource = 'fallback';
      } else if (pattern.source.includes('I think this job')) {
        // Format: "Jared, I think this job might be right for you!"
        company = 'Unknown';
        role = 'Various Roles';
        companyConfidence = 'low';
        roleConfidence = 'low';
        companySource = 'fallback';
        roleSource = 'fallback';
      } else if (pattern.source.includes('has an open position')) {
        // Format: "ð¼ Jared, Company. has an open position"
        company = match[1]?.trim() || '';
        role = 'Various Roles';
        companyConfidence = 'high';
        roleConfidence = 'low';
        companySource = 'subject_line';
        roleSource = 'fallback';
      } else if (pattern.source.includes('Did you see this job')) {
        // Format: "Did you see this job?"
        company = 'Unknown';
        role = 'Various Roles';
        companyConfidence = 'low';
        roleConfidence = 'low';
        companySource = 'fallback';
        roleSource = 'fallback';
      }
      break; // Use first successful match
    }
  }
  
  // Try body patterns for missing fields (medium confidence)
  if (!company && parserConfig.patterns.body.company) {
    for (const pattern of parserConfig.patterns.body.company) {
      const match = body.match(pattern);
      if (match) {
        company = match[1]?.trim() || '';
        companyConfidence = 'medium';
        companySource = 'body_pattern';
        break;
      }
    }
  }
  
  if (!location && parserConfig.patterns.body.location) {
    for (const pattern of parserConfig.patterns.body.location) {
      const match = body.match(pattern);
      if (match) {
        location = match[1]?.trim() || '';
        locationConfidence = 'medium';
        locationSource = 'body_pattern';
        break;
      }
    }
  }
  
  if (!salary && parserConfig.patterns.body.salary) {
    for (const pattern of parserConfig.patterns.body.salary) {
      const match = body.match(pattern);
      if (match) {
        salary = match[0] || '';
        salaryConfidence = 'medium';
        salarySource = 'body_pattern';
        break;
      }
    }
  }
  
  // Additional salary extraction patterns (low confidence)
  if (!salary) {
    // Try various salary patterns
    const salaryPatterns = [
      /\$[\d,]+\s*-\s*\$[\d,]+/g,
      /\$[\d,]+\s*to\s*\$[\d,]+/gi,
      /\$[\d,]+\s*per\s+year/gi,
      /\$[\d,]+\s*annually/gi
    ];
    
    for (const pattern of salaryPatterns) {
      const match = body.match(pattern);
      if (match) {
        salary = match[0];
        salaryConfidence = 'low';
        salarySource = 'description';
        break;
      }
    }
  }
  
  if (!url && parserConfig.patterns.body.url) {
    for (const pattern of parserConfig.patterns.body.url) {
      const match = body.match(pattern);
      if (match) {
        url = match[0] || '';
        urlConfidence = 'medium';
        urlSource = 'body_pattern';
        break;
      }
    }
  }
  
  // Additional body parsing for common patterns (low confidence)
  if (!company || company === 'Unknown') {
    // Try to extract company from body text
    const companyMatch = body.match(/(?:at|@)\s+([^<\n,]+?)(?:\s+in\s+|\s*$)/i);
    if (companyMatch) {
      company = companyMatch[1].trim();
      if (companyConfidence === 'none' || company !== 'Unknown') {
        companyConfidence = 'low';
        companySource = 'description';
      }
    }
  }
  
  if (!location || location.length < 3) {
    // Try to extract full location from body
    const locationMatch = body.match(/([A-Z][a-z]+\s+[A-Z][a-z]+,\s*[A-Z]{2})/);
    if (locationMatch) {
      location = locationMatch[1];
      if (locationConfidence === 'none') {
        locationConfidence = 'low';
        locationSource = 'description';
      }
    }
  }
  
  // Clean up location field to remove salary and other non-location data
  if (location) {
    // Remove salary ranges from location
    location = location.replace(/\$[\d,]+\s*-\s*\$[\d,]+.*$/i, '').trim();
    // Remove common non-location phrases
    location = location.replace(/(package\s+to\s+support|remote|hybrid|full-time|part-time).*$/i, '').trim();
    // Try to find full city name in body if we have a partial city
    if (location && location.length < 8) {
      const fullCity = findFullCityName(location, body);
      if (fullCity) {
        location = fullCity;
      }
    }
  }
  
  if (!role || role === 'Various Roles') {
    // Try to extract specific role from body
    const roleMatch = body.match(/([A-Z][a-z\s]+(?:Manager|Specialist|Engineer|Director|Analyst|Coordinator|Representative|Advisor|Consultant|Executive))/i);
    if (roleMatch) {
      role = roleMatch[1].trim();
      if (roleConfidence === 'none' || roleConfidence === 'low') {
        roleConfidence = 'medium';
        roleSource = 'description';
      }
    }
  }
  
  // Clean up extracted data
  if (company) {
    // Remove "is hiring" and "are hiring" from company names
    company = company.replace(/\s+(is|are)\s+hiring$/i, '').trim();
    // Remove "and others" from company names
    company = company.replace(/\s+and\s+others$/i, '').trim();
  }
  
  if (location) {
    // Remove salary info from location field first
    location = location.replace(/\$[\d,]+\s*-\s*\$[\d,]+.*$/i, '').trim();
    location = location.replace(/package\s+to\s+support.*$/i, '').trim();
    
    // Try to find full city name in body if we have a partial city
    if (location && location.length < 8) {
      const fullCity = findFullCityName(location, body);
      if (fullCity) {
        location = fullCity;
      }
    }
  }
  
  if (role) {
    // Fix truncated role titles
    if (role.startsWith('t ')) role = role.substring(2);
    if (role.startsWith('a ')) role = role.substring(2);
    // Clean up common role title issues
    role = role.replace(/^\s*[a-z]\s+/, '').trim();
    
    // Validate role title - filter out obvious non-roles
    if (isValidRoleTitle(role)) {
      // Role is valid, keep it
    } else {
      // Role is invalid, try to extract from body or set to generic
      const extractedRole = extractRoleFromBody(body);
      role = extractedRole || 'Various Roles';
    }
  }
  
  // Fallback if nothing was found
  if (!company && !role) {
    company = 'Unknown';
    role = subject;
    companyConfidence = 'low';
    roleConfidence = 'low';
    companySource = 'fallback';
    roleSource = 'fallback';
  }
  
  // Use structured parsing helpers
  const structuredSalary = parseStructuredSalary(salary, body);
  const structuredLocation = parseStructuredLocation(location);
  
  // Update confidence based on structured parsing
  if (structuredSalary.confidence !== 'none') {
    salaryConfidence = structuredSalary.confidence;
  }
  if (structuredLocation.confidence !== 'none' && locationConfidence === 'none') {
    locationConfidence = structuredLocation.confidence;
  }
  
  // Check URL
  if (url && url.startsWith('http')) {
    urlConfidence = 'high';
    urlSource = 'direct_data';
  }
  
  const jobData = {
    company: company || 'Unknown',
    role: role || 'Various Roles',
    location: location || '',
    salary: salary || '',
    url: url || '',
    source: source.charAt(0).toUpperCase() + source.slice(1),
    notes: `Found via ${source} job alert`,
    
    // Metadata for confidence tracking
    _meta: {
      company: {
        confidence: companyConfidence,
        source: companySource
      },
      role: {
        confidence: roleConfidence,
        source: roleSource
      },
      location: {
        confidence: locationConfidence,
        source: locationSource,
        structured: structuredLocation
      },
      salary: {
        confidence: salaryConfidence,
        source: salarySource,
        structured: structuredSalary
      },
      url: {
        confidence: urlConfidence,
        source: urlSource
      },
      overallConfidence: null // will be calculated
    }
  };
  
  // Calculate overall confidence
  jobData._meta.overallConfidence = calculateJobConfidence(jobData);
  
  return jobData;
}

// Helper function to find full city name from partial city in email body
function findFullCityName(partialCity, body) {
  if (!partialCity || !body) return null;
  
  // Common city truncations and their full names
  const cityMappings = {
    'Angeles': 'Los Angeles',
    'Monica': 'Santa Monica',
    'Francisco': 'San Francisco',
    'Diego': 'San Diego',
    'Jose': 'San Jose',
    'Antonio': 'San Antonio',
    'Bernardino': 'San Bernardino',
    'Gabriel': 'San Gabriel',
    'Rafael': 'San Rafael',
    'Mateo': 'San Mateo',
    'Leandro': 'San Leandro',
    'Bruno': 'San Bruno',
    'Carlos': 'San Carlos',
    'Luis': 'San Luis Obispo',
    'Marcos': 'San Marcos',
    'Fernando': 'San Fernando',
    'Bernardino': 'San Bernardino',
    'Clemente': 'San Clemente',
    'Juan': 'San Juan',
    'Pedro': 'San Pedro',
    'Ramon': 'San Ramon',
    'Ysidro': 'San Ysidro'
  };
  
  // Check if partial city matches a known truncation
  if (cityMappings[partialCity]) {
    return cityMappings[partialCity];
  }
  
  // Try to find the full city name in the email body
  const cityPatterns = [
    // Look for "City, State" format
    new RegExp(`([A-Z][a-z]+\\s+${partialCity}[a-z]*,\\s*[A-Z]{2})`, 'i'),
    // Look for "City, Country" format
    new RegExp(`([A-Z][a-z]+\\s+${partialCity}[a-z]*,\\s*[A-Z][a-z]+)`, 'i'),
    // Look for standalone city names
    new RegExp(`\\b([A-Z][a-z]+\\s+${partialCity}[a-z]*)\\b`, 'i')
  ];
  
  for (const pattern of cityPatterns) {
    const match = body.match(pattern);
    if (match) {
      return match[1].trim();
    }
  }
  
  return null;
}

// Helper function to validate if a role title is legitimate
function isValidRoleTitle(role) {
  if (!role || role.length < 3) return false;
  
  // Common non-role words that might be extracted incorrectly
  const invalidWords = [
    'apply', 'now', 'click', 'here', 'view', 'job', 'position', 'opening',
    'hiring', 'company', 'location', 'salary', 'remote', 'hybrid', 'full',
    'time', 'part', 'contract', 'temporary', 'permanent', 'benefits',
    'package', 'support', 'various', 'roles', 'jobs', 'positions',
    'indeed', 'linkedin', 'glassdoor', 'ziprecruiter', 'angel', 'remote',
    'weworkremotely', 'greenhouse', 'lever', 'ats', 'hr', 'recruiter',
    'talent', 'acquisition', 'team', 'department', 'division', 'unit',
    'office', 'headquarters', 'branch', 'location', 'address', 'city',
    'state', 'country', 'region', 'area', 'zone', 'district', 'county'
  ];
  
  const roleLower = role.toLowerCase();
  
  // Check if role contains invalid words
  for (const invalidWord of invalidWords) {
    if (roleLower.includes(invalidWord)) {
      return false;
    }
  }
  
  // Check if role is too generic
  const genericRoles = ['various roles', 'multiple positions', 'open positions', 'job openings'];
  if (genericRoles.includes(roleLower)) {
    return false;
  }
  
  // Check if role has proper capitalization (should start with capital letter)
  if (!/^[A-Z]/.test(role)) {
    return false;
  }
  
  // Check if role contains common job title indicators
  const jobTitleIndicators = [
    'manager', 'specialist', 'engineer', 'director', 'analyst', 'coordinator',
    'representative', 'advisor', 'consultant', 'executive', 'assistant',
    'associate', 'senior', 'junior', 'lead', 'principal', 'staff',
    'developer', 'designer', 'architect', 'administrator', 'supervisor',
    'officer', 'agent', 'clerk', 'technician', 'operator', 'technician',
    'scientist', 'researcher', 'writer', 'editor', 'producer', 'director',
    'coordinator', 'facilitator', 'trainer', 'instructor', 'teacher',
    'professor', 'researcher', 'analyst', 'strategist', 'planner'
  ];
  
  const hasJobIndicator = jobTitleIndicators.some(indicator => 
    roleLower.includes(indicator)
  );
  
  return hasJobIndicator;
}

// Helper function to extract role title from email body when subject parsing fails
function extractRoleFromBody(body) {
  if (!body) return null;
  
  // Common role extraction patterns
  const rolePatterns = [
    // "We are looking for a [Role]"
    /(?:looking for|seeking|hiring)\s+(?:a\s+)?([A-Z][a-z\s]+(?:Manager|Specialist|Engineer|Director|Analyst|Coordinator|Representative|Advisor|Consultant|Executive|Developer|Designer|Architect|Administrator|Supervisor|Officer|Agent|Clerk|Technician|Operator|Scientist|Researcher|Writer|Editor|Producer|Facilitator|Trainer|Instructor|Teacher|Professor|Strategist|Planner))/i,
    
    // "Position: [Role]"
    /(?:position|role|title):\s*([A-Z][a-z\s]+(?:Manager|Specialist|Engineer|Director|Analyst|Coordinator|Representative|Advisor|Consultant|Executive|Developer|Designer|Architect|Administrator|Supervisor|Officer|Agent|Clerk|Technician|Operator|Scientist|Researcher|Writer|Editor|Producer|Facilitator|Trainer|Instructor|Teacher|Professor|Strategist|Planner))/i,
    
    // "[Company] is hiring a [Role]"
    /(?:is|are)\s+hiring\s+(?:a\s+)?([A-Z][a-z\s]+(?:Manager|Specialist|Engineer|Director|Analyst|Coordinator|Representative|Advisor|Consultant|Executive|Developer|Designer|Architect|Administrator|Supervisor|Officer|Agent|Clerk|Technician|Operator|Scientist|Researcher|Writer|Editor|Producer|Facilitator|Trainer|Instructor|Teacher|Professor|Strategist|Planner))/i,
    
    // "Join our team as a [Role]"
    /(?:join our team as|become a|work as)\s+(?:a\s+)?([A-Z][a-z\s]+(?:Manager|Specialist|Engineer|Director|Analyst|Coordinator|Representative|Advisor|Consultant|Executive|Developer|Designer|Architect|Administrator|Supervisor|Officer|Agent|Clerk|Technician|Operator|Scientist|Researcher|Writer|Editor|Producer|Facilitator|Trainer|Instructor|Teacher|Professor|Strategist|Planner))/i,
    
    // Generic job title patterns
    /([A-Z][a-z\s]+(?:Manager|Specialist|Engineer|Director|Analyst|Coordinator|Representative|Advisor|Consultant|Executive|Developer|Designer|Architect|Administrator|Supervisor|Officer|Agent|Clerk|Technician|Operator|Scientist|Researcher|Writer|Editor|Producer|Facilitator|Trainer|Instructor|Teacher|Professor|Strategist|Planner))/i
  ];
  
  for (const pattern of rolePatterns) {
    const match = body.match(pattern);
    if (match) {
      const role = match[1].trim();
      // Validate the extracted role
      if (isValidRoleTitle(role)) {
        return role;
      }
    }
  }
  
  return null;
}

function parseGenericJob(subject, body, from) {
  // Generic parser for unknown job sources
  // Handle formats like:
  // "Data Clean for Customer Success Manager. Apply Now."
  // "Go2Zero Strategies, Bruno Independent Living Aids in Los Angeles, CA. Apply Now."
  // "SpaceX for Customer Success Specialist (Starlink). Apply Now."
  
  let company = '';
  let role = '';
  let location = '';
  
  // Determine source from email domain first
  let source = 'Unknown';
  if (from.includes('linkedin.com')) source = 'LinkedIn';
  else if (from.includes('indeed.com')) source = 'Indeed';
  else if (from.includes('glassdoor.com')) source = 'Glassdoor';
  else if (from.includes('ziprecruiter.com')) source = 'ZipRecruiter';
  else if (from.includes('angel.co')) source = 'AngelList';
  else if (from.includes('remote.co')) source = 'Remote.co';
  else if (from.includes('weworkremotely.com')) source = 'WeWorkRemotely';
  else {
    // Extract domain from email
    const domainMatch = from.match(/@(.+)/);
    source = domainMatch ? domainMatch[1] : 'Unknown';
  }
  
  // Handle different email formats based on source
  if (source === 'Glassdoor') {
    // Glassdoor format: "Company1, Company2 in Location. Apply Now."
    let match = subject.match(/(.+?)\s+in\s+(.+?)\.\s*Apply\s+Now/i);
    if (match) {
      // Split companies if there are multiple
      const companies = match[1].split(',').map(c => c.trim());
      company = companies[0]; // Take first company
      location = match[2].trim();
      role = 'Various Roles'; // Generic role for multi-company listings
    } else {
      // Glassdoor format: "Company for Role. Apply Now."
      match = subject.match(/(.+?)\s+for\s+(.+?)\.\s*Apply\s+Now/i);
      if (match) {
        company = match[1].trim();
        role = match[2].trim();
      } else {
        // Fallback for Glassdoor
        company = 'Unknown';
        role = subject;
      }
    }
  } else if (source === 'ZipRecruiter') {
    // ZipRecruiter format: "Jared, I think this job might be right for you!" or "ð¼ Jared, Company. has an open position"
    if (subject.includes('I think this job might be right for you')) {
      // This is a generic subject, try to extract from body
      company = 'Unknown';
      role = 'Various Roles';
    } else if (subject.includes('has an open position')) {
      // Extract company from "Company. has an open position"
      const match = subject.match(/(.+?)\.\s+has\s+an\s+open\s+position/i);
      if (match) {
        company = match[1].trim();
        role = 'Various Roles';
      } else {
        company = 'Unknown';
        role = subject;
      }
    } else {
      // Try other patterns
      const match = subject.match(/(.+?)\s+for\s+(.+?)\.\s*Apply\s+Now/i);
      if (match) {
        company = match[1].trim();
        role = match[2].trim();
      } else {
        company = 'Unknown';
        role = subject;
      }
    }
  } else if (source === 'Indeed') {
    // Indeed format: "Role at Company in Location and X more new jobs"
    let match = subject.match(/(.+?)\s+at\s+(.+?)\s+in\s+(.+?)(?:\s+and\s+\d+\s+more|$)/i);
    if (match) {
      role = match[1].trim();
      company = match[2].trim();
      location = match[3].trim();
    } else {
      // Indeed format: "Role @ Company"
      match = subject.match(/(.+?)\s+@\s+(.+)/);
      if (match) {
        role = match[1].trim();
        company = match[2].trim();
      } else {
        company = 'Unknown';
        role = subject;
      }
    }
  } else {
    // Generic fallback
    let match = subject.match(/(.+?)\s+for\s+(.+?)\.\s*Apply\s+Now/i);
    if (match) {
      company = match[1].trim();
      role = match[2].trim();
    } else {
      match = subject.match(/(.+?)\s+in\s+(.+?)\.\s*Apply\s+Now/i);
      if (match) {
        const companies = match[1].split(',').map(c => c.trim());
        company = companies[0];
        location = match[2].trim();
        role = 'Various Roles';
      } else {
        company = 'Unknown';
        role = subject;
      }
    }
  }
  
  // Try to extract location from body if not found in subject
  if (!location) {
    const locationMatch = body.match(/location[:\s]+([^<\n]+)/i) || 
                         body.match(/([A-Z][a-z]+,\s*[A-Z]{2})/);
    location = locationMatch ? locationMatch[1].trim() : '';
  }
  
  // Try to extract salary
  const salaryMatch = body.match(/\$[\d,]+\s*-\s*\$[\d,]+/);
  const salary = salaryMatch ? salaryMatch[0] : '';
  
  // Try to extract URL
  const urlMatch = body.match(/https?:\/\/[^\s"<]+/);
  const url = urlMatch ? urlMatch[0] : '';
  
  return {
    company,
    role,
    location,
    salary,
    url,
    source,
    notes: `Found via ${source} job alert`
  };
}

function blockEmployer(companyName) {
  if (!confirm(`Are you sure you want to block "${companyName}" and never see jobs from them again?`)) {
    return;
  }
  
  // Add to blocked list
  state.blockedEmployers[companyName] = true;
  
  // Remove all existing jobs from this employer
  const initialCount = state.applications.length;
  state.applications = state.applications.filter(app => app.company !== companyName);
  const removedCount = initialCount - state.applications.length;
  
  saveToFirebase();
  renderJobQueue();
  renderPlanScreen();
  
  // Auto-sync to Google Sheets if enabled
  if (state.sheets.enabled && state.sheets.autoSync) {
    syncToGoogleSheets().catch(err => console.warn('Auto-sync failed:', err));
  }
  
  alert(`Blocked "${companyName}"!\n\nRemoved ${removedCount} existing job(s) from this employer.\n\nFuture Gmail scans will skip jobs from this company.`);
}

function blockCity(cityName) {
  if (!confirm(`Are you sure you want to block "${cityName}" and never see jobs from this city again?`)) {
    return;
  }
  
  // Add to blocked cities list
  state.blockedCities = state.blockedCities || {};
  state.blockedCities[cityName] = true;
  
  // Remove all existing jobs from this city
  const initialCount = state.applications.length;
  state.applications = state.applications.filter(app => {
    if (!app.location) return true;
    const city = app.location.split(',')[0].trim();
    return city !== cityName;
  });
  const removedCount = initialCount - state.applications.length;
  
  saveToFirebase();
  renderJobQueue();
  renderPlanScreen();
  
  // Auto-sync to Google Sheets if enabled
  if (state.sheets.enabled && state.sheets.autoSync) {
    syncToGoogleSheets().catch(err => console.warn('Auto-sync failed:', err));
  }
  
  alert(`Blocked "${cityName}"!\n\nRemoved ${removedCount} existing job(s) from this city.\n\nFuture Gmail scans will skip jobs from this city.`);
}

function handleBulkSelection(grade) {
  const checkboxes = document.querySelectorAll('#jobQueueRows input[type="checkbox"]');
  
  if (grade === 'all') {
    // Select all jobs
    checkboxes.forEach(cb => cb.checked = true);
  } else if (grade === 'ungraded') {
    // Select only ungraded jobs
    checkboxes.forEach(cb => {
      const jobId = cb.getAttribute('data-job-id');
      const job = state.applications.find(app => app.id === jobId);
      if (job) {
        const roleTitle = (job.role || '').trim();
        const grade = state.roleGrades[roleTitle] || 'ungraded';
        cb.checked = grade === 'ungraded';
      }
    });
  } else if (['A', 'B', 'C'].includes(grade)) {
    // Select jobs by specific grade
    checkboxes.forEach(cb => {
      const jobId = cb.getAttribute('data-job-id');
      const job = state.applications.find(app => app.id === jobId);
      if (job) {
        const roleTitle = (job.role || '').trim();
        const jobGrade = state.roleGrades[roleTitle] || 'ungraded';
        cb.checked = jobGrade === grade;
      }
    });
  }
  
  updateSelectedCount();
  
  // Reset dropdown
  const dropdown = document.getElementById('bulkSelectDropdown');
  if (dropdown) dropdown.value = '';
}

function clearAllSelections() {
  const checkboxes = document.querySelectorAll('#jobQueueRows input[type="checkbox"]');
  checkboxes.forEach(cb => cb.checked = false);
  updateSelectedCount();
}

function updateSelectedCount() {
  const checkboxes = document.querySelectorAll('#jobQueueRows input[type="checkbox"]:checked');
  const count = checkboxes.length;
  const countEl = document.getElementById('selectedCount');
  if (countEl) {
    countEl.textContent = `${count} selected`;
  }
}

function bulkDeleteJobs() {
  const selectedCheckboxes = document.querySelectorAll('#jobQueueRows input[type="checkbox"]:checked');
  const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.getAttribute('data-job-id'));
  
  if (selectedIds.length === 0) {
    alert('Please select jobs to delete');
    return;
  }
  
  if (!confirm(`Are you sure you want to delete ${selectedIds.length} job(s) from the queue?`)) {
    return;
  }
  
  // Remove selected jobs
  state.applications = state.applications.filter(app => !selectedIds.includes(app.id));
  
  saveToFirebase();
  renderJobQueue();
  
  alert(`${selectedIds.length} job(s) deleted`);
}

function deleteJob(jobId) {
  const job = state.applications.find(app => app.id === jobId);
  if (!job) return;
  
  if (!confirm(`Delete ${job.company} - ${job.role}?`)) {
    return;
  }
  
  state.applications = state.applications.filter(app => app.id !== jobId);
  saveToFirebase();
  renderJobQueue();
}

function viewJobDetails(jobId) {
  const job = state.applications.find(app => app.id === jobId);
  if (!job) return;
  
  // Create a modal instead of alert for better URL handling
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  `;
  
  const content = document.createElement('div');
  content.style.cssText = `
    background: var(--panel);
    border: 1px solid var(--line);
    border-radius: 12px;
    padding: 24px;
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    color: var(--text);
  `;
  
  const urlSection = job.url ? `
    <div style="margin: 16px 0;">
      <strong>Job URL:</strong><br>
      <a href="${job.url}" target="_blank" rel="noopener noreferrer" 
         style="color: var(--accent); text-decoration: underline; word-break: break-all;">
        ${job.url}
      </a>
    </div>
  ` : '';
  
  content.innerHTML = `
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
      <h3 style="margin: 0; color: var(--text);">ð Job Details</h3>
      <button onclick="this.closest('.modal').remove()" 
              style="background: none; border: none; font-size: 24px; cursor: pointer; color: var(--muted);">
        Ã
      </button>
    </div>
    
    <div style="line-height: 1.6;">
      <div><strong>Company:</strong> ${job.company || 'N/A'}</div>
      <div><strong>Role:</strong> ${job.role || 'N/A'}</div>
      <div><strong>Location:</strong> ${job.location || 'N/A'}</div>
      <div><strong>Salary:</strong> ${job.salary || 'N/A'}</div>
      <div><strong>Status:</strong> ${job.status || 'queued'}</div>
      <div><strong>Source:</strong> ${job.source || 'Unknown'}</div>
      
      ${urlSection}
      
      ${job.notes ? `<div style="margin-top: 16px;"><strong>Notes:</strong> ${job.notes}</div>` : ''}
      ${job.addedToQueue ? `<div style="margin-top: 8px; color: var(--muted); font-size: 14px;">Added: ${new Date(job.addedToQueue).toLocaleString()}</div>` : ''}
    </div>
  `;
  
  modal.className = 'modal';
  modal.appendChild(content);
  document.body.appendChild(modal);
  
  // Close on background click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.remove();
    }
  });
  
  // Open URL if available
  if (job.url) {
    if (confirm('Open job posting in new tab?')) {
      window.open(job.url, '_blank');
    }
  }
}

function addJobManually() {
  // Open a modal to add job manually
  alert('Manual job addition will be implemented next!');
}

function addSelectedToPipeline() {
  const selectedCheckboxes = document.querySelectorAll('#jobQueueRows input[type="checkbox"]:checked');
  const selectedJobs = Array.from(selectedCheckboxes).map(cb => cb.getAttribute('data-job-id'));
  
  if (selectedJobs.length === 0) {
    alert('Please select at least one job to add to your pipeline');
    return;
  }
  
  // Move selected jobs to pipeline
  selectedJobs.forEach(jobId => {
    const job = state.applications.find(app => app.id === jobId);
    if (job && job.status === 'queued') {
      job.status = 'pipeline';
      job.addedToPipeline = new Date().toISOString();
    }
  });
  
  saveToFirebase();
  renderJobQueue();
  renderPlanScreen();
  
  // Auto-sync to Google Sheets if enabled
  if (state.sheets.enabled && state.sheets.autoSync) {
    syncToGoogleSheets().catch(err => console.warn('Auto-sync failed:', err));
  }
  
  alert(`${selectedJobs.length} job(s) added to your Applications Pipeline!`);
}

function openJobPrioritizationSettings() {
  document.getElementById('jobPrioritizationModal').style.display = 'flex';
  renderPrioritizationSettings();
}

function closeJobPrioritizationSettings() {
  document.getElementById('jobPrioritizationModal').style.display = 'none';
}

function renderPrioritizationSettings() {
  const container = document.getElementById('prioritizationSettings');
  if (!container) return; // Exit if container doesn't exist
  
  // Get unique role titles from all applications AND previously graded roles
  const roleSet = new Set();
  
  // Add roles from current applications
  state.applications.forEach(app => {
    if (app.role) {
      roleSet.add(app.role.trim());
    }
  });
  
  // Add roles that have been previously graded (even if not in current applications)
  Object.keys(state.roleGrades).forEach(role => {
    if (state.roleGrades[role] !== 'ungraded') {
      roleSet.add(role);
    }
  });
  
  // Sort roles by grade: A (green), B (orange), C (red), ungraded (gray)
  const roles = Array.from(roleSet).sort((a, b) => {
    const gradeOrder = { 'A': 0, 'B': 1, 'C': 2, 'ungraded': 3 };
    const gradeA = state.roleGrades[a] || 'ungraded';
    const gradeB = state.roleGrades[b] || 'ungraded';
    
    const orderDiff = gradeOrder[gradeA] - gradeOrder[gradeB];
    if (orderDiff !== 0) return orderDiff;
    
    // If same grade, sort alphabetically
    return a.localeCompare(b);
  });
  
  container.innerHTML = `
    <div style="display: grid; gap: 16px;">
      <div style="background: var(--panel-hover); padding: 10px; border-radius: 8px; font-size: 11px;">
        <strong>Click roles to cycle colors:</strong>
        <div style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px;">
          <span style="background: #6b7280; color: white; padding: 3px 8px; border-radius: 4px; font-size: 10px;">Gray = Ungraded</span>
          <span style="background: #16a34a; color: white; padding: 3px 8px; border-radius: 4px; font-size: 10px;">Green = Grade A</span>
          <span style="background: #ea580c; color: white; padding: 3px 8px; border-radius: 4px; font-size: 10px;">Orange = Grade B</span>
          <span style="background: #dc2626; color: white; padding: 3px 8px; border-radius: 4px; font-size: 10px;">Red = Grade C</span>
        </div>
      </div>
      
      ${roles.length === 0 ? 
        '<p style="color: var(--text-muted); font-size: 13px; margin: 0;">No roles yet. Scan Gmail or add jobs manually to see role titles here.</p>' :
        `<div style="display: flex; flex-wrap: wrap; gap: 4px;">
          ${roles.map(role => {
            const grade = state.roleGrades[role] || 'ungraded';
            const colors = {
              'A': { bg: '#16a34a', text: 'white' },
              'B': { bg: '#ea580c', text: 'white' },
              'C': { bg: '#dc2626', text: 'white' },
              'ungraded': { bg: '#6b7280', text: 'white' }
            };
            const color = colors[grade];
            
            return `<button 
              onclick="cycleRoleGrade('${role.replace(/'/g, "\\'")}')" 
              style="
                background: ${color.bg}; 
                color: ${color.text}; 
                border: none; 
                padding: 3px 8px; 
                border-radius: 4px; 
                font-size: 10px; 
                cursor: pointer;
                transition: opacity 0.2s;
                white-space: normal;
                word-wrap: break-word;
                height: auto;
                min-height: 20px;
                display: inline-block;
                text-align: center;
              "
              onmouseover="this.style.opacity='0.8'"
              onmouseout="this.style.opacity='1'"
              title="Click to cycle grade: ${grade === 'ungraded' ? 'Not graded' : 'Grade ' + grade}"
            >${role}</button>`;
          }).join('')}
        </div>`
      }
    </div>
  `;
}

function cycleRoleGrade(roleTitle) {
  const currentGrade = state.roleGrades[roleTitle] || 'ungraded';
  const gradeOrder = ['ungraded', 'A', 'B', 'C'];
  const currentIndex = gradeOrder.indexOf(currentGrade);
  const nextIndex = (currentIndex + 1) % gradeOrder.length;
  const newGrade = gradeOrder[nextIndex];
  
  state.roleGrades[roleTitle] = newGrade;
  saveToFirebase();
  
  // Update colors in real-time without re-rendering/re-sorting
  updateRoleColors(roleTitle, newGrade);
}

function updateRoleColors(roleTitle, grade) {
  const gradeColors = {
    'A': { bg: '#16a34a', text: 'white' },
    'B': { bg: '#ea580c', text: 'white' },
    'C': { bg: '#dc2626', text: 'white' },
    'ungraded': { bg: '#6b7280', text: 'white' }
  };
  const color = gradeColors[grade];
  
  // Find and update all buttons with this role title (both in cluster and table)
  const buttons = document.querySelectorAll(`button[onclick*="cycleRoleGrade"]`);
  buttons.forEach(btn => {
    // Check if this button is for the role we're updating
    if (btn.textContent.trim() === roleTitle) {
      btn.style.background = color.bg;
      btn.style.color = color.text;
      const gradeLabel = grade === 'ungraded' ? 'Not graded' : 'Grade ' + grade;
      btn.title = `Click to cycle grade: ${gradeLabel}`;
    }
  });
}

function cycleCityGrade(cityName) {
  const currentGrade = state.cityGrades[cityName] || 'ungraded';
  const gradeOrder = ['ungraded', 'A', 'B', 'C'];
  const currentIndex = gradeOrder.indexOf(currentGrade);
  const nextIndex = (currentIndex + 1) % gradeOrder.length;
  const newGrade = gradeOrder[nextIndex];
  
  state.cityGrades[cityName] = newGrade;
  saveToFirebase();
  updateCityColors(cityName, newGrade);
}

function updateCityColors(cityName, grade) {
  const gradeColors = {
    'A': { bg: '#16a34a', text: 'white' },
    'B': { bg: '#ea580c', text: 'white' },
    'C': { bg: '#dc2626', text: 'white' },
    'ungraded': { bg: '#6b7280', text: 'white' }
  };
  
  const color = gradeColors[grade];
  
  // Update all city buttons with this city name
  document.querySelectorAll(`[data-city="${cityName}"]`).forEach(button => {
    button.style.background = color.bg;
    button.style.color = color.text;
  });
}

function renderCityGradingSettings() {
  const container = document.getElementById('cityGradingSettings');
  if (!container) return;
  
  // Get unique cities from all applications AND previously graded cities
  const citySet = new Set();
  
  // Add cities from current applications
  state.applications.forEach(app => {
    if (app.location) {
      // Extract city from location (handle "Los Angeles, CA" format)
      const city = app.location.split(',')[0].trim();
      citySet.add(city);
    }
  });
  
  // Add cities that have been previously graded (even if not in current applications)
  Object.keys(state.cityGrades).forEach(city => {
    if (state.cityGrades[city] !== 'ungraded') {
      citySet.add(city);
    }
  });
  
  // Sort cities by grade: A (green), B (orange), C (red), ungraded (gray)
  const cities = Array.from(citySet).sort((a, b) => {
    const gradeOrder = { 'A': 0, 'B': 1, 'C': 2, 'ungraded': 3 };
    const gradeA = state.cityGrades[a] || 'ungraded';
    const gradeB = state.cityGrades[b] || 'ungraded';
    
    const orderDiff = gradeOrder[gradeA] - gradeOrder[gradeB];
    if (orderDiff !== 0) return orderDiff;
    
    // If same grade, sort alphabetically
    return a.localeCompare(b);
  });
  
  container.innerHTML = `
    <div style="display: grid; gap: 16px;">
      <div style="background: var(--panel-hover); padding: 10px; border-radius: 8px; font-size: 11px;">
        <strong>Click cities to cycle colors:</strong>
        <div style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px;">
          <span style="background: #6b7280; color: white; padding: 3px 8px; border-radius: 4px; font-size: 10px;">Gray = Ungraded</span>
          <span style="background: #16a34a; color: white; padding: 3px 8px; border-radius: 4px; font-size: 10px;">Green = Grade A</span>
          <span style="background: #ea580c; color: white; padding: 3px 8px; border-radius: 4px; font-size: 10px;">Orange = Grade B</span>
          <span style="background: #dc2626; color: white; padding: 3px 8px; border-radius: 4px; font-size: 10px;">Red = Grade C</span>
        </div>
      </div>
      
      ${cities.length === 0 ? 
        '<p style="color: var(--text-muted); font-size: 13px; margin: 0;">No cities yet. Scan Gmail or add jobs manually to see cities here.</p>' :
        `<div style="display: flex; flex-wrap: wrap; gap: 4px;">
          ${cities.map(city => {
            const grade = state.cityGrades[city] || 'ungraded';
            const colors = {
              'A': { bg: '#16a34a', text: 'white' },
              'B': { bg: '#ea580c', text: 'white' },
              'C': { bg: '#dc2626', text: 'white' },
              'ungraded': { bg: '#6b7280', text: 'white' }
            };
            const color = colors[grade];
            
            return `<button 
              onclick="cycleCityGrade('${city.replace(/'/g, "\\'")}')" 
              data-city="${city}"
              style="
                background: ${color.bg}; 
                color: ${color.text}; 
                border: none; 
                padding: 3px 8px; 
                border-radius: 4px; 
                font-size: 10px; 
                cursor: pointer;
                transition: opacity 0.2s;
                white-space: normal;
                word-wrap: break-word;
                height: auto;
                min-height: 20px;
                display: inline-block;
                text-align: center;
              "
              onmouseover="this.style.opacity='0.8'"
              onmouseout="this.style.opacity='1'"
              title="Click to cycle grade: ${grade === 'ungraded' ? 'Not graded' : 'Grade ' + grade}"
            >${city}</button>`;
          }).join('')}
        </div>`
      }
    </div>
  `;
}

function syncToUserId() {
  const newUserId = document.getElementById('syncUserIdInput').value.trim();
  if (!newUserId) {
    alert('Please enter a User ID');
    return;
  }
  
  if (newUserId === userId) {
    alert('This is already your current User ID');
    return;
  }
  
  if (confirm(`Switch to User ID: ${newUserId}?\n\nThis will load data from that account and sync with other devices using the same ID.`)) {
    // Save current data to localStorage as backup
    localStorage.setItem('career_chute_backup_' + userId, JSON.stringify(state));
    
    // Switch to new User ID
    userId = newUserId;
    localStorage.setItem('career_chute_userId', userId);
    
    // Clear current state
    state = {
      weekStart: getWeekStart(),
      targets: { apps: 15, net: 10 },
      apps: [],
      contacts: [],
      dailyTasks: {},
      weekDone: { apps: 0, net: 0 },
      taskProgress: {},
      streak: 0,
      theme: 'dark'
    };
    
    // Update UI immediately
    renderSettings();
    document.getElementById('syncUserIdInput').value = '';
    
    // Load data from new User ID
    if (firebaseAvailable && db) {
      updateSyncStatus('syncing', 'Loading data...');
      db.collection('users').doc(userId).get().then(doc => {
        if (doc.exists) {
          const data = doc.data();
          if (data.lastUpdated) {
            state = { ...state, ...data };
            delete state.lastUpdated;
            
            // Re-render everything
            renderTodayTasks();
            renderPlanScreen();
            renderSettings();
            
            updateSyncStatus('synced', 'Synced');
            setTimeout(() => updateSyncStatus('', 'Cloud'), 2000);
            
            alert('Successfully synced with other device!');
          } else {
            alert('No data found for this User ID');
          }
        } else {
          alert('No data found for this User ID');
        }
      }).catch(error => {
        console.error('Sync error:', error);
        updateSyncStatus('error', 'Error');
        alert('Failed to load data from other device');
      });
    } else {
      alert('Firebase not available - cannot sync data');
    }
  }
}

function forceOfflineMode() {
  if (confirm('Force offline mode?\n\nThis will load your local data and bypass Firebase connection. You can sync later when connection is restored.')) {
    updateSyncStatus('error', 'Offline');
    loadFromLocalStorage();
    alert('Switched to offline mode. Your local data is loaded.');
  }
}

// Emergency global function - can be called from browser console
window.emergencyOffline = function() {
  console.log('Emergency offline mode triggered');
  updateSyncStatus('error', 'Offline');
  loadFromLocalStorage();
  alert('Emergency offline mode activated!');
};

// List all users in Firebase (for debugging)
function listAllUsers() {
  if (!firebaseAvailable || !db) {
    alert('Firebase not available');
    return;
  }
  
  updateSyncStatus('syncing', 'Loading users...');
  
  db.collection('users').get().then(querySnapshot => {
    let userList = 'Found ' + querySnapshot.size + ' users:\n\n';
    querySnapshot.forEach(doc => {
      const data = doc.data();
      const lastUpdated = data.lastUpdated ? new Date(data.lastUpdated).toLocaleString() : 'Never';
      const taskCount = data.dailyTasks ? Object.keys(data.dailyTasks).length : 0;
      userList += `ID: ${doc.id}\n`;
      userList += `Last Updated: ${lastUpdated}\n`;
      userList += `Tasks: ${taskCount}\n`;
      userList += `Apps: ${data.apps ? data.apps.length : 0}\n\n`;
    });
    
    updateSyncStatus('synced', 'Users loaded');
    alert(userList);
  }).catch(error => {
    console.error('Error loading users:', error);
    updateSyncStatus('error', 'Error');
    alert('Failed to load users: ' + error.message);
  });
}

// Clean up old users and migrate to shared user
function cleanupAndMigrateUsers() {
  if (!firebaseAvailable || !db) {
    alert('Firebase not available');
    return;
  }
  
  if (confirm('This will merge all user data into a single shared account and delete old users. Continue?')) {
    updateSyncStatus('syncing', 'Migrating users...');
    
    db.collection('users').get().then(querySnapshot => {
      let mergedData = {
        weekStart: getWeekStart(),
        targets: { apps: 15, net: 10 },
        apps: [],
        contacts: [],
        dailyTasks: {},
        weekDone: { apps: 0, net: 0 },
        taskProgress: {},
        streak: 0,
        theme: 'dark'
      };
      
      let userCount = 0;
      let promises = [];
      
      querySnapshot.forEach(doc => {
        if (doc.id !== SHARED_USER_ID) {
          userCount++;
          const data = doc.data();
          
          // Merge data (keep the most recent/complete data)
          if (data.apps && data.apps.length > mergedData.apps.length) {
            mergedData.apps = data.apps;
          }
          if (data.contacts && data.contacts.length > mergedData.contacts.length) {
            mergedData.contacts = data.contacts;
          }
          if (data.dailyTasks) {
            Object.assign(mergedData.dailyTasks, data.dailyTasks);
          }
          if (data.weekDone) {
            mergedData.weekDone = data.weekDone;
          }
          if (data.taskProgress) {
            Object.assign(mergedData.taskProgress, data.taskProgress);
          }
          if (data.streak > mergedData.streak) {
            mergedData.streak = data.streak;
          }
          if (data.theme) {
            mergedData.theme = data.theme;
          }
          
          // Delete old user
          promises.push(db.collection('users').doc(doc.id).delete());
        }
      });
      
      // Save merged data to shared user
      promises.push(db.collection('users').doc(SHARED_USER_ID).set({
        ...mergedData,
        lastUpdated: new Date().toISOString()
      }));
      
      Promise.all(promises).then(() => {
        updateSyncStatus('synced', 'Migration complete');
        alert(`Migration complete! Merged ${userCount} users into shared account.`);
        
        // Reload the app with merged data
        state = mergedData;
        renderTodayTasks();
        renderPlanScreen();
        renderSettings();
      }).catch(error => {
        console.error('Migration error:', error);
        updateSyncStatus('error', 'Migration failed');
        alert('Migration failed: ' + error.message);
      });
    });
  }
}

function exportToICal() {
  const applications = state.applications || [];
  
  if (applications.length === 0) {
    alert('No job applications to export');
    return;
  }
  
  // Generate iCal content
  let icalContent = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//Career Chute//Job Applications//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH'
  ];
  
  // Add each application as an event
  applications.forEach(app => {
    if (!app.company || !app.role) return;
    
    // Create event based on application status and dates
    const eventId = generateId();
    const now = new Date();
    const eventDate = app.dateSent ? new Date(app.dateSent) : 
                     app.addedToPipeline ? new Date(app.addedToPipeline) : 
                     app.addedToQueue ? new Date(app.addedToQueue) : now;
    
    // Format date for iCal (YYYYMMDDTHHMMSSZ)
    const formatDate = (date) => {
      return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
    };
    
    // Create summary based on status
    let summary = `${app.company} - ${app.role}`;
    let description = `Job Application: ${app.company} - ${app.role}`;
    
    if (app.status === 'sent') {
      summary = `â Applied: ${app.company} - ${app.role}`;
      description = `Application submitted to ${app.company} for ${app.role}`;
    } else if (app.status === 'interview') {
      summary = `ð¯ Interview: ${app.company} - ${app.role}`;
      description = `Interview scheduled with ${app.company} for ${app.role}`;
    } else if (app.status === 'offer') {
      summary = `ð Offer: ${app.company} - ${app.role}`;
      description = `Job offer received from ${app.company} for ${app.role}`;
    } else if (app.status === 'rejected') {
      summary = `â Rejected: ${app.company} - ${app.role}`;
      description = `Application rejected by ${app.company} for ${app.role}`;
    } else if (app.status === 'pipeline') {
      summary = `ð Pipeline: ${app.company} - ${app.role}`;
      description = `Job application in pipeline - ${app.company} for ${app.role}`;
    } else if (app.status === 'tailoring') {
      summary = `âï¸ Tailoring: ${app.company} - ${app.role}`;
      description = `Tailoring resume/cover letter for ${app.company} - ${app.role}`;
    } else if (app.status === 'ready') {
      summary = `ð Ready: ${app.company} - ${app.role}`;
      description = `Application ready to submit - ${app.company} for ${app.role}`;
    } else {
      summary = `ð Queued: ${app.company} - ${app.role}`;
      description = `Job application queued - ${app.company} for ${app.role}`;
    }
    
    // Add additional details
    if (app.location) description += `\nLocation: ${app.location}`;
    if (app.salary) description += `\nSalary: ${app.salary}`;
    if (app.url) description += `\nJob URL: ${app.url}`;
    if (app.notes) description += `\nNotes: ${app.notes}`;
    if (app.source) description += `\nSource: ${app.source}`;
    
    // Add status-specific dates
    if (app.dateSent) description += `\nApplied: ${new Date(app.dateSent).toLocaleDateString()}`;
    if (app.addedToPipeline) description += `\nAdded to Pipeline: ${new Date(app.addedToPipeline).toLocaleDateString()}`;
    if (app.addedToQueue) description += `\nAdded to Queue: ${new Date(app.addedToQueue).toLocaleDateString()}`;
    
    // Create the event
    icalContent.push(
      'BEGIN:VEVENT',
      `UID:${eventId}@career-chute.app`,
      `DTSTART:${formatDate(eventDate)}`,
      `DTEND:${formatDate(new Date(eventDate.getTime() + 60 * 60 * 1000))}`, // 1 hour duration
      `SUMMARY:${summary}`,
      `DESCRIPTION:${description.replace(/\n/g, '\\n')}`,
      `STATUS:CONFIRMED`,
      `TRANSP:OPAQUE`,
      'END:VEVENT'
    );
  });
  
  icalContent.push('END:VCALENDAR');
  
  // Create and download the file
  const icalString = icalContent.join('\r\n');
  const blob = new Blob([icalString], { type: 'text/calendar;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `career-chute-applications-${new Date().toISOString().split('T')[0]}.ics`;
  link.click();
  URL.revokeObjectURL(url);
  
  // Show success message
  const successMsg = document.createElement('div');
  successMsg.style.cssText = `
    position: fixed; top: 20px; right: 20px; z-index: 10000;
    background: var(--ok); color: white; padding: 12px 20px;
    border-radius: 8px; box-shadow: var(--shadow-lift);
    font-weight: 500; animation: slideIn 0.3s ease-out;
  `;
  successMsg.textContent = `ð Exported ${applications.length} applications to iCal`;
  document.body.appendChild(successMsg);
  
  setTimeout(() => {
    successMsg.style.animation = 'fadeUp 0.3s ease-out reverse';
    setTimeout(() => successMsg.remove(), 300);
  }, 3000);
}

function downloadEventICal(eventId) {
  const event = state.events.find(e => e.id === eventId);
  if (!event) {
    alert('Event not found');
    return;
  }
  
  // Generate iCal content for single event
  let icalContent = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//Career Chute//Event//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH'
  ];
  
  // Format date for iCal (YYYYMMDDTHHMMSSZ)
  const formatDate = (date) => {
    return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
  };
  
  const eventDate = event.date ? new Date(event.date) : new Date();
  const startTime = formatDate(eventDate);
  const endTime = formatDate(new Date(eventDate.getTime() + 60 * 60 * 1000)); // 1 hour duration
  
  icalContent.push(
    'BEGIN:VEVENT',
    `UID:${eventId}@career-chute.com`,
    `DTSTART:${startTime}`,
    `DTEND:${endTime}`,
    `SUMMARY:${event.name}`,
    `DESCRIPTION:${event.type}${event.notes ? '\\n\\nNotes: ' + event.notes : ''}`,
    `LOCATION:${event.address || event.location || 'TBD'}`,
    'STATUS:CONFIRMED',
    'END:VEVENT'
  );
  
  icalContent.push('END:VCALENDAR');
  
  // Download file
  const icalString = icalContent.join('\r\n');
  const blob = new Blob([icalString], { type: 'text/calendar;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `career-chute-event-${event.name.replace(/[^a-zA-Z0-9]/g, '-')}.ics`;
  link.click();
  URL.revokeObjectURL(url);
  
  // Show success message
  const successMsg = document.createElement('div');
  successMsg.style.cssText = `
    position: fixed; top: 20px; right: 20px; z-index: 10000;
    background: var(--ok); color: white; padding: 12px 20px;
    border-radius: 8px; box-shadow: var(--shadow-lift);
    font-weight: 500; animation: slideIn 0.3s ease-out;
  `;
  successMsg.textContent = `ð Downloaded ${event.name} to iCal`;
  document.body.appendChild(successMsg);
  
  setTimeout(() => {
    successMsg.style.animation = 'fadeUp 0.3s ease-out reverse';
    setTimeout(() => successMsg.remove(), 300);
  }, 3000);
}

function exportData() {
  const dataStr = JSON.stringify(state, null, 2);
  const dataBlob = new Blob([dataStr], {type: 'application/json'});
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'career-chute-data.json';
  link.click();
  URL.revokeObjectURL(url);
}

function importData() {
  document.getElementById('importFileInput').click();
}

document.getElementById('importFileInput').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const importedData = JSON.parse(e.target.result);
      if (confirm('This will replace all current data. Continue?')) {
        state = { ...state, ...importedData };
        initializeWeekAndDay();
        saveToFirebase();
        renderTodayTasks();
        renderProgress();
        renderPlanScreen();
        renderSettings();
        alert('Data imported successfully!');
      }
    } catch (error) {
      alert('Invalid file format');
    }
  };
  reader.readAsText(file);
});

function confirmReset() {
  if (confirm('This will delete ALL your data. This cannot be undone. Continue?')) {
    if (confirm('Are you absolutely sure? This will reset everything.')) {
      localStorage.clear();
      location.reload();
    }
  }
}

</script>

<!-- Settings Screen -->
<div id="settings-screen" class="screen">
  <div class="top-bar">
    <button class="ghost" onclick="goHome()">â Back</button>
    <h2>Settings</h2>
    <div style="width:60px"></div>
  </div>
  
  <div style="padding: 20px;">
    <div class="setting-section">
      <h3 style="margin-bottom: 16px;">Data Management</h3>
      
      <button onclick="exportData()" style="width: 100%; margin-bottom: 12px;">
        ð¦ Export All Data (JSON)
      </button>
      
      <button onclick="exportToICal()" style="width: 100%; margin-bottom: 12px;">
        ð Export to iCal
      </button>
      
      <button onclick="document.getElementById('import-file').click()" class="secondary" style="width: 100%; margin-bottom: 12px;">
        ð¥ Import Data
      </button>
      <input type="file" id="import-file" accept=".json" style="display:none;" onchange="importData(event)">
      
      <button onclick="confirmClearData()" class="ghost" style="width: 100%; color: var(--bad);">
        ðï¸ Clear All Data
      </button>
    </div>
    
    <div class="setting-section" style="margin-top: 32px;">
      <h3 style="margin-bottom: 16px;">About</h3>
      <p style="color: var(--muted); font-size: 14px;">
        Career Chute v3.0<br>
        Track your job search progress<br>
        All data stored locally on your device
      </p>
    </div>
  </div>
</div>

<!-- Focus Instructions Modal -->
<div id="focusInstructionsModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:1000; align-items:center; justify-content:center; padding:20px;" onclick="closeFocusInstructions()">
  <div style="background:var(--panel); border-radius:16px; padding:32px; max-width:800px; max-height:80vh; overflow-y:auto; margin:20px;" onclick="event.stopPropagation()">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:24px;">
      <h2 style="margin:0; color:var(--accent);">ð¯ Focus Session Guide</h2>
      <button onclick="closeFocusInstructions()" style="background:none; border:none; color:var(--muted); font-size:24px; cursor:pointer; padding:0; width:32px; height:32px; display:flex; align-items:center; justify-content:center;">Ã</button>
    </div>
    
    <div style="color:var(--text); line-height:1.6; font-size:14px;">
      <h3 style="color:var(--accent); margin-top:24px; margin-bottom:12px;">Getting Started</h3>
      <ol style="margin-bottom:20px;">
        <li><strong>Set Your Daily Goal:</strong> Choose 1-8 hours (4-32 blocks) from the dropdown</li>
        <li><strong>Click "Start Focus Day":</strong> This initializes your session and shows the progress grid</li>
        <li><strong>Session Info:</strong> Shows start time and your selected goal</li>
      </ol>

      <h3 style="color:var(--accent); margin-top:24px; margin-bottom:12px;">Understanding the Interface</h3>
      <p><strong>Header Row:</strong></p>
      <ul style="margin-bottom:20px;">
        <li><strong>ð¯ Focus Session:</strong> Session title</li>
        <li><strong>Started: [time]:</strong> When you began your focus day</li>
        <li><strong>Goal: [dropdown]:</strong> Adjustable daily target (1h-8h)</li>
        <li><strong>Progress: X/Y:</strong> Current blocks completed vs. goal</li>
        <li><strong>Total: Xh Ym:</strong> Accumulated time across all completed chunks</li>
      </ul>

      <p><strong>Progress Grid:</strong></p>
      <ul style="margin-bottom:20px;">
        <li><strong>White Squares:</strong> Unfinished 15-minute blocks</li>
        <li><strong>Yellow Squares:</strong> Queued blocks for next chunk</li>
        <li><strong>Green Squares:</strong> Completed blocks</li>
        <li><strong>Blue Squares:</strong> Currently active block (with pulse animation)</li>
      </ul>

      <h3 style="color:var(--accent); margin-top:24px; margin-bottom:12px;">Using Focus Sessions</h3>
      
      <p><strong>Starting a Chunk:</strong></p>
      <ol style="margin-bottom:20px;">
        <li><strong>Select Duration:</strong> Choose your desired chunk length (15m-120m)</li>
        <li><strong>Click Start:</strong> Timer begins counting down, selected blocks turn yellow (queued), first block turns blue (active) with pulse animation, green cycle animation plays on background</li>
      </ol>

      <p><strong>During a Chunk:</strong></p>
      <ul style="margin-bottom:20px;">
        <li><strong>Timer Display:</strong> Shows remaining time in MM:SS format</li>
        <li><strong>Progress Tracking:</strong> Blocks turn green every 15 minutes</li>
        <li><strong>Visual Feedback:</strong> Active block pulses blue</li>
        <li><strong>Automatic Completion:</strong> Chunk finishes when timer reaches zero</li>
      </ul>

      <p><strong>Chunk Completion:</strong></p>
      <ul style="margin-bottom:20px;">
        <li><strong>Rainbow Alert:</strong> Background cycles through rainbow colors</li>
        <li><strong>Block Conversion:</strong> All queued blocks turn green</li>
        <li><strong>Timer Continues:</strong> If no new chunk selected, timer keeps running</li>
        <li><strong>Auto-Progression:</strong> New green blocks added every 15 minutes</li>
      </ul>

      <h3 style="color:var(--accent); margin-top:24px; margin-bottom:12px;">Button Functions</h3>
      <table style="width:100%; border-collapse:collapse; margin-bottom:20px;">
        <tr style="border-bottom:1px solid var(--line);">
          <th style="text-align:left; padding:8px 0; color:var(--accent);">Button</th>
          <th style="text-align:left; padding:8px 0; color:var(--accent);">Function</th>
          <th style="text-align:left; padding:8px 0; color:var(--accent);">Confirmation Required</th>
        </tr>
        <tr style="border-bottom:1px solid var(--line);">
          <td style="padding:8px 0;"><strong>Start</strong></td>
          <td style="padding:8px 0;">Begins new chunk timer</td>
          <td style="padding:8px 0;">No</td>
        </tr>
        <tr style="border-bottom:1px solid var(--line);">
          <td style="padding:8px 0;"><strong>Pause</strong></td>
          <td style="padding:8px 0;">Pauses current chunk</td>
          <td style="padding:8px 0;">No</td>
        </tr>
        <tr style="border-bottom:1px solid var(--line);">
          <td style="padding:8px 0;"><strong>Resume</strong></td>
          <td style="padding:8px 0;">Resumes paused chunk</td>
          <td style="padding:8px 0;">No</td>
        </tr>
        <tr style="border-bottom:1px solid var(--line);">
          <td style="padding:8px 0;"><strong>Reset</strong></td>
          <td style="padding:8px 0;">Resets entire day's progress</td>
          <td style="padding:8px 0;">Yes</td>
        </tr>
        <tr>
          <td style="padding:8px 0;"><strong>End</strong></td>
          <td style="padding:8px 0;">Ends focus day, saves to history</td>
          <td style="padding:8px 0;">Yes</td>
        </tr>
      </table>

      <h3 style="color:var(--accent); margin-top:24px; margin-bottom:12px;">Advanced Features</h3>
      <ul style="margin-bottom:20px;">
        <li><strong>Timer Coordination:</strong> Focus session timer pauses when you enter task focus mode and resumes when you exit</li>
        <li><strong>Multi-Device Sync:</strong> Progress syncs across all devices via Firebase</li>
        <li><strong>Visual Alerts:</strong> Green cycle when chunk starts, rainbow cycle when chunk completes, yellow pulse when paused</li>
        <li><strong>Conflict Resolution:</strong> Automatically handles timer conflicts between devices</li>
      </ul>

      <div style="background:var(--panel-hover); padding:16px; border-radius:8px; margin-top:24px; font-size:12px; color:var(--muted);">
        <strong>Technical Notes:</strong> Each block = 15 minutes. Chunk types: 15m (1 block), 30m (2 blocks), 45m (3 blocks), etc. All progress saved to Firebase and local storage. Optimized for mobile and desktop use.
      </div>
    </div>
  </div>
</div>

<!-- Modal Overlay -->
<div id="modal-overlay" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:1000; align-items:center; justify-content:center;" onclick="closeModal()">
  <div id="modal-content" style="background:var(--panel); border-radius:16px; padding:32px; max-width:400px; margin:20px;" onclick="event.stopPropagation()">
    <h2 id="modal-title" style="margin-bottom:16px;"></h2>
    <p id="modal-message" style="color:var(--muted); margin-bottom:24px;"></p>
    <div id="modal-buttons" style="display:flex; gap:12px;"></div>
  </div>
</div>

<!-- Celebration Overlay -->
<div id="celebration-overlay" class="celebration-overlay">
  <div>
    <div class="breathing-circle"></div>
    <div class="breathing-text">ð Nice work!</div>
  </div>
</div>

<style>
.setting-section {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 20px;
}

@keyframes breathe {
  0%, 100% { transform: scale(1); opacity: 0.6; }
  50% { transform: scale(1.3); opacity: 1; }
}

@keyframes confetti {
  0% { transform: translateY(0) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}

.celebration-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  z-index: 9998;
  display: none;
  align-items: center;
  justify-content: center;
}

.celebration-overlay.active {
  display: flex;
}

.breathing-circle {
  width: 150px;
  height: 150px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent), var(--ok));
  animation: breathe 4s ease-in-out infinite;
  margin: 0 auto;
}

.breathing-text {
  text-align: center;
  font-size: 24px;
  font-weight: 600;
  color: var(--text);
  margin-top: 30px;
}

.confetti-piece {
  position: fixed;
  width: 10px;
  height: 10px;
  animation: confetti 3s ease-out forwards;
  z-index: 9999;
}
</style>

<script>
// Field Mapping Training Functions
async function loadMappingTrainingData() {
  if (!state.gmail.connected) {
    alert('Please connect to Gmail first!');
    return;
  }
  
  // Check if token is expired and refresh if needed
  if (state.gmail.tokenExpiry && Date.now() > state.gmail.tokenExpiry) {
    console.log('Gmail token expired, attempting to refresh...');
    try {
      await refreshGmailToken();
    } catch (error) {
      console.error('Token refresh failed:', error);
      alert('Gmail session expired. Please reconnect Gmail.');
      disconnectGmail();
      return;
    }
  }
  
  // Make sure Gmail API is loaded
  if (!gapi || !gapi.client || !gapi.client.gmail) {
    console.log('Gmail API not ready, attempting to reinitialize...');
    try {
      await initGoogleAPI();
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      if (!gapi.client.gmail) {
        alert('Gmail API not ready. Please reconnect Gmail.');
        return;
      }
    } catch (error) {
      console.error('Failed to reinitialize Gmail API:', error);
      alert('Gmail API not ready. Please reconnect Gmail.');
      return;
    }
  }
  
  try {
    // Set the access token for the API call
    gapi.client.setToken({
      access_token: state.gmail.accessToken
    });
    
    // Load recent job alert emails
    const response = await gapi.client.gmail.users.messages.list({
      userId: 'me',
      q: 'from:(linkedin.com OR indeed.com OR glassdoor.com OR ziprecruiter.com) subject:(job OR hiring OR position) newer_than:7d',
      maxResults: 10
    });
    
    const messages = response.result.messages || [];
    const container = document.getElementById('mappingTrainingContainer');
    
    if (messages.length === 0) {
      container.innerHTML = '<p>No recent job emails found for training.</p>';
      return;
    }
    
    container.innerHTML = `
      <div style="background: var(--ok); color: white; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
        <h3 style="margin: 0 0 8px 0;">ð¯ Training Purpose</h3>
        <p style="margin: 0; font-size: 14px;">Review how emails are being parsed and correct any mistakes. This helps the system learn and improve accuracy for future job alerts.</p>
      </div>
      <h3>ð§ Email Parsing Training</h3>
    `;
    
    for (let i = 0; i < Math.min(messages.length, 5); i++) {
      const message = await gapi.client.gmail.users.messages.get({
        userId: 'me',
        id: messages[i].id
      });
      
      const headers = message.result.payload.headers;
      const subject = headers.find(h => h.name === 'Subject')?.value || '';
      const from = headers.find(h => h.name === 'From')?.value || '';
      
      let body = '';
      if (message.result.payload.body.data) {
        body = atob(message.result.payload.body.data.replace(/-/g, '+').replace(/_/g, '/'));
      } else if (message.result.payload.parts) {
        const textPart = message.result.payload.parts.find(part => part.mimeType === 'text/plain');
        if (textPart && textPart.body.data) {
          body = atob(textPart.body.data.replace(/-/g, '+').replace(/_/g, '/'));
        }
      }
      
      // Parse with current system
      console.log('Parsing email:', { subject, from, bodyLength: body.length });
      const parsed = mapEmailFields(subject, body, from);
      console.log('Parsed result:', parsed);
      
      // Create training interface
      const trainingCard = document.createElement('div');
      trainingCard.style.cssText = 'background: var(--panel); border: 1px solid var(--line); border-radius: 8px; padding: 16px; margin-bottom: 16px;';
      
      trainingCard.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 16px;">
          <div>
            <h4 style="margin: 0 0 8px 0;">ð§ Original Email</h4>
            <div style="background: var(--bg); padding: 12px; border-radius: 4px; font-size: 12px; border: 1px solid var(--line);">
              <div style="margin-bottom: 8px;"><strong>From:</strong> ${from}</div>
              <div style="margin-bottom: 8px;"><strong>Subject:</strong> ${subject}</div>
              <div><strong>Body:</strong></div>
              <div style="max-height: 120px; overflow-y: auto; white-space: pre-wrap; margin-top: 4px; padding: 8px; background: var(--panel); border-radius: 4px;">${body.substring(0, 800)}${body.length > 800 ? '...' : ''}</div>
            </div>
          </div>
          <div>
            <h4 style="margin: 0 0 12px 0;">ð§ Current Parsing Results</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 16px;">
              <div>
                <label style="font-size: 12px; color: var(--muted); margin-bottom: 4px; display: block;">Company:</label>
                <input type="text" value="${parsed.company}" style="width: 100%; padding: 8px; border: 1px solid var(--line); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 14px;" onchange="updateParsedField(${i}, 'company', this.value)">
              </div>
              <div>
                <label style="font-size: 12px; color: var(--muted); margin-bottom: 4px; display: block;">Role:</label>
                <input type="text" value="${parsed.role}" style="width: 100%; padding: 8px; border: 1px solid var(--line); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 14px;" onchange="updateParsedField(${i}, 'role', this.value)">
              </div>
              <div>
                <label style="font-size: 12px; color: var(--muted); margin-bottom: 4px; display: block;">Location:</label>
                <input type="text" value="${parsed.location}" style="width: 100%; padding: 8px; border: 1px solid var(--line); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 14px;" onchange="updateParsedField(${i}, 'location', this.value)">
              </div>
              <div>
                <label style="font-size: 12px; color: var(--muted); margin-bottom: 4px; display: block;">Salary:</label>
                <input type="text" value="${parsed.salary}" style="width: 100%; padding: 8px; border: 1px solid var(--line); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 14px;" onchange="updateParsedField(${i}, 'salary', this.value)">
              </div>
              <div>
                <label style="font-size: 12px; color: var(--muted); margin-bottom: 4px; display: block;">Source:</label>
                <input type="text" value="${parsed.source}" style="width: 100%; padding: 8px; border: 1px solid var(--line); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 14px;" onchange="updateParsedField(${i}, 'source', this.value)">
              </div>
            </div>
            <div style="display: flex; gap: 8px; align-items: center;">
              <button onclick="saveTrainingCorrection(${i})" class="modern-button primary" style="height: 36px; padding: 0 16px; font-size: 14px;">
                ð¾ Save Correction
              </button>
              <button onclick="testParsingForEmail(${i})" class="modern-button secondary" style="height: 36px; padding: 0 16px; font-size: 14px;">
                ð Re-parse
              </button>
              <span style="font-size: 12px; color: var(--muted);">This helps improve future parsing accuracy</span>
            </div>
          </div>
        </div>
      `;
      
      container.appendChild(trainingCard);
    }
    
  } catch (error) {
    console.error('Error loading mapping training data:', error);
    alert('Failed to load training data. Please try again.');
  }
}

function updateParsedField(index, field, value) {
  // This would update the parsed data for training
  console.log(`Updating field ${field} to ${value} for email ${index}`);
}

// Test parsing for a specific email
function testParsingForEmail(index) {
  console.log(`Testing parsing for email ${index}`);
  // This would re-run the parsing and update the display
  alert('Re-parsing email... This feature will be implemented to test different parsing approaches.');
}

function saveTrainingCorrection(index) {
  // This would save the correction and potentially update parsing rules
  console.log(`Saving correction for email ${index}`);
  
  // Update statistics
  if (!state.parserStats) {
    state.parserStats = {
      totalEmailsProcessed: 0,
      correctionsMade: 0,
      lastScanTime: null,
      accuracyRate: 0
    };
  }
  
  state.parserStats.correctionsMade++;
  updateParserStats();
  saveToFirebase();
  
  alert('Correction saved! This will help improve future parsing.');
}

// Initialize parser statistics
function initParserStats() {
  if (!state.parserStats) {
    state.parserStats = {
      totalEmailsProcessed: 0,
      correctionsMade: 0,
      lastScanTime: null,
      accuracyRate: 0
    };
  }
  
  // Update from Gmail scan results if available
  if (state.gmail && state.gmail.lastScanResults) {
    state.parserStats.totalEmailsProcessed += state.gmail.lastScanResults.emailsProcessed || 0;
    state.parserStats.lastScanTime = state.gmail.lastScanTime;
  }
  
  updateParserStats();
  populateSourceRules();
}

// Update parser statistics display
function updateParserStats() {
  const stats = state.parserStats || {
    totalEmailsProcessed: 0,
    correctionsMade: 0,
    lastScanTime: null,
    accuracyRate: 0
  };
  
  // Calculate accuracy rate (simplified - in real implementation, track correct vs incorrect)
  const accuracyRate = stats.totalEmailsProcessed > 0 ? 
    Math.max(0, 100 - (stats.correctionsMade / stats.totalEmailsProcessed * 100)) : 0;
  
  const totalEmailsEl = document.getElementById('totalEmailsProcessed');
  const accuracyEl = document.getElementById('parsingAccuracy');
  const correctionsEl = document.getElementById('correctionsMade');
  const lastScanEl = document.getElementById('lastScanTime');
  
  if (totalEmailsEl) totalEmailsEl.textContent = stats.totalEmailsProcessed;
  if (accuracyEl) accuracyEl.textContent = Math.round(accuracyRate) + '%';
  if (correctionsEl) correctionsEl.textContent = stats.correctionsMade;
  if (lastScanEl) {
    if (stats.lastScanTime) {
      const date = new Date(stats.lastScanTime);
      lastScanEl.textContent = date.toLocaleString();
    } else {
      lastScanEl.textContent = 'Never';
    }
  }
}

// Populate source-specific rules
function populateSourceRules() {
  const container = document.getElementById('sourceRules');
  if (!container) return;
  
  const sources = [
    {
      name: 'LinkedIn',
      patterns: [
        'Role at Company in Location',
        'Role @ Company',
        'Company is hiring'
      ],
      examples: [
        'Software Engineer at Google in Mountain View, CA',
        'Product Manager @ Meta',
        'Tesla is hiring'
      ]
    },
    {
      name: 'Indeed',
      patterns: [
        'Company for Role',
        'Role @ Company',
        'New jobs for Role'
      ],
      examples: [
        'Apple for Software Engineer',
        'Data Scientist @ Netflix',
        'New jobs for Product Manager'
      ]
    },
    {
      name: 'Glassdoor',
      patterns: [
        'Company1, Company2 in Location',
        'Company is hiring Role'
      ],
      examples: [
        'Microsoft, Amazon in Seattle, WA',
        'Spotify is hiring Backend Engineer'
      ]
    },
    {
      name: 'ZipRecruiter',
      patterns: [
        'Role opportunities',
        'Company hiring'
      ],
      examples: [
        'Frontend Engineer opportunities',
        'Stripe hiring'
      ]
    }
  ];
  
  container.innerHTML = sources.map(source => `
    <div style="background: var(--bg); padding: 16px; border-radius: 8px; border: 1px solid var(--line);">
      <h4 style="margin: 0 0 12px 0; color: var(--accent);">${source.name}</h4>
      <div style="margin-bottom: 12px;">
        <div style="font-size: 12px; color: var(--muted); margin-bottom: 6px;">Patterns:</div>
        ${source.patterns.map(pattern => `<div style="font-size: 11px; background: var(--panel); padding: 4px 8px; border-radius: 4px; margin-bottom: 4px; font-family: monospace;">${pattern}</div>`).join('')}
      </div>
      <div>
        <div style="font-size: 12px; color: var(--muted); margin-bottom: 6px;">Examples:</div>
        ${source.examples.map(example => `<div style="font-size: 11px; color: var(--text); margin-bottom: 2px;">â¢ ${example}</div>`).join('')}
      </div>
    </div>
  `).join('');
}

// Test function for email parsing improvements
function testEmailParsing() {
  console.log('Testing email parsing improvements...');
  
  // Test 1: Partial city name resolution
  const testBody1 = "We are hiring a Software Engineer in Los Angeles, CA. Apply now!";
  const result1 = findFullCityName("Angeles", testBody1);
  console.log('Test 1 - City resolution:', result1); // Should return "Los Angeles"
  
  // Test 2: Role title validation
  const validRole = "Software Engineer";
  const invalidRole = "Apply Now";
  console.log('Test 2a - Valid role:', isValidRoleTitle(validRole)); // Should return true
  console.log('Test 2b - Invalid role:', isValidRoleTitle(invalidRole)); // Should return false
  
  // Test 3: Role extraction from body
  const testBody2 = "We are looking for a Senior Product Manager to join our team.";
  const extractedRole = extractRoleFromBody(testBody2);
  console.log('Test 3 - Role extraction:', extractedRole); // Should return "Senior Product Manager"
  
  // Test 4: Full email parsing with improvements
  const testSubject = "Software Engineer at TechCorp in Angeles";
  const testBody3 = "TechCorp is hiring a Software Engineer in Los Angeles, CA. Salary: $120k-150k. Apply now!";
  const parsedEmail = mapEmailFields(testSubject, testBody3, "jobs@indeed.com");
  console.log('Test 4 - Full parsing:', parsedEmail);
  
  console.log('Email parsing tests completed!');
}

</script>

</body>
</html>